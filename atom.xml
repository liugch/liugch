<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何有悠然</title>
  <subtitle>Liu Guangch&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liugch.top/"/>
  <updated>2017-02-08T12:48:47.101Z</updated>
  <id>http://liugch.top/</id>
  
  <author>
    <name>何有悠然</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 文件地址与缓存</title>
    <link href="http://liugch.top/2016/11/01/Android_%E6%96%87%E4%BB%B6%E7%9A%84%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BC%93%E5%AD%98/"/>
    <id>http://liugch.top/2016/11/01/Android_文件的地址和缓存/</id>
    <published>2016-11-01T11:45:02.000Z</published>
    <updated>2017-02-08T12:48:47.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件地址与缓存"><a href="#文件地址与缓存" class="headerlink" title="文件地址与缓存"></a>文件地址与缓存</h1><blockquote>
<p>getCacheDir()、getFilesDir()、getExternalFilesDir()、getExternalCacheDir()</p>
<p> 低版本时所需要的权限 在AndroidManifest文件中加入sdcard操作权限</p>
</blockquote>
<a id="more"></a>
<pre><code>&lt;uses-permission Android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;

&lt;!--在SDCard中创建与删除文件权限 --&gt;
&lt;uses-permissioandroid:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt; 
&lt;!--往SDCard写入数据权限 --&gt; 
　　 &lt;uses-permissionandroid:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 
</code></pre><ul>
<li>2 确认sdcard的存在<br>　　* android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED)</li>
<li>3 获取扩展存储设备的文件目录<br>　　* android.os.Environment.getExternalStorageDirectory();</li>
</ul>
<p><strong>本机</strong></p>
<p>getCacheDir():方法用于获取/data/data/<application package="">/cache目录</application></p>
<p>getFilesDir():方法用于获取/data/data/<application package="">/files目录</application></p>
<p><strong>SD开</strong></p>
<p>Context.getExternalFilesDir():方法可以获取到 SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据</p>
<p><strong>context.getExternalFilesDir(null)::/storage/emulated/0/Android/data/com.main.app.zxingdemo/files</strong></p>
<p><strong>getExternalFilesDir().getAbsolutePath:: /storage/emulated/0/Android/data/com.main.app.zxingdemo/files</strong></p>
<p>Context.getExternalCacheDir():方法可以获取到 SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据</p>
<p>如果使用上面的方法，当你的应用在被用户卸载后，SDCard/Android/data/你的应用的包名/ 这个目录下的所有文件都会被删除，不会留下垃圾信息。</p>
<p>而且上面二个目录分别对应-&gt;应用详情里面的”清除数据“与”清除缓存“选项</p>
<blockquote>
<p>一个获取缓存路劲的方法</p>
</blockquote>
<pre><code>/**
 * 一个方法来获取缓存地址
 * @param context
 * @return
 */
public String getDiskCacheDir(Context context) {
    String cachePath = null;
    if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
            || !Environment.isExternalStorageRemovable()) {
        cachePath = context.getExternalCacheDir().getPath();
    } else {
        cachePath = context.getCacheDir().getPath();
    }
    return cachePath;
}
</code></pre><blockquote>
<p>获取文件保存路径</p>
</blockquote>
<pre><code>/**
 *  获取文件保存的路劲
 * @param context
 * @return
 */
private String getFileRoot(Context context) {
    //判断sd卡是否存在也就是是否正常挂载
    if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
        File external = context.getExternalFilesDir(null);
        if (external != null) {
            // /storage/emulated/0/Android/data/com.main.app.zxingdemo/files
            return external.getAbsolutePath();
        }
    }
    ///data/data/com.main.app.zxingdemo/files
    return context.getFilesDir().getAbsolutePath();
}
</code></pre><blockquote>
<p>其它文件路径</p>
</blockquote>
<pre><code> Environment.getDataDirectory();
Environment.getDownloadCacheDirectory();
Environment.getExternalStorageDirectory();
Environment.getExternalStoragePublicDirectory(&quot;test&quot;);
Environment.getRootDirectory();
getPackageCodePath();
getPackageResourcePath();
getCacheDir() ;
getDatabasePath(&quot;test&quot;) ;
getDir(&quot;test&quot;, Context.MODE_PRIVATE) ;
getExternalCacheDir() ;
getExternalFilesDir(&quot;test&quot;);
getExternalFilesDir(null);
getFilesDir();
</code></pre><p><strong>执行后结果为:</strong></p>
<p><img src="http://i.imgur.com/agjdjCS.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文件地址与缓存&quot;&gt;&lt;a href=&quot;#文件地址与缓存&quot; class=&quot;headerlink&quot; title=&quot;文件地址与缓存&quot;&gt;&lt;/a&gt;文件地址与缓存&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;getCacheDir()、getFilesDir()、getExternalFilesDir()、getExternalCacheDir()&lt;/p&gt;
&lt;p&gt; 低版本时所需要的权限 在AndroidManifest文件中加入sdcard操作权限&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate</title>
    <link href="http://liugch.top/2016/11/01/Hibernate/"/>
    <id>http://liugch.top/2016/11/01/Hibernate/</id>
    <published>2016-10-31T16:13:25.000Z</published>
    <updated>2016-10-31T17:10:32.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate工作原理及为什么要用"><a href="#Hibernate工作原理及为什么要用" class="headerlink" title="Hibernate工作原理及为什么要用?"></a>Hibernate工作原理及为什么要用?</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>1.通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件<br>2.由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml">读取并解析映射信息<br>3.通过config.buildSessionFactory();//创建SessionFactory<br>4.sessionFactory.openSession();//打开Sesssion<br>5.session.beginTransaction();//创建事务Transation<br>6.persistent operate持久化操作<br>7.session.getTransaction().commit();//提交事务<br>8.关闭Session<br>9.关闭SesstionFactory<br><a id="more"></a></mapping></p>
<h2 id="为什么要用："><a href="#为什么要用：" class="headerlink" title="为什么要用："></a>为什么要用：</h2><ol>
<li><p>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p>
</li>
<li><p>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的        编码工作</p>
</li>
<li><p>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</p>
</li>
<li><p>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，    从一对一到多对多的各种复杂关系。</p>
</li>
</ol>
<blockquote>
<p>Hibernate是如何延迟加载?</p>
</blockquote>
<ol>
<li><p>Hibernate2延迟加载实现：a)实体对象 b)集合（Collection）</p>
</li>
<li><p>Hibernate3 提供了属性的延迟加载功能</p>
</li>
</ol>
<p>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</p>
<blockquote>
<p>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)</p>
</blockquote>
<p>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</p>
<h2 id="说下Hibernate的缓存机制"><a href="#说下Hibernate的缓存机制" class="headerlink" title="说下Hibernate的缓存机制"></a>说下Hibernate的缓存机制</h2><ol>
<li><p>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</p>
</li>
<li><p>二级缓存：</p>
<p>a) 应用及缓存 </p>
<p>b) 分布式缓存<br>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非 关键数据<br>c) 第三方缓存的实现</p>
</li>
</ol>
<p><strong>一级缓存：session级的缓存也叫事务级的缓存，只缓存实体，生命周期和session一致。不能对其进行管理。不用显示的调用</strong>。</p>
<p><strong>二级缓存：sessionFactory缓存，也叫进程级的缓存，使用第3方插件实现的，也值缓存实体，生命周期和sessionFactory一致，可以进行管理。</strong></p>
<p>首先配置第3放插件，我们用的是EHCache，在hibernate.cfg.xml文件中加入</p>
<pre><code>&lt;property name=&quot;hibernate.cache.user_second_level_cache&quot;&gt;true&lt;/property&gt;
</code></pre><p>在映射中也要显示的调用<br>    <cache usage="read-only"></cache></p>
<p>二</p>
<blockquote>
<p>级缓存之查询缓存：对普通属性进行缓存。如果关联的表发生了修改，那么查询缓存的生命周期也结束了。</p>
</blockquote>
<p><strong>在程序中必须手动启用查询缓存：query.setCacheable(true);</strong></p>
<blockquote>
<p>Hibernate的查询方式     Sql、Criteria,object comptosition</p>
<p>Hql：</p>
</blockquote>
<p>1、 属性查询<br>2、 参数查询、命名参数查询<br>3、 关联查询<br>4、 分页查询<br>5、 统计函数</p>
<h2 id="如何优化Hibernate？"><a href="#如何优化Hibernate？" class="headerlink" title="如何优化Hibernate？"></a><strong>如何优化Hibernate？</strong></h2><p>1.使用双向一对多关联，不使用单向一对多</p>
<p>2.灵活使用单向一对多关联</p>
<p>3.不用一对一，用多对一取代</p>
<p>4.配置对象缓存，不使用集合缓存</p>
<p>5.一对多集合使用Bag,多对多集合使用Set</p>
<p>6.继承类使用显式多态</p>
<p>7.表字段要少，表关联不要怕多，有二级缓存撑腰</p>
<blockquote>
<p>Hibernate有哪几种查询数据的方式</p>
</blockquote>
<p>  (1)导航对象图查询</p>
<p>  (2)OID查询</p>
<p>  (3)HQL</p>
<p>  (4)QBC</p>
<p>  (5)本地SQL</p>
<h2 id="load-和get-的区别"><a href="#load-和get-的区别" class="headerlink" title="load()和get()的区别"></a><strong>load()和get()的区别</strong></h2><p>Session.load/get方法均可以根据指定的实体类和id从数据库读取记录，并返回与之对应的实体对象。</p>
<p>如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObjectNotFoundException。<br>Load方法可返回实体的代理类实例，而get方法永远直接返回实体类。<br>load方法可以充分利用内部缓存和二级缓存中的现有数据，<br>而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，<br>直接调用SQL完成数据读取。</p>
<p>/<em>
  </em>load()方法的执行顺序如下：<br>  <em>a)：首先通过id在session缓存中查找对象，如果存在此id的对象，直接将其返回
  </em>b)：在二级缓存中查找，找到后将 其返回。<br>  <em>c)：如果在session缓存和二级缓存中都找不到此对象，则从数据库中加载有此ID的对象
  </em>因此load()方法并不总是导致SQL语句，只有缓存中无此数据时，才向数据库发送SQL！<br>  */</p>
<p> /<em>
  </em>与get()的区别：<br>  <em>1：在立即加载对象（当hibernate在从数据库中取得数据组装好一个对象后
  </em>会立即再从数据库取得数据此对象所关联的对象）时，如果对象存在，<br>  <em>load()和get()方法没有区别，都可以取得已初始化的对象;但如果当对
  </em>象不存在且是立即加载时，使用get()方法则返回null,而使用load()则<br>  <em>抛出一个异常。因此使用load()方法时，要确认查询的主键ID一定是存在
  </em>的，从这一点讲它没有get方便！<br>  <em>2：在延迟加载对象(Hibernate从数据库中取得数据组装好一个对象后，
  </em>不会立即再从数据库取得数据组装此对象所关联的对象，而是等到需要时，<br>  <em>都会从数据库取得数据组装此对象关联的对象)时，get()方法仍然使用
  </em>立即加载的方式发送SQL语句，并得到已初始化的对象，而load()方法则<br>  <em>根本不发送SQL语句，它返回一个代理对象，直到这个对象被访问时才被
  </em>初始化。<br>  */</p>
<p>get()—-不支持LAZY</p>
<p>load()—-支持LAZY</p>
<p>总之对于get和load的根本区别，一句话，hibernate对于load方法认为该数据在数据库中一定存在，<br>可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；<br>而对于get方法，hibernate一定要获取到真实的数据，否则返回null。<br>get方法首先查询session缓存，没有的话查询二级缓存，最后查询数据库；<br>反而load方法创建时首先查询session缓存，没有就创建代理，实际使用数据时才查询二级缓存和数据库</p>
<blockquote>
<p>引用链接</p>
</blockquote>
<p><a href="http://sishuok.com/forum/blogPost/list/2936.html" target="_blank" rel="external">http://sishuok.com/forum/blogPost/list/2936.html</a><br><a href="http://www.cnblogs.com/javaNewegg/archive/2011/08/28/2156521.html" target="_blank" rel="external">http://www.cnblogs.com/javaNewegg/archive/2011/08/28/2156521.html</a><br><a href="http://blog.csdn.net/zhaoshl_368/article/details/6577103" target="_blank" rel="external">http://blog.csdn.net/zhaoshl_368/article/details/6577103</a></p>
<h2 id="hibernate-主键生成策略"><a href="#hibernate-主键生成策略" class="headerlink" title="hibernate 主键生成策略"></a>hibernate 主键生成策略</h2><pre><code>&lt;id name=&quot;id&quot; length=&quot;22&quot; &gt;
    &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;
&lt;/id&gt;
</code></pre><p><a href="http://www.cnblogs.com/xlwmin/articles/2189427.html" target="_blank" rel="external">http://www.cnblogs.com/xlwmin/articles/2189427.html</a></p>
<blockquote>
<p>注意:<br>    在HQL,您应该使用映射的java类名和属性名@ entity,而不是实际的表名和列名<br>List&lt;?&gt; result = session.createQuery(“from Student”).list();</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate工作原理及为什么要用&quot;&gt;&lt;a href=&quot;#Hibernate工作原理及为什么要用&quot; class=&quot;headerlink&quot; title=&quot;Hibernate工作原理及为什么要用?&quot;&gt;&lt;/a&gt;Hibernate工作原理及为什么要用?&lt;/h1&gt;&lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h2&gt;&lt;p&gt;1.通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件&lt;br&gt;2.由hibernate.cfg.xml中的&lt;mapping resource=&quot;com/xx/User.hbm.xml&quot;/&gt;读取并解析映射信息&lt;br&gt;3.通过config.buildSessionFactory();//创建SessionFactory&lt;br&gt;4.sessionFactory.openSession();//打开Sesssion&lt;br&gt;5.session.beginTransaction();//创建事务Transation&lt;br&gt;6.persistent operate持久化操作&lt;br&gt;7.session.getTransaction().commit();//提交事务&lt;br&gt;8.关闭Session&lt;br&gt;9.关闭SesstionFactory&lt;br&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://liugch.top/categories/Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://liugch.top/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Struts2 中一些配置</title>
    <link href="http://liugch.top/2016/10/29/Struts2%20%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/"/>
    <id>http://liugch.top/2016/10/29/Struts2 一些配置/</id>
    <published>2016-10-29T02:02:03.000Z</published>
    <updated>2017-02-08T12:41:52.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Struts2-中的一些简单的配置"><a href="#Struts2-中的一些简单的配置" class="headerlink" title="Struts2 中的一些简单的配置"></a>Struts2 中的一些简单的配置</h1><h3 id="在web-xml-中"><a href="#在web-xml-中" class="headerlink" title="在web.xml 中:"></a>在web.xml 中:</h3><pre><code>&lt;filter&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><a id="more"></a>
<h3 id="在Struts-xml-中"><a href="#在Struts-xml-中" class="headerlink" title="在Struts.xml 中:"></a>在Struts.xml 中:</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE struts PUBLIC
    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;
&lt;struts&gt;
    &lt;!-- 动态方法调用,一般都是为 false --&gt;
    &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot; /&gt;
    &lt;!-- 是否启用开发者模式 --&gt;
    &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt;

    &lt;package name=&quot;hehe&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;
        &lt;!--默认的要到的位置  --&gt;
        &lt;!-- &lt;default-action-ref name=&quot;index&quot; /&gt; --&gt;


        &lt;!-- 什么异常 对应的 --&gt;
        &lt;global-exception-mappings&gt;
            &lt;exception-mapping exception=&quot;java.lang.Exception&quot; result=&quot;error&quot;/&gt;
        &lt;/global-exception-mappings&gt;

        &lt;!-- 全局错误页面 --&gt;
        &lt;global-results&gt;
            &lt;result name=&quot;error&quot;&gt;/WEB-INF/jsp/error.jsp&lt;/result&gt;
        &lt;/global-results&gt;

      &lt;!--&lt;action name=&quot;index&quot;&gt;
            &lt;result type=&quot;redirectAction&quot;&gt;
                &lt;param name=&quot;actionName&quot;&gt;HelloWorld&lt;/param&gt;
                &lt;param name=&quot;namespace&quot;&gt;/example&lt;/param&gt;
            &lt;/result&gt;
        &lt;/action&gt; --&gt;

    &lt;/package&gt;

    &lt;include file=&quot;student.xml&quot;/&gt;
&lt;/struts&gt;
</code></pre><h3 id="Struts中表单的验证"><a href="#Struts中表单的验证" class="headerlink" title="Struts中表单的验证"></a>Struts中表单的验证</h3><p><img src="http://i.imgur.com/HAIFjK5.png" alt="验证格式图"></p>
<p>UserAction-loginSubmit-validation.xml</p>
<p><strong>UserAction:action 类名;loginSubmit:该类中的方法名;validation:必须这个结尾;</strong></p>
<p><strong>如果没有loginSubmit:说明UserAction 中的所用的方法都会验证;</strong></p>
<blockquote>
<p>验证的规则我们可以看文档;下载下来的 Struts中就有,下面一些简单的例子;</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE validators PUBLIC
    &quot;-//Apache Struts//XWork Validator 1.0.3//EN&quot;
    &quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&quot;&gt;    

&lt;validators&gt;
    &lt;!-- 与页面form表单对应的 name 的值 --&gt;
    &lt;field name=&quot;uname&quot;&gt;
        &lt;field-validator type=&quot;requiredstring&quot;&gt;
            &lt;param name=&quot;trim&quot;&gt;true&lt;/param&gt;  
            &lt;message&gt;用户名不能为空！&lt;/message&gt;
        &lt;/field-validator&gt;

        &lt;field-validator type=&quot;regex&quot;&gt;
            &lt;!-- param name值为：regex：正则表达式  --&gt;
            &lt;param name=&quot;regex&quot;&gt;&lt;![CDATA[(\w{5,})]]&gt;&lt;/param&gt;
            &lt;message&gt;长度要大于5位！&lt;/message&gt;
        &lt;/field-validator&gt;    
    &lt;/field&gt;

    &lt;field name=&quot;upwd&quot;&gt;
        &lt;field-validator type=&quot;requiredstring&quot;&gt;
            &lt;param name=&quot;trim&quot;&gt;true&lt;/param&gt;
            &lt;message&gt;密码不能为空！&lt;/message&gt;
        &lt;/field-validator&gt;

        &lt;field-validator type=&quot;regex&quot;&gt;
            &lt;param name=&quot;regex&quot;&gt;&lt;![CDATA[(^\w*$)]]&gt;&lt;/param&gt;
            &lt;message&gt;密码不合理含有非法字符&lt;/message&gt;
        &lt;/field-validator&gt;

        &lt;field-validator type=&quot;stringlength&quot;&gt;
            &lt;param name=&quot;minLength&quot;&gt;6&lt;/param&gt;
            &lt;param name=&quot;maxLength&quot;&gt;16&lt;/param&gt;
            &lt;message&gt;&lt;![CDATA[密码必须在6到16之间]]&gt;&lt;/message&gt;
        &lt;/field-validator&gt;

    &lt;/field&gt;
    &lt;field name=&quot;reupwd&quot;&gt;
        &lt;field-validator type=&quot;fieldexpression&quot;&gt;
               &lt;param name=&quot;expression&quot;&gt;&lt;![CDATA[reupwd==upwd]]&gt;&lt;/param&gt;
               &lt;message&gt;密码不一致！&lt;/message&gt;
         &lt;/field-validator&gt;
    &lt;/field&gt;

    &lt;field name=&quot;birth&quot;&gt;
        &lt;field-validator type=&quot;date&quot;&gt;
            &lt;param name=&quot;min&quot;&gt;2015-1-1&lt;/param&gt;
            &lt;param name=&quot;max&quot;&gt;2016-12-12&lt;/param&gt;
            &lt;message&gt;日期范围有误！请重新输入!&lt;/message&gt;
        &lt;/field-validator&gt;
    &lt;/field&gt;
&lt;/validators&gt;
</code></pre><p><strong>Make sure there is a result for “input” listed in the struts.xml for when the validation fails:</strong></p>
<p><strong>一定要在Struts.xml 写入 action中 result 名为:input 的返回页面,不然会报错</strong></p>
<blockquote>
<p>Struts2 中自定义拦截器</p>
</blockquote>
<ol>
<li>写一个类 继承 AbstractInterceptor</li>
<li>在xml 中使用</li>
</ol>
<p>课参考老师笔记 github.com/s126; notes;</p>
<blockquote>
<p>Struts2 中的国际化,ognl表达式,值栈, 获取值栈中的值;  值的获取… 笔记中;;</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Struts2-中的一些简单的配置&quot;&gt;&lt;a href=&quot;#Struts2-中的一些简单的配置&quot; class=&quot;headerlink&quot; title=&quot;Struts2 中的一些简单的配置&quot;&gt;&lt;/a&gt;Struts2 中的一些简单的配置&lt;/h1&gt;&lt;h3 id=&quot;在web-xml-中&quot;&gt;&lt;a href=&quot;#在web-xml-中&quot; class=&quot;headerlink&quot; title=&quot;在web.xml 中:&quot;&gt;&lt;/a&gt;在web.xml 中:&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Struts2" scheme="http://liugch.top/categories/Struts2/"/>
    
    
      <category term="Struts2" scheme="http://liugch.top/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Spring 一些基本的注解的使用</title>
    <link href="http://liugch.top/2016/10/28/Spring%20%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://liugch.top/2016/10/28/Spring 一些注解的基本使用/</id>
    <published>2016-10-28T11:40:07.000Z</published>
    <updated>2017-02-08T12:32:53.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Spring Bean 的一些配置</p>
</blockquote>
<p><strong>id:</strong> Bean唯一标识</p>
<p><strong>Class:</strong> Bean 对应的Class 类</p>
<p><strong>lazy-init:</strong><br>值为: TRUE / false </p>
<a id="more"></a>
<p>默认为: false</p>
<p>定义这个Bean是否懒初始化(就是用到这个Bean的时候才初始化)</p>
<p><strong>singleton:</strong><br>值为: TRUE / false </p>
<p>默认为: TRUE;</p>
<p>定义这个Bean 是否是单例模式,如果是false的话:每获取该Bean 的时候 都不是同一个Bean实例 ,会重新创建一个;</p>
<h3 id="autowire"><a href="#autowire" class="headerlink" title="autowire:"></a>autowire:</h3><p>值为:<br>byName 根据名字装配</p>
<p>byType    根据类型装配</p>
<p>constructor 根据构造器装配</p>
<p>默认:default no ;</p>
<p>定义这个Bean的时候是否自动注入其它的Bean的实例;</p>
<p>比如autowire=”byName”,<br>如果该Bean对应类中有其它Bean类型的变量时:并且<strong>该变量的属性名 和 xml中定义的某个Bean的id 相同</strong><br>就会把这个Bean自动注入进去</p>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope:"></a>scope:</h3><p>值为:<br>singleton(单例)<br>prototype(重新创建实例) 一般用在Action</p>
<p>request,session,global session 仅用于web中;</p>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract:"></a>abstract:</h3><p>值为: TRUE / false</p>
<p>默认: false;</p>
<p>定义一个Bean是否是抽象Bean, 表示该Bean 不被实例化;</p>
<p><strong>一般用于,一些 属性不会经常改变; 经常会被其它的Bean 给继承;</strong></p>
<h3 id="parent"><a href="#parent" class="headerlink" title="parent:"></a>parent:</h3><p>值为: 其它 Bean的id值;</p>
<p><strong>表示继承对应id的Bean ;</strong></p>
<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on:"></a>depends-on:</h3><p>值为: 其它 Bean的id值;</p>
<p>表示实例化该Bean的时候 , <strong>先实例化和 depends-on值的Bean的实例;</strong></p>
<h3 id="init-method"><a href="#init-method" class="headerlink" title="init-method:"></a>init-method:</h3><p>用来定义Bean的初始化方法，它会在Bean组装之后调用。它必须是一个无参数的方法。 </p>
<h3 id="destroy-method："><a href="#destroy-method：" class="headerlink" title="destroy-method："></a>destroy-method：</h3><p>用来定义Bean的销毁方法，它在BeanFactory关闭时调用。同样，它也必须是一个无参数的方法。它只能应用于singleton Bean。 </p>
<h3 id="factory-method："><a href="#factory-method：" class="headerlink" title="factory-method："></a>factory-method：</h3><p>定义创建该Bean对象的工厂方法。它用于下面的“factory-bean”，表示这个Bean是通过工厂方法创建。此时，“class”属性失效。 </p>
<h3 id="factory-bean"><a href="#factory-bean" class="headerlink" title="factory-bean:"></a>factory-bean:</h3><p>定义创建该Bean对象的工厂类。如果使用了“factory-bean”则“class”属性失效。</p>
<hr>
<blockquote>
<p>如果有很多的xml 可以使用import 导入<br>在集合其它框架整合的时候. 还有其它方式进行导入</p>
</blockquote>
<pre><code>&lt;import resource=&quot;spring-test.xml&quot;/&gt;
</code></pre><blockquote>
<p>当使用注解的时候  需要定义如下:</p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.liugch&quot;&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;com.liugch.entity&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre><blockquote>
<p> 当要加载 其它的配置文件的时候 如:properties 文件时</p>
</blockquote>
<pre><code>&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;
</code></pre><hr>
<blockquote>
<p> Spring 中一些常用的注解</p>
</blockquote>
<p>@Component</p>
<p>@Repository</p>
<p>@Service</p>
<p>@Controller</p>
<p>上面都是一样的作用: 用来 让一个类让Spring容器来管理 , 相当于生成了一个Bean</p>
<p>@Resource</p>
<p>@Autowired</p>
<p>@Qualifier</p>
<p>上面用注入: 一般用 @Resource 就行了</p>
<p>@Scope(“prototype”) </p>
<p>让该类不是使用单例;重新创建新的实例;</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Spring Bean 的一些配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;id:&lt;/strong&gt; Bean唯一标识&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class:&lt;/strong&gt; Bean 对应的Class 类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lazy-init:&lt;/strong&gt;&lt;br&gt;值为: TRUE / false &lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://liugch.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://liugch.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SSH 整合笔记</title>
    <link href="http://liugch.top/2016/10/28/SSH%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/"/>
    <id>http://liugch.top/2016/10/28/SSH整合笔记/</id>
    <published>2016-10-28T11:40:07.000Z</published>
    <updated>2017-02-08T12:39:29.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>SSH笔记</p>
</blockquote>
<p>rasphone  连接网络</p>
<blockquote>
<p>Spring 的使用教程</p>
</blockquote>
<h2 id="http-wiki-jikexueyuan-com-project-spring"><a href="#http-wiki-jikexueyuan-com-project-spring" class="headerlink" title="http://wiki.jikexueyuan.com/project/spring/ "></a><a href="http://wiki.jikexueyuan.com/project/spring/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/spring/</a> </h2><a id="more"></a>
<blockquote>
<p>Hibernate.initialize(autho.getBook()) 显式 lazy对象</p>
</blockquote>
<hr>
<blockquote>
<p>Struts2 几种获取参数的方法 </p>
<h2 id="https-my-oschina-net-u-1398304-blog-215874"><a href="#https-my-oschina-net-u-1398304-blog-215874" class="headerlink" title="https://my.oschina.net/u/1398304/blog/215874"></a><a href="https://my.oschina.net/u/1398304/blog/215874" target="_blank" rel="external">https://my.oschina.net/u/1398304/blog/215874</a></h2><p>SSH 整合的一些思路及案例</p>
<h2 id="http-blog-csdn-net-zhuanzhe117-article-details-48014545"><a href="#http-blog-csdn-net-zhuanzhe117-article-details-48014545" class="headerlink" title="http://blog.csdn.net/zhuanzhe117/article/details/48014545"></a><a href="http://blog.csdn.net/zhuanzhe117/article/details/48014545" target="_blank" rel="external">http://blog.csdn.net/zhuanzhe117/article/details/48014545</a></h2><p>SpringMVC 的一些配置</p>
<h2 id="https-segmentfault-com-a-1190000005670764-articleHeader7"><a href="#https-segmentfault-com-a-1190000005670764-articleHeader7" class="headerlink" title="https://segmentfault.com/a/1190000005670764#articleHeader7"></a><a href="https://segmentfault.com/a/1190000005670764#articleHeader7" target="_blank" rel="external">https://segmentfault.com/a/1190000005670764#articleHeader7</a></h2><p>SpringMVC 的一些笔记</p>
<h2 id="http-www-imooc-com-article-1392"><a href="#http-www-imooc-com-article-1392" class="headerlink" title="http://www.imooc.com/article/1392"></a><a href="http://www.imooc.com/article/1392" target="_blank" rel="external">http://www.imooc.com/article/1392</a></h2><p>maven 中oracle jar包</p>
</blockquote>
<p>到达下载后的jar包的位置 执行下面语句</p>
<p>mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0 -Dpackaging=jar -Dfile=ojdbc6.jar -DgeneratePom=true </p>
<hr>
<blockquote>
<p>大神的博客</p>
</blockquote>
<h2 id="http-blog-csdn-net-fengshizty-viewmode-list"><a href="#http-blog-csdn-net-fengshizty-viewmode-list" class="headerlink" title="http://blog.csdn.net/fengshizty?viewmode=list"></a><a href="http://blog.csdn.net/fengshizty?viewmode=list" target="_blank" rel="external">http://blog.csdn.net/fengshizty?viewmode=list</a></h2><blockquote>
<p>无法访问服务器</p>
</blockquote>
<p>1.没有部署到服务器中;<br>2.配置中访问地址已经出错;</p>
<blockquote>
<p>防止访问时路径有问题<br>    <base href="${pageContext.request.scheme}://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/"></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SSH笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;rasphone  连接网络&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring 的使用教程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;http-wiki-jikexueyuan-com-project-spring&quot;&gt;&lt;a href=&quot;#http-wiki-jikexueyuan-com-project-spring&quot; class=&quot;headerlink&quot; title=&quot;http://wiki.jikexueyuan.com/project/spring/ &quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/spring/&quot;&gt;http://wiki.jikexueyuan.com/project/spring/&lt;/a&gt; &lt;/h2&gt;
    
    </summary>
    
      <category term="SSH" scheme="http://liugch.top/categories/SSH/"/>
    
    
      <category term="Spring" scheme="http://liugch.top/tags/Spring/"/>
    
      <category term="SSH" scheme="http://liugch.top/tags/SSH/"/>
    
      <category term="Hibernate" scheme="http://liugch.top/tags/Hibernate/"/>
    
      <category term="Struts2" scheme="http://liugch.top/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Spring Test Junit 基本使用</title>
    <link href="http://liugch.top/2016/10/28/spring%20junit%20%20%E6%80%BB%E7%BB%93/"/>
    <id>http://liugch.top/2016/10/28/spring junit  总结/</id>
    <published>2016-10-28T09:20:10.000Z</published>
    <updated>2017-02-08T12:29:06.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>IDEA Spring Junit 单元测试</p>
</blockquote>
<p>参考文档：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-springunitest/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-springunitest/</a></p>
<a id="more"></a>
<blockquote>
<p>一些简单注解<br>@BeforeClass</p>
</blockquote>
<p><strong>用来执行整个测试类需要一次性初始化的环境 如加载spring中配置文件</strong></p>
<p>@RunWith </p>
<p><strong>注释标签是 Junit 提供的，用来说明此测试类的运行者，这里用了SpringJUnit4ClassRunner，</strong><br><strong>这个类是一个针对 Junit 运行环境的自定义扩展，用来标准化在 Spring 环境中 Junit4.5 的测试用例，</strong><br><strong>例如支持的注释标签的标准化</strong></p>
<p>@ContextConfiguration </p>
<p><strong>注释标签是 Spring test context 提供的，用来指定 Spring 配置信息的来源</strong></p>
<p>@Transactional </p>
<p><strong>注释标签是表明此测试类的事务启用，这样所有的测试方案都会自动的 rollback，即您不用自己清除自己所做的任何对数据库的变更了</strong></p>
<p>@ActiveProfiles(“test”) </p>
<p><strong>@ActiveProfiles，可以指定一个或者多个 profile，这样我们的测试类就仅仅加载这些名字的 profile 中定义的 bean 实例。</strong></p>
<p>@Repeat(3)</p>
<p><strong>通过 @Repeat，您可以轻松的多次执行测试用例，而不用自己写 for 循环</strong></p>
<hr>
<p><strong>对 TestNG 的支持</strong><br>Spring 2.5 以后，就开始支持 TestNG 了，支持的方法包括：<br>将您的 TestNG 测试<strong>类继承 Spring 的测试父类</strong>：<br>AbstractTransactionalTestNGSpringContextTests 或者 AbstractTestNGSpringContextTests，<br>这样您的 TestNG 测试类内部就可以访问 applicationContext 成员变量了</p>
<p><strong>不继承 Spring 父类</strong>，在测试类上使用<br>@TestExecutionListeners 注释标签，可以引入的监听器包括<br>DependencyInjectionTestExecutionListener：使得测试类拥有依赖注入特性<br>DirtiesContextTestExecutionListener：使得测试类拥有更新 applicationContext 能力<br>TransactionalTestExecutionListener：使得测试类拥有自动的事务管理能力</p>
<hr>
<blockquote>
<p>@Autowired注解、@Resource注解的区别  一般都会用 @Resource</p>
</blockquote>
<p><strong>@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了</strong><br><strong>@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。</strong><br><strong>所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。</strong><br><strong>如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</strong></p>
<blockquote>
<p>hibernate 不同版本的 SchemaExport 区别</p>
</blockquote>
<pre><code> @Test
public void ExportDB() {
    ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();
    Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
    SchemaExport export = new SchemaExport();
    export.create(EnumSet.of(TargetType.DATABASE), metadata);
 /*   // 默认读取hibernate.cfg.xml文件
    Configuration cfg = new Configuration().configure();

    // 生成并输出sql到文件（当前目录）和数据库
    SchemaExport schemaExport = new SchemaExport(cfg);

    // true 在控制台打印sql语句，true 导入sql语句到数据库，即可执行
    schemaExport.create(true, false);*/

/*    ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();

    MetadataImplementor metadataImplementor = (MetadataImplementor)
            new MetadataSources(serviceRegistry).buildMetadata();

    SchemaExport export = new SchemaExport(serviceRegistry, metadataImplementor);
    export.create(true, true);*/
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;IDEA Spring Junit 单元测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-springunitest/&quot;&gt;http://www.ibm.com/developerworks/cn/java/j-lo-springunitest/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://liugch.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://liugch.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Android WebView 的使用</title>
    <link href="http://liugch.top/2016/10/25/Android_WebView/"/>
    <id>http://liugch.top/2016/10/25/Android_WebView/</id>
    <published>2016-10-25T11:45:30.000Z</published>
    <updated>2017-02-08T12:46:01.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebView-基本使用"><a href="#WebView-基本使用" class="headerlink" title="WebView 基本使用"></a>WebView 基本使用</h1><blockquote>
<p>WebView控件之WebSettings各种配置方法</p>
<p><a href="http://teachcourse.cn/android-webview-websettings" target="_blank" rel="external">http://teachcourse.cn/android-webview-websettings</a></p>
</blockquote>
<a id="more"></a>
<p><strong>设置WebView要显示的网页：</strong></p>
<p>互联网用：webView.loadUrl(“<a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a>“); </p>
<p>本地文件用：webView.loadUrl(“file:///android_asset/XX.html”);  </p>
<p>本地文件存放在：assets文件中</p>
<p><strong>设置WebView是否支持Javascript</strong></p>
<p>如果访问的页面中有JavaScript，则webview必须设置支持Javascript<br>webview.getSettings().setJavaScriptEnabled(true);  </p>
<hr>
<blockquote>
<p>android 各种所需的权限</p>
<p><a href="http://blog.csdn.net/sweetburden2011/article/details/9167353" target="_blank" rel="external">http://blog.csdn.net/sweetburden2011/article/details/9167353</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WebView-基本使用&quot;&gt;&lt;a href=&quot;#WebView-基本使用&quot; class=&quot;headerlink&quot; title=&quot;WebView 基本使用&quot;&gt;&lt;/a&gt;WebView 基本使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;WebView控件之WebSettings各种配置方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://teachcourse.cn/android-webview-websettings&quot;&gt;http://teachcourse.cn/android-webview-websettings&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 自学笔记</title>
    <link href="http://liugch.top/2016/10/15/Android%20%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://liugch.top/2016/10/15/Android 自学笔记/</id>
    <published>2016-10-15T11:40:00.000Z</published>
    <updated>2017-02-08T12:44:13.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="love-android"><a href="#love-android" class="headerlink" title="love android"></a>love android</h1><blockquote>
<p>自学的道路走起….</p>
<p>酷爱的资源网站 受益匪浅 …. </p>
<p>从此爱上了android的世界…</p>
<p>让我们一起踏上生命的航帆,让生命不息….</p>
</blockquote>
<a id="more"></a>
<p>鸿神: <a href="http://www.xueandroid.com/" title="鸿神" target="_blank" rel="external">http://www.xueandroid.com/</a></p>
<p>郭神:<a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">http://blog.csdn.net/guolin_blog</a></p>
<p>生命一号博客: <a href="http://www.cnblogs.com/smyhvae/p/4799730.html" target="_blank" rel="external">http://www.cnblogs.com/smyhvae/p/4799730.html</a></p>
<p>okhttps工具: <a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="external">https://github.com/hongyangAndroid/okhttputils</a></p>
<blockquote>
<p>android 图片的在线制作</p>
</blockquote>
<p><a href="https://romannurik.github.io/AndroidAssetStudio/icons-generic.html#source.type=image&amp;source.space.trim=1&amp;source.space.pad=-0.1&amp;size=24&amp;padding=0&amp;color=33b5e5%2C100&amp;name=ic_hehe" target="_blank" rel="external">https://romannurik.github.io/AndroidAssetStudio/icons-generic.html#source.type=image&amp;source.space.trim=1&amp;source.space.pad=-0.1&amp;size=24&amp;padding=0&amp;color=33b5e5%2C100&amp;name=ic_hehe</a></p>
<blockquote>
<p>图片乱选,OOM 等问题</p>
</blockquote>
<p><a href="http://blog.csdn.net/chinese_zhang/article/details/48470413" target="_blank" rel="external">http://blog.csdn.net/chinese_zhang/article/details/48470413</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/9316683</a></p>
<p><a href="http://blog.csdn.net/gao_chun/article/details/48550117" target="_blank" rel="external">http://blog.csdn.net/gao_chun/article/details/48550117</a></p>
<blockquote>
<p>Axure RP 8 的使用</p>
</blockquote>
<p> <a href="http://flavienlaurent.com/blog/2013/11/20/making-your-action-bar-not-boring/" target="_blank" rel="external">http://flavienlaurent.com/blog/2013/11/20/making-your-action-bar-not-boring/</a></p>
<blockquote>
<p>移动设备原型尺寸计算工具</p>
</blockquote>
<p><a href="http://www.iaxure.com/share/yxcc/" target="_blank" rel="external">http://www.iaxure.com/share/yxcc/</a></p>
<blockquote>
<p>fontawesome 字体的使用</p>
</blockquote>
<p><a href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" target="_blank" rel="external">https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css</a></p>
<blockquote>
<p>SwipeRefreshLayout 的使用，自定义SwipeRefreshLayout</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/d23b42b6360b" target="_blank" rel="external">http://www.jianshu.com/p/d23b42b6360b</a></p>
<blockquote>
<p>Intellij IDEA 的快捷键  同时也是用于andriod studio的快捷键</p>
</blockquote>
<p><a href="http://www.phperz.com/article/15/0923/159042.html" target="_blank" rel="external">http://www.phperz.com/article/15/0923/159042.html</a></p>
<blockquote>
<p>Intellij IDEA 中没有输入后就有 提示功能 问题</p>
</blockquote>
<p>解决： 把 编辑器中的 省电模式给关掉</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;love-android&quot;&gt;&lt;a href=&quot;#love-android&quot; class=&quot;headerlink&quot; title=&quot;love android&quot;&gt;&lt;/a&gt;love android&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;自学的道路走起….&lt;/p&gt;
&lt;p&gt;酷爱的资源网站 受益匪浅 …. &lt;/p&gt;
&lt;p&gt;从此爱上了android的世界…&lt;/p&gt;
&lt;p&gt;让我们一起踏上生命的航帆,让生命不息….&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android BraodCastReceiver 基本使用</title>
    <link href="http://liugch.top/2016/09/28/Android%20BraodCastReceiver%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://liugch.top/2016/09/28/Android BraodCastReceiver 的基本使用/</id>
    <published>2016-09-28T11:40:51.000Z</published>
    <updated>2017-02-08T12:24:28.505Z</updated>
    
    <content type="html"><![CDATA[<p>BroadCastReceiver（广播接受者）<br>用于接收广播，一个广播可以被多个广播接受者所接收<br>自身并不实现图形用户界面，当它收到某个通知后<br>BroadCastReceiver 可以启动Activity 作为相应，<br>或者通过NotificationManager 提醒用户，或者启动Service 等等</p>
<a id="more"></a>
<blockquote>
<p>常见的系统广播</p>
</blockquote>
<p>Android 系统在运行的过程中，会产生很多事件， 比如开机，电量改变，收发短信，拨打电话，屏幕锁屏</p>
<blockquote>
<p>BroadCastReceiver 配置方式</p>
</blockquote>
<p>静态注册：不够灵活，程序退出后还是可以 接收广播<br>第一步，写一个写继承BroadCastReceiver<br>第二步，在Androidmanifest 清单文件中配置<br>拨打电话广播:</p>
<pre><code>/**
 * Created by Administrator on 2017/1/3.
 * 接收打电话的广播接受者
 */

public class CallReceiver extends BroadcastReceiver {
    // 接收信息
    @Override
    public void onReceive(Context context, Intent intent) {
        // 获取电话号码
        String number = getResultData();
        Log.i(TAG, &quot;onReceive:&quot;+number);
        // 改变电话号码
        setResultData(&quot;10086&quot;);
        String number2 = getResultData();
        Log.i(TAG, &quot;onReceive:&quot;+number2);
    }
}

&lt;!--电话权限--&gt;
    &lt;uses-permission android:name=&quot;android.permission.PROCESS_OUTGOING_CALLS&quot;&gt;&lt;/uses-permission&gt;
   &lt;!--电话广播 --&gt;
&lt;receiver android:name=&quot;.Receiver.CallReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.NEW_OUTGOING_CALL&quot;&gt;&lt;/action&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><p>动态注册: 更加的灵活<br>在程序中使用registerReceiver注册。<br>使用unregiesterReciver()方法取消注册。</p>
<blockquote>
<p>一个短息拦截 小案例</p>
<p>参考 <a href="http://blog.csdn.net/qq_26787115/article/details/51113053" target="_blank" rel="external">http://blog.csdn.net/qq_26787115/article/details/51113053</a></p>
</blockquote>
<pre><code>  /**
 * Created by Administrator on 2017/1/4.
 * 接收 短信的广播接收者
 *
 * 短信拦截器
 */
public class SMSReceiver extends BroadcastReceiver {

private static final String TAG =&quot;SMSReceiver&quot; ;
    @RequiresApi(api = Build.VERSION_CODES.M)
    @Override
    public void onReceive(Context context, Intent intent) {

        SmsMessage[] messages= SMSReceiver.getMessagesFromIntent(intent);
        for (SmsMessage message : messages) {
            //获取发件人号码
            String toPhone = message.getOriginatingAddress();
            //获取短信内容
            String smsContent = message.getMessageBody();
            Log.i(&quot;SMSReceiver&quot;, &quot;发件人号码:&quot; + toPhone + &quot;短信内容&quot; + smsContent);

            //判断是否是拦截的号码
            if (toPhone.equals(&quot;12345678910&quot;)) {
                //拦截广播
                abortBroadcast();
            }
        }
    }

    /**
     *  通过意图获取所有的短信信息
     * @param intent
     * @return
     */
    @RequiresApi(api = Build.VERSION_CODES.M)
    public static SmsMessage[] getMessagesFromIntent(Intent intent) {

        Log.i(TAG, &quot;onReceive: &quot; + &quot;收到短信&quot;);
        // 获取短信内容
        Object[] messages = (Object[]) intent.getSerializableExtra(&quot;pdus&quot;);
        String format = intent.getStringExtra(&quot;format&quot;);
        int pduCount = messages.length;
        SmsMessage[] msgs = new SmsMessage[pduCount];

        for (int i = 0; i &lt; pduCount; i++) {
            byte[] pdu = (byte[]) messages[i];
            //把数组元素转换成短信对象
            msgs[i] = SmsMessage.createFromPdu(pdu, format);
        }
        return msgs;
    }

}

 &lt;!--短信权限--&gt;
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;

&lt;!--注册短信广播--&gt;
&lt;receiver android:name=&quot;.Receiver.SMSReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;!--定义接收的广播,被Google隐藏的权限操作--&gt;
        &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><p>这样我们运行之下，你会发现，虽然走到拦截这一步，但是并没有阻止显示在短信收件箱里，这里，我们要注意一个优势，就是广播接收者是有优先级定义的，我们只需要在<strong>清单注册根节点</strong>的intent-filter标签里定义一个</p>
<blockquote>
<p>android:priority=”1000”</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BroadCastReceiver（广播接受者）&lt;br&gt;用于接收广播，一个广播可以被多个广播接受者所接收&lt;br&gt;自身并不实现图形用户界面，当它收到某个通知后&lt;br&gt;BroadCastReceiver 可以启动Activity 作为相应，&lt;br&gt;或者通过NotificationManager 提醒用户，或者启动Service 等等&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 第三方SDK 遇到的坑</title>
    <link href="http://liugch.top/2016/09/27/android%E7%AC%AC%E4%B8%89%E6%96%B9SDK%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://liugch.top/2016/09/27/android第三方SDK遇到的坑/</id>
    <published>2016-09-27T09:40:51.000Z</published>
    <updated>2017-02-08T12:21:23.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微博中．．．"><a href="#微博中．．．" class="headerlink" title="微博中．．．"></a>微博中．．．</h2><blockquote>
<p>异常</p>
</blockquote>
<p> AndroidStudio-/vendor/lib, /system/lib]]] couldn’t find “libweibosdkcore.so”</p>
<blockquote>
<p>成功的解决方案</p>
</blockquote>
<a id="more"></a>
<p>导入 下载下来SDK中的 weiboSDKCore_3.1.4.jar 和 libs 下的含有<strong>.so的文件夹</strong>放到libs中,</p>
<p>出现上面的错误,就在和 <strong>main同一级下新建 一个文件夹下,把含有.so的文件夹放入其中</strong>;</p>
<p>然后app 下的 H:\projects\weibo\app\build.gradle 文件中添加如下配置:</p>
<p>最后 <strong>一定要 Sync 一下</strong>;</p>
<pre><code>task nativeLibsToJar(type: Zip, description: &quot;create a jar archive of the native libs&quot;) {
    destinationDir file(&quot;$projectDir/libs&quot;)
    baseName &quot;Native_Libs2&quot;
    extension &quot;jar&quot;
    from fileTree(dir: &quot;libs&quot;, include: &quot;**/*.so&quot;)
    into &quot;lib&quot;
}

tasks.withType(JavaCompile) {
    compileTask -&gt; compileTask.dependsOn(nativeLibsToJar)
}
</code></pre><blockquote>
<p>放入的文件的结构图如下</p>
</blockquote>
<p><img src="http://i.imgur.com/EMXX6Fw.png" alt="结构图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;微博中．．．&quot;&gt;&lt;a href=&quot;#微博中．．．&quot; class=&quot;headerlink&quot; title=&quot;微博中．．．&quot;&gt;&lt;/a&gt;微博中．．．&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; AndroidStudio-/vendor/lib, /system/lib]]] couldn’t find “libweibosdkcore.so”&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;成功的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
      <category term="SDK" scheme="http://liugch.top/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>Android Menu</title>
    <link href="http://liugch.top/2016/09/26/Android_menu/"/>
    <id>http://liugch.top/2016/09/26/Android_menu/</id>
    <published>2016-09-26T04:50:01.000Z</published>
    <updated>2017-02-08T12:26:06.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Meau"><a href="#Meau" class="headerlink" title="Meau"></a>Meau</h1><blockquote>
<p>选项菜单</p>
<p>上下文菜单</p>
<p>子菜单</p>
<p>Popup弹出菜单</p>
<p>ActionMode 创建导航菜单</p>
</blockquote>
<p>以下小例子都有很多优化的地方</p>
<a id="more"></a>
<p><strong>选项菜单</strong></p>
<p>onCreateOptionsMenu(Menu menu)</p>
<p>onOptionsItemSelected(MenuItem item)</p>
<p><strong>showAsAction 在as 中 会报错  要添加 xmlns:app=”<a href="http://schemas.android.com/apk/res-auto" target="_blank" rel="external">http://schemas.android.com/apk/res-auto</a>“  引用</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; &gt;
    &lt;!--
        item 中通还可以有menu  : 表示的为 子菜单;
        menuCategroy:属性可以控制菜单项的位置
        orderInCategory 同种类菜单进行排序
        title: 菜单显示的文本
        titleCondensed：菜单项的短标题。当菜单项标题太长时会显示该属性值
        icon: 设置图标
        alphabeticShortcut:添加菜单项的字母快捷键
        numericShortcut：添加菜单项的数字快捷键
        checkable：表示菜单项是否带复选框。该属性可设计为true或false
        checked：如果菜单项带复选框(checkable属性为true)，该属性表示复选框默认状态是否被选中。可设置的值为true或false
        visible：菜单项默认状态是否可视 true|false
        enable：菜单项默认状态是否被激活 是否是可用的
        showAsAction:
            ifRoom: 如果溢出就会隐藏 溢出来的部分
            never:永远不会显示。只会在溢出列表中显示，而且只显示标题，所以在定义item的时候，最好把标题都带上。
            always : 不管是是否溢出都会显示
            withText: 只显示文本
            collapseActionView:声明了这个操作视窗应该被折叠到一个按钮中，当用户选择这个按钮时，
                        这个操作视窗展开。否则，这个操作视窗在默认的情况下是可见的，
                        并且即便在用于不适用的时候，也要占据操作栏的有效空间。
                        一般要配合ifRoom一起使用才会有效果。
        --&gt;
    &lt;item
        android:id=&quot;@+id/action_add&quot;
        android:orderInCategory=&quot;1&quot;
        app:showAsAction=&quot;never&quot;
        android:title=&quot;呵呵哒&quot; /&gt;

    &lt;item
        android:id=&quot;@+id/delete&quot;
        android:orderInCategory=&quot;2&quot;
        app:showAsAction=&quot;never&quot;
        android:title=&quot;萌萌哒&quot; /&gt;
&lt;/menu&gt;
</code></pre><hr>
<pre><code>   ///////////////////  创建一个选项菜单
/**
 * 创建一个选项菜单
 * @param menu
 * @return
 */
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.menu, menu);
//        menu.add(1,1,1,&quot;add&quot;);
//        menu.add(1,2,1,&quot;delete&quot;);
    return true;
}
/**
 * 当菜单选项被单击的时候
 * @param
 * @return
 */
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()){
        case R.id.action_add:
            toast(&quot;add&quot;);
            break;
        case R.id.delete:
            toast(&quot;delete&quot;);
            break;
        default:
            break;
    }
    return super.onOptionsItemSelected(item);
}
</code></pre><p><strong>上下文菜单</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
&lt;item
    android:id=&quot;@+id/a&quot;
    android:title=&quot;a&quot;
    android:orderInCategory=&quot;1&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
&lt;item
    android:id=&quot;@+id/b&quot;
    android:title=&quot;b&quot;
    android:orderInCategory=&quot;2&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
&lt;item
    android:id=&quot;@+id/c&quot;
    android:title=&quot;c&quot;
    android:orderInCategory=&quot;3&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
</code></pre><p></p>
<hr>
<pre><code>list = (ListView) findViewById(R.id.listview);
    String[] listItem = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;};
    ArrayAdapter&lt;String&gt; adpater = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, listItem);
    list.setAdapter(adpater);

    registerForContextMenu(list);//为 listview 注册一个菜单

///////              创建一个上下文菜单
/**
 * 导入你所需的菜单
 * @param menu
 * @param v
 * @param menuInfo
 */
@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    getMenuInflater().inflate(R.menu.item, menu);
}

/**
 * 当 listview中的item 长按的时候
 * @param item
 * @return
 */
@Override
public boolean onContextItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.a:
            toast(&quot;a&quot;);
            break;
        case R.id.b:
            toast(&quot;b&quot;);
            break;
        default:
            break;
    }
    return super.onContextItemSelected(item);
}
</code></pre><p><strong>子菜单</strong></p>
<pre><code> /////////////////////////////// 创建子菜单
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    SubMenu a = menu.addSubMenu(1, 1, 1, &quot;hehe&quot;);
    a.setHeaderTitle(&quot;想你了&quot;);
    a.setHeaderIcon(R.mipmap.ic_launcher);
    a.add(1, 1, 1, &quot;a&quot;);
    a.add(1, 2, 1, &quot;b&quot;);
    SubMenu b = menu.addSubMenu(2, 1, 1, &quot;heihei&quot;);
    b.setHeaderTitle(&quot;不想你了&quot;);
    b.add(2, 1, 1, &quot;c&quot;);
    b.add(2, 2, 1, &quot;d&quot;);
    return true;
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {

    if (item.getGroupId() == 1) {
        switch (item.getItemId()) {
            case 1:
                toast(&quot;a&quot;);
                break;
            case 2:
                toast(&quot;b&quot;);
                break;
            default:
                break;
        }
    }else if (item.getGroupId() == 2) {
        switch (item.getItemId()) {
            case 1:
                toast(&quot;c&quot;);
                break;
            case 2:
                toast(&quot;d&quot;);
                break;
            default:
                break;
        }
    }


    return super.onOptionsItemSelected(item);
}
public void toast(String str) {
    Toast.makeText(this, str, Toast.LENGTH_SHORT).show();
}
</code></pre><p><strong>Popup弹出菜单</strong></p>
<pre><code>// 点击一个 按钮时:
@Override
public void onClick(View v) {
    switch (v.getId()){
        case R.id.PopupMenu:
            //建立PopupMenu对象
            PopupMenu popup = new PopupMenu(MainActivity.this, v);
            //压入XML资源文件
            popup.getMenuInflater().inflate(R.menu.menu,popup.getMenu());
            //设置点击菜单选项事件
            popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
                @Override
                public boolean onMenuItemClick(MenuItem item) {
                    switch (item.getItemId()){
                        case R.id.action_add:
                            toast(&quot;add&quot;);
                            break;
                        case R.id.delete:
                            toast(&quot;delete&quot;);
                            break;
                        default:
                            break;
                    }
                    return true;
                }
            });
            //显示菜单
            popup.show();
            break;
        default:
            break;
    }
}
</code></pre><p><strong>ActionMode 导航菜单</strong></p>
<pre><code>modeAction.setOnLongClickListener(new View.OnLongClickListener() {
      @Override
      public boolean onLongClick(View v) {
          if(actionMode != null) {
              return false;
          }
          // 这里在start时， 也是可以得到 ActionMode的
          actionMode = startActionMode(new ActionMode.Callback() {
              @Override
              public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                  menu.add(1, 1, 1, &quot;hehe&quot;);
                  menu.add(1, 2, 1, &quot;jjj&quot;);
                  menu.add(1, 3, 1, &quot;ggg&quot;);
                  return true;
              }

              @Override
              public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                  return false;
              }

              @Override
              public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
                  switch (item.getItemId()) {
                      case 1:
                          toast(&quot;1&quot;);
                          break;
                      case 2:
                          toast(&quot;2&quot;);
                          break;
                      case 3:
                          toast(&quot;3&quot;);
                          break;
                      default:
                          break;
                  }
                  return false;
              }

              @Override
              public void onDestroyActionMode(ActionMode mode) {
                  actionMode = null;
              }
          });
          v.setSelected(true);        //设置为可选
          return true;
      }
  });
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Meau&quot;&gt;&lt;a href=&quot;#Meau&quot; class=&quot;headerlink&quot; title=&quot;Meau&quot;&gt;&lt;/a&gt;Meau&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;选项菜单&lt;/p&gt;
&lt;p&gt;上下文菜单&lt;/p&gt;
&lt;p&gt;子菜单&lt;/p&gt;
&lt;p&gt;Popup弹出菜单&lt;/p&gt;
&lt;p&gt;ActionMode 创建导航菜单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下小例子都有很多优化的地方&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Layout</title>
    <link href="http://liugch.top/2016/09/25/shapeAndview/"/>
    <id>http://liugch.top/2016/09/25/shapeAndview/</id>
    <published>2016-09-25T09:40:51.000Z</published>
    <updated>2016-12-23T16:29:09.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布局的优化"><a href="#布局的优化" class="headerlink" title="布局的优化"></a>布局的优化</h1><blockquote>
<p>尽量的使用 include merge </p>
<p>劲量不要嵌套的太多的布局</p>
<p>一般不要 RelativeLayout 里面再次嵌套 RelativeLayout</p>
</blockquote>
<h2 id="布局的一些简化操作"><a href="#布局的一些简化操作" class="headerlink" title="布局的一些简化操作"></a>布局的一些简化操作</h2><pre><code> &lt;LinearLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;120dp&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;ImageView
        android:layout_width=&quot;120dp&quot;
        android:layout_height=&quot;120dp&quot;
        android:layout_margin=&quot;5dp&quot;
        android:src=&quot;@drawable/touxiang&quot; /&gt;
    &lt;!--
    ineSpacingExtra属性代表的是行间距，他默认是0，是一个绝对高度值。
    同时还有lineSpacingMultiplier属性， 它代表行间距倍数，默认为1.0f，是一个相对高度值。
    android:text=&quot;你好\n第三方\n大都饭店&quot; 自动回帮你换行
    --&gt;
    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:gravity=&quot;center_vertical&quot;
        android:lineSpacingMultiplier=&quot;2&quot;
        android:text=&quot;你好\n第三方\n大都饭店&quot;
        android:textSize=&quot;14sp&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><blockquote>
<p>定义 一个shape的XML</p>
<p>调用 自定义的 shape 设置包含item的分割线</p>
<p>item中的间隔我可以 放弃 view 和 margin 用 space 使用</p>
</blockquote>
<p><strong>类似的效果图</strong></p>
<p><img src="http://i.imgur.com/bV20OlF.png" alt=""></p>
<p><strong>divider.xml</strong></p>
<pre><code>&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;size
    android:width=&quot;1dp&quot;
    android:height=&quot;1dp&quot;/&gt;
&lt;solid
    android:color=&quot;#e1e1e1&quot;/&gt;
&lt;/shape&gt;
</code></pre><p><strong>布局</strong>    </p>
<pre><code>&lt;!--
    divider:调用 定义的shape  
    showDividers:分割线显示的位置
    android:drawableLeft=&quot;@mipmap/shebei
    Space: 设置 间隔
 --&gt;
&lt;LinearLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:divider=&quot;@drawable/divider&quot;
    android:showDividers=&quot;middle|beginning|end&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;
    &lt;Space
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;30dp&quot; /&gt;
    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p><strong>TextView 实现超链接</strong></p>
<p>效果图:</p>
<p><img src="http://i.imgur.com/LUa8sx6.png" alt=""></p>
<pre><code>//布局
 &lt;TextView
    android:id=&quot;@+id/text&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:autoLink=&quot;all&quot; /&gt;

// activity
 text=(TextView) findViewById(R.id.text);
    String texts = &quot;网址：http://www.baidu.com&quot;+&quot;\n&quot;;
    texts += &quot;邮箱:88888888@qq.com&quot;+&quot;\n&quot;;
    texts += &quot;电话：13888888888&quot; +&quot;\n&quot;;
    text.setText(texts);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;布局的优化&quot;&gt;&lt;a href=&quot;#布局的优化&quot; class=&quot;headerlink&quot; title=&quot;布局的优化&quot;&gt;&lt;/a&gt;布局的优化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;尽量的使用 include merge &lt;/p&gt;
&lt;p&gt;劲量不要嵌套的太多的布局&lt;/p&gt;

    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="http://liugch.top/2016/09/25/hexo/"/>
    <id>http://liugch.top/2016/09/25/hexo/</id>
    <published>2016-09-24T18:22:53.000Z</published>
    <updated>2016-10-22T18:07:26.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Hexo简介"><a href="#1-Hexo简介" class="headerlink" title="1.Hexo简介"></a>1.Hexo简介</h1><p>Hexo是一款基于Node.js 的静态博客框架，并且使用Markdown来解析文章的，本地安装Hexo后，可以利用git版本控制工具来操作Hexo,利用Hexo的主题来自动生成静态的网页。&lt;属于个人的理解&gt;</p>
<a id="more"></a>
<p>查考：<a href="https://hexo.io/zh-cn/docs/" title="Hexo帮助文档" target="_blank" rel="external">Hexo的帮助文档重要 </a></p>
<h1 id="2-博客环境的搭建"><a href="#2-博客环境的搭建" class="headerlink" title="2.博客环境的搭建"></a>2.博客环境的搭建</h1><h2 id="一、安装Git"><a href="#一、安装Git" class="headerlink" title="一、安装Git"></a>一、安装Git</h2><blockquote>
<p>下载地址  <a href="https://git-scm.com/download" title="Git下载地址" target="_blank" rel="external">https://git-scm.com/download</a></p>
</blockquote>
<h2 id="二、安装Node-js"><a href="#二、安装Node-js" class="headerlink" title="二、安装Node.js"></a>二、安装Node.js</h2><blockquote>
<p>下载地址  <a href="http://nodejs.cn/download/" title="Node.js下载地址" target="_blank" rel="external">http://nodejs.cn/download/</a></p>
</blockquote>
<h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>Git和Node.js 安装好后，在一个合适的位置新建一个文件夹（英文的比较好），之后就开始使用Hexo了。</p>
<blockquote>
<p>Hexo的安装并初始化</p>
</blockquote>
<pre><code>$ npm install -g hexo-cli
$ hexo init
</code></pre><p>安装Hexo后会在该文件夹下生成如下的文件</p>
<pre><code>├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><p>其中_config.yml文件用于存放网站的配置信息，你可以在此配置大部分的参数；scaffolds是存放模板的文件夹，当新建文章时，Hexo 会根据scaffold来建立文件；source是资源文件夹，用于存放用户资源，themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。</p>
<blockquote>
<p>生成静态的博文</p>
</blockquote>
<p>在Git Bash终端执行命令：</p>
<pre><code>1  hexo g
2  hexo s
</code></pre><p>可以组合起来使用：</p>
<pre><code>hexo s -g
</code></pre><p>执行完之后：</p>
<p>Hexo将source文件夹中的 Markdown 和 HTML 文件会被解析并放到public文件夹中，public文件夹用于存放静态博客文件，相当于网站根目录。</p>
<blockquote>
<p>至此简单的博客已经搭建完毕  访问：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a></p>
</blockquote>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Hexo简介&quot;&gt;&lt;a href=&quot;#1-Hexo简介&quot; class=&quot;headerlink&quot; title=&quot;1.Hexo简介&quot;&gt;&lt;/a&gt;1.Hexo简介&lt;/h1&gt;&lt;p&gt;Hexo是一款基于Node.js 的静态博客框架，并且使用Markdown来解析文章的，本地安装Hexo后，可以利用git版本控制工具来操作Hexo,利用Hexo的主题来自动生成静态的网页。&amp;lt;属于个人的理解&amp;gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://liugch.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://liugch.top/tags/hexo/"/>
    
      <category term="github" scheme="http://liugch.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Oralce的世界</title>
    <link href="http://liugch.top/2016/09/24/index/"/>
    <id>http://liugch.top/2016/09/24/index/</id>
    <published>2016-09-24T09:40:51.000Z</published>
    <updated>2016-10-22T18:07:31.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle-的体系结构"><a href="#Oracle-的体系结构" class="headerlink" title="Oracle 的体系结构"></a>Oracle 的体系结构</h1><p>数据库是一个以某种有组织的方式存储的数据集合。 它本质上是用计算机存储记录的系统，是位于用户和系统之间的一层管理软件。 Oracle 数据库是目前最流行、最强大的面向对象的关系型数据库(ORDBMS)。</p>
<a id="more"></a>
<p>Oracle 是基于请求响应的方式，分为服务端和客户端。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>Oracle 是由实例和数据库两部分组成</p>
<h3 id="实例-INSTANCE"><a href="#实例-INSTANCE" class="headerlink" title="实例 (INSTANCE)"></a><strong>实例 (INSTANCE)</strong></h3><p> 又称为oracle数据库引擎，由由内存即SGA(System Global Area,系统全局区)和后台处理进程组成。</p>
<h3 id="数据库-DATEBASE"><a href="#数据库-DATEBASE" class="headerlink" title="数据库(DATEBASE)"></a><strong>数据库(DATEBASE)</strong></h3><p> 保存在计算机上的数据文件等。可以从物理物件或逻辑组件的角度看待。</p>
<h4 id="物理组件"><a href="#物理组件" class="headerlink" title="物理组件"></a>物理组件</h4><ol>
<li><p><strong>控制文件 (Control File)</strong></p>
<pre><code>select * from v$controlfile;
</code></pre><p>记录数据库的物理结构和其他控制信息，如数据库名称，数据文件、日志文件名称和位置等。多副本保证安全。</p>
</li>
<li><p><strong>数据文件 (Data File)</strong></p>
<pre><code>select name,status,enabled from v$datafile;
</code></pre></li>
<li><p><strong> 日志文件 (联机日志文件/归档日志文件)</strong></p>
<pre><code>select * from v$log;   -- 查看日志
</code></pre><p>保存用户的所有操作。一个数据库至少有两个日志组，轮流写入。<br>每个日志组至少有一个日志成员，成员之间是镜像关系，这是为了保护数据。<br>联机日志组的交换过程叫切换。当一个组写完会自动切换下一组，也可以手动切换：</p>
<pre><code>alter system switch logfile   -- 切换日志文件
</code></pre><p>如果打开归档模式，切换日志的时候会产生归档文件。打开归档模式命令:</p>
<pre><code>alter database archivelog
</code></pre></li>
<li><p><strong>初始化参数文件 (Parameter File)</strong></p>
<pre><code>位置:
$ORA_HOME/admin/&lt;SID&gt;/pfile/init.ora.xxx
</code></pre></li>
</ol>
<h4 id="逻辑组件"><a href="#逻辑组件" class="headerlink" title="逻辑组件"></a>逻辑组件</h4><ul>
<li><p><strong>表空间</strong></p>
<pre><code>select * from v$tablespace;--查询所有的表空间
</code></pre></li>
</ul>
<ol>
<li>最基本的逻辑结构 ，是数据库恢复的最小单位, 容纳着许多数据库实体, 如表、视图、索引、聚簇、回退段和临时段等。</li>
<li>默认创建的表空间有 SYSTEM/SYSAUX/TEMP/UNDO/USERS</li>
<li>表空间跟数据文件是 1vN 的关系。一个表空间至少需要一个相应的数据文件</li>
<li>在实际生产中，不建议用默认表空间，要根据情况自己创建</li>
<li><p>创建/删除表空间的语法：</p>
<pre><code>--表空间创建
create tablespace xxx
datafile &apos;D:\xxx.dbf&apos;
size 50m
autoextend on
next 50m maxsize 20480m
extent management local;

-- 创建临时表空间
create temporary tablespace yyy
tempfile &apos;D:\yyy.dbf&apos;;

-- 删除
drop tablespace yyy;
</code></pre></li>
<li>逻辑上说，一个表空间是由一到多个段组成的。</li>
</ol>
<ul>
<li><strong>段 (Segment)</strong></li>
</ul>
<ol>
<li>段是对象在数据库中占用的空间</li>
<li>每个段，对应的是每个对象，有 table/index/view 等</li>
<li>按照存储对象类型的不同，分为数据段、索引段、回滚段和临时段</li>
<li>逻辑上说，段是由区组成的</li>
</ol>
<ul>
<li><strong> 区 (Extend)</strong></li>
</ul>
<ol>
<li>由连续的数据块组成，由 Oracle 自动分配管理</li>
<li>当段中的空间已满时，会自动扩展新区</li>
</ol>
<ul>
<li><strong>块</strong></li>
</ul>
<ol>
<li>数据块是Oracle服务器所能分配、读取或写入的最小逻辑单位。</li>
<li>Oracle服务器以数据块为单位管理数据文件的存储空间。</li>
<li>正常情况下，块的大小是操作系统块的整数倍，称作标准块。</li>
<li>可以通过参数 db_block_size 控制，默认 8k.</li>
</ol>
<blockquote>
<p>启动过程</p>
</blockquote>
<pre><code>startup nomount        -- 只启动了实例 (Instance)
alter database mount   -- 数据库挂载
alter database open    -- 数据库打开
shutdown immediate     -- 立刻关闭
</code></pre><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="连接语法"><a href="#连接语法" class="headerlink" title="连接语法"></a>连接语法</h2><pre><code>sqlplus sys/southit as sysdba     -- 管理员登录
sqlplus / as sysdba               -- 操作系统认证
sqlplus scott/tiger               -- 普通用户登录
sqlplus scott/tiger@remotedb      -- 连接远程数据库
 -- 未连接状态，之后可以用 conn user/pass 语法登录
sqlplus /nolog                    
</code></pre><hr>
<h1 id="Oracle-网络配置"><a href="#Oracle-网络配置" class="headerlink" title="Oracle 网络配置"></a>Oracle 网络配置</h1><h2 id="配置途径"><a href="#配置途径" class="headerlink" title="配置途径"></a>配置途径</h2><ul>
<li><p><code>直接修改 NETWORK/ADMIN 下的配置文件</code><br>  通过 Oracle 的 Net Manager 工具配置<br>  服务端 (NETWORK/ADMIN/listener.ora)</p>
</li>
<li><p><code>直接修改配置文件或通过图形界面配置。</code><br>  主要配置元素有：<br>  协议 (TCP/IP)<br>  连接地址<br>  端口号 (默认1521，一般不需要修改)<br>  开启 TNSListener 服务</p>
</li>
</ul>
<hr>
<h1 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>用户是用于资源控制和权限管理的一个概念<br>开始新的项目时，保持良好的习惯： 为项目创建新的用户，指定新的表空间。</p>
<blockquote>
<p>系统缺省用户</p>
</blockquote>
<p><strong>SYS 用户</strong></p>
<pre><code>又叫特权用户，数据库中至高无上的用户。
它是数据库的系统管理员，负责的是数据的安装、维护、升级、备份、恢复、优化等操作。
不能用 normal 的身份登录，必须用 SYSDBA/SYSOPER 的身份登录。
即使其他的用户用 SYSDBA/SYSOPER 的身份登录，实际上登录的也是 SYS。
</code></pre><p><strong>SYSTEM 用户</strong></p>
<pre><code>数据库的管理员。SYSTEM 用户之下保存着数据库运行的一些基本字典数据。
它拥有 DBA 的角色。主要负责对数据库中各种对象，各种资源的管理。
</code></pre><p><strong>其他用户 (如SCOTT)</strong></p>
<pre><code>普通用户，能够执行被授权范围之内的操作。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Oracle-的体系结构&quot;&gt;&lt;a href=&quot;#Oracle-的体系结构&quot; class=&quot;headerlink&quot; title=&quot;Oracle 的体系结构&quot;&gt;&lt;/a&gt;Oracle 的体系结构&lt;/h1&gt;&lt;p&gt;数据库是一个以某种有组织的方式存储的数据集合。 它本质上是用计算机存储记录的系统，是位于用户和系统之间的一层管理软件。 Oracle 数据库是目前最流行、最强大的面向对象的关系型数据库(ORDBMS)。&lt;/p&gt;
    
    </summary>
    
      <category term="Oracle" scheme="http://liugch.top/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="http://liugch.top/tags/Oracle/"/>
    
  </entry>
  
</feed>
