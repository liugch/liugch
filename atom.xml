<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何有悠然</title>
  <subtitle>Liu Guangch&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liugch.top/"/>
  <updated>2016-10-31T17:10:32.955Z</updated>
  <id>http://liugch.top/</id>
  
  <author>
    <name>何有悠然</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hibernate</title>
    <link href="http://liugch.top/2016/11/01/Hibernate/"/>
    <id>http://liugch.top/2016/11/01/Hibernate/</id>
    <published>2016-10-31T16:13:25.000Z</published>
    <updated>2016-10-31T17:10:32.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate工作原理及为什么要用"><a href="#Hibernate工作原理及为什么要用" class="headerlink" title="Hibernate工作原理及为什么要用?"></a>Hibernate工作原理及为什么要用?</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>1.通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件<br>2.由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml">读取并解析映射信息<br>3.通过config.buildSessionFactory();//创建SessionFactory<br>4.sessionFactory.openSession();//打开Sesssion<br>5.session.beginTransaction();//创建事务Transation<br>6.persistent operate持久化操作<br>7.session.getTransaction().commit();//提交事务<br>8.关闭Session<br>9.关闭SesstionFactory<br><a id="more"></a></mapping></p>
<h2 id="为什么要用："><a href="#为什么要用：" class="headerlink" title="为什么要用："></a>为什么要用：</h2><ol>
<li><p>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p>
</li>
<li><p>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的        编码工作</p>
</li>
<li><p>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</p>
</li>
<li><p>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，    从一对一到多对多的各种复杂关系。</p>
</li>
</ol>
<blockquote>
<p>Hibernate是如何延迟加载?</p>
</blockquote>
<ol>
<li><p>Hibernate2延迟加载实现：a)实体对象 b)集合（Collection）</p>
</li>
<li><p>Hibernate3 提供了属性的延迟加载功能</p>
</li>
</ol>
<p>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</p>
<blockquote>
<p>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)</p>
</blockquote>
<p>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</p>
<h2 id="说下Hibernate的缓存机制"><a href="#说下Hibernate的缓存机制" class="headerlink" title="说下Hibernate的缓存机制"></a>说下Hibernate的缓存机制</h2><ol>
<li><p>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</p>
</li>
<li><p>二级缓存：</p>
<p>a) 应用及缓存 </p>
<p>b) 分布式缓存<br>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非 关键数据<br>c) 第三方缓存的实现</p>
</li>
</ol>
<p><strong>一级缓存：session级的缓存也叫事务级的缓存，只缓存实体，生命周期和session一致。不能对其进行管理。不用显示的调用</strong>。</p>
<p><strong>二级缓存：sessionFactory缓存，也叫进程级的缓存，使用第3方插件实现的，也值缓存实体，生命周期和sessionFactory一致，可以进行管理。</strong></p>
<p>首先配置第3放插件，我们用的是EHCache，在hibernate.cfg.xml文件中加入</p>
<pre><code>&lt;property name=&quot;hibernate.cache.user_second_level_cache&quot;&gt;true&lt;/property&gt;
</code></pre><p>在映射中也要显示的调用<br>    <cache usage="read-only"></cache></p>
<p>二</p>
<blockquote>
<p>级缓存之查询缓存：对普通属性进行缓存。如果关联的表发生了修改，那么查询缓存的生命周期也结束了。</p>
</blockquote>
<p><strong>在程序中必须手动启用查询缓存：query.setCacheable(true);</strong></p>
<blockquote>
<p>Hibernate的查询方式     Sql、Criteria,object comptosition</p>
<p>Hql：</p>
</blockquote>
<p>1、 属性查询<br>2、 参数查询、命名参数查询<br>3、 关联查询<br>4、 分页查询<br>5、 统计函数</p>
<h2 id="如何优化Hibernate？"><a href="#如何优化Hibernate？" class="headerlink" title="如何优化Hibernate？"></a><strong>如何优化Hibernate？</strong></h2><p>1.使用双向一对多关联，不使用单向一对多</p>
<p>2.灵活使用单向一对多关联</p>
<p>3.不用一对一，用多对一取代</p>
<p>4.配置对象缓存，不使用集合缓存</p>
<p>5.一对多集合使用Bag,多对多集合使用Set</p>
<p>6.继承类使用显式多态</p>
<p>7.表字段要少，表关联不要怕多，有二级缓存撑腰</p>
<blockquote>
<p>Hibernate有哪几种查询数据的方式</p>
</blockquote>
<p>  (1)导航对象图查询</p>
<p>  (2)OID查询</p>
<p>  (3)HQL</p>
<p>  (4)QBC</p>
<p>  (5)本地SQL</p>
<h2 id="load-和get-的区别"><a href="#load-和get-的区别" class="headerlink" title="load()和get()的区别"></a><strong>load()和get()的区别</strong></h2><p>Session.load/get方法均可以根据指定的实体类和id从数据库读取记录，并返回与之对应的实体对象。</p>
<p>如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObjectNotFoundException。<br>Load方法可返回实体的代理类实例，而get方法永远直接返回实体类。<br>load方法可以充分利用内部缓存和二级缓存中的现有数据，<br>而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，<br>直接调用SQL完成数据读取。</p>
<p>/<em>
  </em>load()方法的执行顺序如下：<br>  <em>a)：首先通过id在session缓存中查找对象，如果存在此id的对象，直接将其返回
  </em>b)：在二级缓存中查找，找到后将 其返回。<br>  <em>c)：如果在session缓存和二级缓存中都找不到此对象，则从数据库中加载有此ID的对象
  </em>因此load()方法并不总是导致SQL语句，只有缓存中无此数据时，才向数据库发送SQL！<br>  */</p>
<p> /<em>
  </em>与get()的区别：<br>  <em>1：在立即加载对象（当hibernate在从数据库中取得数据组装好一个对象后
  </em>会立即再从数据库取得数据此对象所关联的对象）时，如果对象存在，<br>  <em>load()和get()方法没有区别，都可以取得已初始化的对象;但如果当对
  </em>象不存在且是立即加载时，使用get()方法则返回null,而使用load()则<br>  <em>抛出一个异常。因此使用load()方法时，要确认查询的主键ID一定是存在
  </em>的，从这一点讲它没有get方便！<br>  <em>2：在延迟加载对象(Hibernate从数据库中取得数据组装好一个对象后，
  </em>不会立即再从数据库取得数据组装此对象所关联的对象，而是等到需要时，<br>  <em>都会从数据库取得数据组装此对象关联的对象)时，get()方法仍然使用
  </em>立即加载的方式发送SQL语句，并得到已初始化的对象，而load()方法则<br>  <em>根本不发送SQL语句，它返回一个代理对象，直到这个对象被访问时才被
  </em>初始化。<br>  */</p>
<p>get()—-不支持LAZY</p>
<p>load()—-支持LAZY</p>
<p>总之对于get和load的根本区别，一句话，hibernate对于load方法认为该数据在数据库中一定存在，<br>可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；<br>而对于get方法，hibernate一定要获取到真实的数据，否则返回null。<br>get方法首先查询session缓存，没有的话查询二级缓存，最后查询数据库；<br>反而load方法创建时首先查询session缓存，没有就创建代理，实际使用数据时才查询二级缓存和数据库</p>
<blockquote>
<p>引用链接</p>
</blockquote>
<p><a href="http://sishuok.com/forum/blogPost/list/2936.html" target="_blank" rel="external">http://sishuok.com/forum/blogPost/list/2936.html</a><br><a href="http://www.cnblogs.com/javaNewegg/archive/2011/08/28/2156521.html" target="_blank" rel="external">http://www.cnblogs.com/javaNewegg/archive/2011/08/28/2156521.html</a><br><a href="http://blog.csdn.net/zhaoshl_368/article/details/6577103" target="_blank" rel="external">http://blog.csdn.net/zhaoshl_368/article/details/6577103</a></p>
<h2 id="hibernate-主键生成策略"><a href="#hibernate-主键生成策略" class="headerlink" title="hibernate 主键生成策略"></a>hibernate 主键生成策略</h2><pre><code>&lt;id name=&quot;id&quot; length=&quot;22&quot; &gt;
    &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;
&lt;/id&gt;
</code></pre><p><a href="http://www.cnblogs.com/xlwmin/articles/2189427.html" target="_blank" rel="external">http://www.cnblogs.com/xlwmin/articles/2189427.html</a></p>
<blockquote>
<p>注意:<br>    在HQL,您应该使用映射的java类名和属性名@ entity,而不是实际的表名和列名<br>List&lt;?&gt; result = session.createQuery(“from Student”).list();</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate工作原理及为什么要用&quot;&gt;&lt;a href=&quot;#Hibernate工作原理及为什么要用&quot; class=&quot;headerlink&quot; title=&quot;Hibernate工作原理及为什么要用?&quot;&gt;&lt;/a&gt;Hibernate工作原理及为什么要用?&lt;/h1&gt;&lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h2&gt;&lt;p&gt;1.通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件&lt;br&gt;2.由hibernate.cfg.xml中的&lt;mapping resource=&quot;com/xx/User.hbm.xml&quot;/&gt;读取并解析映射信息&lt;br&gt;3.通过config.buildSessionFactory();//创建SessionFactory&lt;br&gt;4.sessionFactory.openSession();//打开Sesssion&lt;br&gt;5.session.beginTransaction();//创建事务Transation&lt;br&gt;6.persistent operate持久化操作&lt;br&gt;7.session.getTransaction().commit();//提交事务&lt;br&gt;8.关闭Session&lt;br&gt;9.关闭SesstionFactory&lt;br&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://liugch.top/categories/Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://liugch.top/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Android Menu</title>
    <link href="http://liugch.top/2016/09/26/menu/"/>
    <id>http://liugch.top/2016/09/26/menu/</id>
    <published>2016-09-26T09:40:51.000Z</published>
    <updated>2016-12-23T16:18:01.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Meau"><a href="#Meau" class="headerlink" title="Meau"></a>Meau</h1><blockquote>
<p>选项菜单</p>
<p>上下文菜单</p>
<p>子菜单</p>
<p>Popup弹出菜单</p>
<p>ActionMode 创建导航菜单</p>
</blockquote>
<p>以下小例子都有很多优化的地方</p>
<p><strong>选项菜单</strong></p>
<p>onCreateOptionsMenu(Menu menu)</p>
<p>onOptionsItemSelected(MenuItem item)</p>
<p><strong>showAsAction 在as 中 会报错  要添加 xmlns:app=”<a href="http://schemas.android.com/apk/res-auto" target="_blank" rel="external">http://schemas.android.com/apk/res-auto</a>“  引用</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; &gt;
    &lt;!--
        item 中通还可以有menu  : 表示的为 子菜单;
        menuCategroy:属性可以控制菜单项的位置
        orderInCategory 同种类菜单进行排序
        title: 菜单显示的文本
        titleCondensed：菜单项的短标题。当菜单项标题太长时会显示该属性值
        icon: 设置图标
        alphabeticShortcut:添加菜单项的字母快捷键
        numericShortcut：添加菜单项的数字快捷键
        checkable：表示菜单项是否带复选框。该属性可设计为true或false
        checked：如果菜单项带复选框(checkable属性为true)，该属性表示复选框默认状态是否被选中。可设置的值为true或false
        visible：菜单项默认状态是否可视 true|false
        enable：菜单项默认状态是否被激活 是否是可用的
        showAsAction:
            ifRoom: 如果溢出就会隐藏 溢出来的部分
            never:永远不会显示。只会在溢出列表中显示，而且只显示标题，所以在定义item的时候，最好把标题都带上。
            always : 不管是是否溢出都会显示
            withText: 只显示文本
            collapseActionView:声明了这个操作视窗应该被折叠到一个按钮中，当用户选择这个按钮时，
                        这个操作视窗展开。否则，这个操作视窗在默认的情况下是可见的，
                        并且即便在用于不适用的时候，也要占据操作栏的有效空间。
                        一般要配合ifRoom一起使用才会有效果。
        --&gt;
    &lt;item
        android:id=&quot;@+id/action_add&quot;
        android:orderInCategory=&quot;1&quot;
        app:showAsAction=&quot;never&quot;
        android:title=&quot;呵呵哒&quot; /&gt;

    &lt;item
        android:id=&quot;@+id/delete&quot;
        android:orderInCategory=&quot;2&quot;
        app:showAsAction=&quot;never&quot;
        android:title=&quot;萌萌哒&quot; /&gt;
&lt;/menu&gt;
</code></pre><hr>
<pre><code>   ///////////////////  创建一个选项菜单
/**
 * 创建一个选项菜单
 * @param menu
 * @return
 */
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.menu, menu);
//        menu.add(1,1,1,&quot;add&quot;);
//        menu.add(1,2,1,&quot;delete&quot;);
    return true;
}
/**
 * 当菜单选项被单击的时候
 * @param
 * @return
 */
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()){
        case R.id.action_add:
            toast(&quot;add&quot;);
            break;
        case R.id.delete:
            toast(&quot;delete&quot;);
            break;
        default:
            break;
    }
    return super.onOptionsItemSelected(item);
}
</code></pre><p><strong>上下文菜单</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
&lt;item
    android:id=&quot;@+id/a&quot;
    android:title=&quot;a&quot;
    android:orderInCategory=&quot;1&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
&lt;item
    android:id=&quot;@+id/b&quot;
    android:title=&quot;b&quot;
    android:orderInCategory=&quot;2&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
&lt;item
    android:id=&quot;@+id/c&quot;
    android:title=&quot;c&quot;
    android:orderInCategory=&quot;3&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
</code></pre><p></p>
<hr>
<pre><code>list = (ListView) findViewById(R.id.listview);
    String[] listItem = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;};
    ArrayAdapter&lt;String&gt; adpater = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, listItem);
    list.setAdapter(adpater);

    registerForContextMenu(list);//为 listview 注册一个菜单

///////              创建一个上下文菜单
/**
 * 导入你所需的菜单
 * @param menu
 * @param v
 * @param menuInfo
 */
@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    getMenuInflater().inflate(R.menu.item, menu);
}

/**
 * 当 listview中的item 长按的时候
 * @param item
 * @return
 */
@Override
public boolean onContextItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.a:
            toast(&quot;a&quot;);
            break;
        case R.id.b:
            toast(&quot;b&quot;);
            break;
        default:
            break;
    }
    return super.onContextItemSelected(item);
}
</code></pre><p><strong>子菜单</strong></p>
<pre><code> /////////////////////////////// 创建子菜单
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    SubMenu a = menu.addSubMenu(1, 1, 1, &quot;hehe&quot;);
    a.setHeaderTitle(&quot;想你了&quot;);
    a.setHeaderIcon(R.mipmap.ic_launcher);
    a.add(1, 1, 1, &quot;a&quot;);
    a.add(1, 2, 1, &quot;b&quot;);
    SubMenu b = menu.addSubMenu(2, 1, 1, &quot;heihei&quot;);
    b.setHeaderTitle(&quot;不想你了&quot;);
    b.add(2, 1, 1, &quot;c&quot;);
    b.add(2, 2, 1, &quot;d&quot;);
    return true;
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {

    if (item.getGroupId() == 1) {
        switch (item.getItemId()) {
            case 1:
                toast(&quot;a&quot;);
                break;
            case 2:
                toast(&quot;b&quot;);
                break;
            default:
                break;
        }
    }else if (item.getGroupId() == 2) {
        switch (item.getItemId()) {
            case 1:
                toast(&quot;c&quot;);
                break;
            case 2:
                toast(&quot;d&quot;);
                break;
            default:
                break;
        }
    }


    return super.onOptionsItemSelected(item);
}
public void toast(String str) {
    Toast.makeText(this, str, Toast.LENGTH_SHORT).show();
}
</code></pre><p><strong>Popup弹出菜单</strong></p>
<pre><code>// 点击一个 按钮时:
@Override
public void onClick(View v) {
    switch (v.getId()){
        case R.id.PopupMenu:
            //建立PopupMenu对象
            PopupMenu popup = new PopupMenu(MainActivity.this, v);
            //压入XML资源文件
            popup.getMenuInflater().inflate(R.menu.menu,popup.getMenu());
            //设置点击菜单选项事件
            popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
                @Override
                public boolean onMenuItemClick(MenuItem item) {
                    switch (item.getItemId()){
                        case R.id.action_add:
                            toast(&quot;add&quot;);
                            break;
                        case R.id.delete:
                            toast(&quot;delete&quot;);
                            break;
                        default:
                            break;
                    }
                    return true;
                }
            });
            //显示菜单
            popup.show();
            break;
        default:
            break;
    }
}
</code></pre><p><strong>ActionMode 导航菜单</strong></p>
<pre><code>modeAction.setOnLongClickListener(new View.OnLongClickListener() {
      @Override
      public boolean onLongClick(View v) {
          if(actionMode != null) {
              return false;
          }
          // 这里在start时， 也是可以得到 ActionMode的
          actionMode = startActionMode(new ActionMode.Callback() {
              @Override
              public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                  menu.add(1, 1, 1, &quot;hehe&quot;);
                  menu.add(1, 2, 1, &quot;jjj&quot;);
                  menu.add(1, 3, 1, &quot;ggg&quot;);
                  return true;
              }

              @Override
              public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                  return false;
              }

              @Override
              public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
                  switch (item.getItemId()) {
                      case 1:
                          toast(&quot;1&quot;);
                          break;
                      case 2:
                          toast(&quot;2&quot;);
                          break;
                      case 3:
                          toast(&quot;3&quot;);
                          break;
                      default:
                          break;
                  }
                  return false;
              }

              @Override
              public void onDestroyActionMode(ActionMode mode) {
                  actionMode = null;
              }
          });
          v.setSelected(true);        //设置为可选
          return true;
      }
  });
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Meau&quot;&gt;&lt;a href=&quot;#Meau&quot; class=&quot;headerlink&quot; title=&quot;Meau&quot;&gt;&lt;/a&gt;Meau&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;选项菜单&lt;/p&gt;
&lt;p&gt;上下文菜单&lt;/p&gt;
&lt;p&gt;子菜单&lt;/p&gt;
&lt;p&gt;Popup弹出菜单&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Layout</title>
    <link href="http://liugch.top/2016/09/25/shapeAndview/"/>
    <id>http://liugch.top/2016/09/25/shapeAndview/</id>
    <published>2016-09-25T09:40:51.000Z</published>
    <updated>2016-12-23T16:29:09.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布局的优化"><a href="#布局的优化" class="headerlink" title="布局的优化"></a>布局的优化</h1><blockquote>
<p>尽量的使用 include merge </p>
<p>劲量不要嵌套的太多的布局</p>
<p>一般不要 RelativeLayout 里面再次嵌套 RelativeLayout</p>
</blockquote>
<h2 id="布局的一些简化操作"><a href="#布局的一些简化操作" class="headerlink" title="布局的一些简化操作"></a>布局的一些简化操作</h2><pre><code> &lt;LinearLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;120dp&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;ImageView
        android:layout_width=&quot;120dp&quot;
        android:layout_height=&quot;120dp&quot;
        android:layout_margin=&quot;5dp&quot;
        android:src=&quot;@drawable/touxiang&quot; /&gt;
    &lt;!--
    ineSpacingExtra属性代表的是行间距，他默认是0，是一个绝对高度值。
    同时还有lineSpacingMultiplier属性， 它代表行间距倍数，默认为1.0f，是一个相对高度值。
    android:text=&quot;你好\n第三方\n大都饭店&quot; 自动回帮你换行
    --&gt;
    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:gravity=&quot;center_vertical&quot;
        android:lineSpacingMultiplier=&quot;2&quot;
        android:text=&quot;你好\n第三方\n大都饭店&quot;
        android:textSize=&quot;14sp&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><blockquote>
<p>定义 一个shape的XML</p>
<p>调用 自定义的 shape 设置包含item的分割线</p>
<p>item中的间隔我可以 放弃 view 和 margin 用 space 使用</p>
</blockquote>
<p><strong>类似的效果图</strong></p>
<p><img src="http://i.imgur.com/bV20OlF.png" alt=""></p>
<p><strong>divider.xml</strong></p>
<pre><code>&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;size
    android:width=&quot;1dp&quot;
    android:height=&quot;1dp&quot;/&gt;
&lt;solid
    android:color=&quot;#e1e1e1&quot;/&gt;
&lt;/shape&gt;
</code></pre><p><strong>布局</strong>    </p>
<pre><code>&lt;!--
    divider:调用 定义的shape  
    showDividers:分割线显示的位置
    android:drawableLeft=&quot;@mipmap/shebei
    Space: 设置 间隔
 --&gt;
&lt;LinearLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:divider=&quot;@drawable/divider&quot;
    android:showDividers=&quot;middle|beginning|end&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;
    &lt;Space
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;30dp&quot; /&gt;
    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p><strong>TextView 实现超链接</strong></p>
<p>效果图:</p>
<p><img src="http://i.imgur.com/LUa8sx6.png" alt=""></p>
<pre><code>//布局
 &lt;TextView
    android:id=&quot;@+id/text&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:autoLink=&quot;all&quot; /&gt;

// activity
 text=(TextView) findViewById(R.id.text);
    String texts = &quot;网址：http://www.baidu.com&quot;+&quot;\n&quot;;
    texts += &quot;邮箱:88888888@qq.com&quot;+&quot;\n&quot;;
    texts += &quot;电话：13888888888&quot; +&quot;\n&quot;;
    text.setText(texts);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;布局的优化&quot;&gt;&lt;a href=&quot;#布局的优化&quot; class=&quot;headerlink&quot; title=&quot;布局的优化&quot;&gt;&lt;/a&gt;布局的优化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;尽量的使用 include merge &lt;/p&gt;
&lt;p&gt;劲量不要嵌套的太多的布局&lt;/p&gt;

    
    </summary>
    
      <category term="Android" scheme="http://liugch.top/categories/Android/"/>
    
    
      <category term="Android" scheme="http://liugch.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="http://liugch.top/2016/09/25/hexo/"/>
    <id>http://liugch.top/2016/09/25/hexo/</id>
    <published>2016-09-24T18:22:53.000Z</published>
    <updated>2016-10-22T18:07:26.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Hexo简介"><a href="#1-Hexo简介" class="headerlink" title="1.Hexo简介"></a>1.Hexo简介</h1><p>Hexo是一款基于Node.js 的静态博客框架，并且使用Markdown来解析文章的，本地安装Hexo后，可以利用git版本控制工具来操作Hexo,利用Hexo的主题来自动生成静态的网页。&lt;属于个人的理解&gt;</p>
<a id="more"></a>
<p>查考：<a href="https://hexo.io/zh-cn/docs/" title="Hexo帮助文档" target="_blank" rel="external">Hexo的帮助文档重要 </a></p>
<h1 id="2-博客环境的搭建"><a href="#2-博客环境的搭建" class="headerlink" title="2.博客环境的搭建"></a>2.博客环境的搭建</h1><h2 id="一、安装Git"><a href="#一、安装Git" class="headerlink" title="一、安装Git"></a>一、安装Git</h2><blockquote>
<p>下载地址  <a href="https://git-scm.com/download" title="Git下载地址" target="_blank" rel="external">https://git-scm.com/download</a></p>
</blockquote>
<h2 id="二、安装Node-js"><a href="#二、安装Node-js" class="headerlink" title="二、安装Node.js"></a>二、安装Node.js</h2><blockquote>
<p>下载地址  <a href="http://nodejs.cn/download/" title="Node.js下载地址" target="_blank" rel="external">http://nodejs.cn/download/</a></p>
</blockquote>
<h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>Git和Node.js 安装好后，在一个合适的位置新建一个文件夹（英文的比较好），之后就开始使用Hexo了。</p>
<blockquote>
<p>Hexo的安装并初始化</p>
</blockquote>
<pre><code>$ npm install -g hexo-cli
$ hexo init
</code></pre><p>安装Hexo后会在该文件夹下生成如下的文件</p>
<pre><code>├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><p>其中_config.yml文件用于存放网站的配置信息，你可以在此配置大部分的参数；scaffolds是存放模板的文件夹，当新建文章时，Hexo 会根据scaffold来建立文件；source是资源文件夹，用于存放用户资源，themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。</p>
<blockquote>
<p>生成静态的博文</p>
</blockquote>
<p>在Git Bash终端执行命令：</p>
<pre><code>1  hexo g
2  hexo s
</code></pre><p>可以组合起来使用：</p>
<pre><code>hexo s -g
</code></pre><p>执行完之后：</p>
<p>Hexo将source文件夹中的 Markdown 和 HTML 文件会被解析并放到public文件夹中，public文件夹用于存放静态博客文件，相当于网站根目录。</p>
<blockquote>
<p>至此简单的博客已经搭建完毕  访问：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a></p>
</blockquote>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Hexo简介&quot;&gt;&lt;a href=&quot;#1-Hexo简介&quot; class=&quot;headerlink&quot; title=&quot;1.Hexo简介&quot;&gt;&lt;/a&gt;1.Hexo简介&lt;/h1&gt;&lt;p&gt;Hexo是一款基于Node.js 的静态博客框架，并且使用Markdown来解析文章的，本地安装Hexo后，可以利用git版本控制工具来操作Hexo,利用Hexo的主题来自动生成静态的网页。&amp;lt;属于个人的理解&amp;gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://liugch.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://liugch.top/tags/hexo/"/>
    
      <category term="github" scheme="http://liugch.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Oralce的世界</title>
    <link href="http://liugch.top/2016/09/24/index/"/>
    <id>http://liugch.top/2016/09/24/index/</id>
    <published>2016-09-24T09:40:51.000Z</published>
    <updated>2016-10-22T18:07:31.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle-的体系结构"><a href="#Oracle-的体系结构" class="headerlink" title="Oracle 的体系结构"></a>Oracle 的体系结构</h1><p>数据库是一个以某种有组织的方式存储的数据集合。 它本质上是用计算机存储记录的系统，是位于用户和系统之间的一层管理软件。 Oracle 数据库是目前最流行、最强大的面向对象的关系型数据库(ORDBMS)。</p>
<a id="more"></a>
<p>Oracle 是基于请求响应的方式，分为服务端和客户端。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>Oracle 是由实例和数据库两部分组成</p>
<h3 id="实例-INSTANCE"><a href="#实例-INSTANCE" class="headerlink" title="实例 (INSTANCE)"></a><strong>实例 (INSTANCE)</strong></h3><p> 又称为oracle数据库引擎，由由内存即SGA(System Global Area,系统全局区)和后台处理进程组成。</p>
<h3 id="数据库-DATEBASE"><a href="#数据库-DATEBASE" class="headerlink" title="数据库(DATEBASE)"></a><strong>数据库(DATEBASE)</strong></h3><p> 保存在计算机上的数据文件等。可以从物理物件或逻辑组件的角度看待。</p>
<h4 id="物理组件"><a href="#物理组件" class="headerlink" title="物理组件"></a>物理组件</h4><ol>
<li><p><strong>控制文件 (Control File)</strong></p>
<pre><code>select * from v$controlfile;
</code></pre><p>记录数据库的物理结构和其他控制信息，如数据库名称，数据文件、日志文件名称和位置等。多副本保证安全。</p>
</li>
<li><p><strong>数据文件 (Data File)</strong></p>
<pre><code>select name,status,enabled from v$datafile;
</code></pre></li>
<li><p><strong> 日志文件 (联机日志文件/归档日志文件)</strong></p>
<pre><code>select * from v$log;   -- 查看日志
</code></pre><p>保存用户的所有操作。一个数据库至少有两个日志组，轮流写入。<br>每个日志组至少有一个日志成员，成员之间是镜像关系，这是为了保护数据。<br>联机日志组的交换过程叫切换。当一个组写完会自动切换下一组，也可以手动切换：</p>
<pre><code>alter system switch logfile   -- 切换日志文件
</code></pre><p>如果打开归档模式，切换日志的时候会产生归档文件。打开归档模式命令:</p>
<pre><code>alter database archivelog
</code></pre></li>
<li><p><strong>初始化参数文件 (Parameter File)</strong></p>
<pre><code>位置:
$ORA_HOME/admin/&lt;SID&gt;/pfile/init.ora.xxx
</code></pre></li>
</ol>
<h4 id="逻辑组件"><a href="#逻辑组件" class="headerlink" title="逻辑组件"></a>逻辑组件</h4><ul>
<li><p><strong>表空间</strong></p>
<pre><code>select * from v$tablespace;--查询所有的表空间
</code></pre></li>
</ul>
<ol>
<li>最基本的逻辑结构 ，是数据库恢复的最小单位, 容纳着许多数据库实体, 如表、视图、索引、聚簇、回退段和临时段等。</li>
<li>默认创建的表空间有 SYSTEM/SYSAUX/TEMP/UNDO/USERS</li>
<li>表空间跟数据文件是 1vN 的关系。一个表空间至少需要一个相应的数据文件</li>
<li>在实际生产中，不建议用默认表空间，要根据情况自己创建</li>
<li><p>创建/删除表空间的语法：</p>
<pre><code>--表空间创建
create tablespace xxx
datafile &apos;D:\xxx.dbf&apos;
size 50m
autoextend on
next 50m maxsize 20480m
extent management local;

-- 创建临时表空间
create temporary tablespace yyy
tempfile &apos;D:\yyy.dbf&apos;;

-- 删除
drop tablespace yyy;
</code></pre></li>
<li>逻辑上说，一个表空间是由一到多个段组成的。</li>
</ol>
<ul>
<li><strong>段 (Segment)</strong></li>
</ul>
<ol>
<li>段是对象在数据库中占用的空间</li>
<li>每个段，对应的是每个对象，有 table/index/view 等</li>
<li>按照存储对象类型的不同，分为数据段、索引段、回滚段和临时段</li>
<li>逻辑上说，段是由区组成的</li>
</ol>
<ul>
<li><strong> 区 (Extend)</strong></li>
</ul>
<ol>
<li>由连续的数据块组成，由 Oracle 自动分配管理</li>
<li>当段中的空间已满时，会自动扩展新区</li>
</ol>
<ul>
<li><strong>块</strong></li>
</ul>
<ol>
<li>数据块是Oracle服务器所能分配、读取或写入的最小逻辑单位。</li>
<li>Oracle服务器以数据块为单位管理数据文件的存储空间。</li>
<li>正常情况下，块的大小是操作系统块的整数倍，称作标准块。</li>
<li>可以通过参数 db_block_size 控制，默认 8k.</li>
</ol>
<blockquote>
<p>启动过程</p>
</blockquote>
<pre><code>startup nomount        -- 只启动了实例 (Instance)
alter database mount   -- 数据库挂载
alter database open    -- 数据库打开
shutdown immediate     -- 立刻关闭
</code></pre><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="连接语法"><a href="#连接语法" class="headerlink" title="连接语法"></a>连接语法</h2><pre><code>sqlplus sys/southit as sysdba     -- 管理员登录
sqlplus / as sysdba               -- 操作系统认证
sqlplus scott/tiger               -- 普通用户登录
sqlplus scott/tiger@remotedb      -- 连接远程数据库
 -- 未连接状态，之后可以用 conn user/pass 语法登录
sqlplus /nolog                    
</code></pre><hr>
<h1 id="Oracle-网络配置"><a href="#Oracle-网络配置" class="headerlink" title="Oracle 网络配置"></a>Oracle 网络配置</h1><h2 id="配置途径"><a href="#配置途径" class="headerlink" title="配置途径"></a>配置途径</h2><ul>
<li><p><code>直接修改 NETWORK/ADMIN 下的配置文件</code><br>  通过 Oracle 的 Net Manager 工具配置<br>  服务端 (NETWORK/ADMIN/listener.ora)</p>
</li>
<li><p><code>直接修改配置文件或通过图形界面配置。</code><br>  主要配置元素有：<br>  协议 (TCP/IP)<br>  连接地址<br>  端口号 (默认1521，一般不需要修改)<br>  开启 TNSListener 服务</p>
</li>
</ul>
<hr>
<h1 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>用户是用于资源控制和权限管理的一个概念<br>开始新的项目时，保持良好的习惯： 为项目创建新的用户，指定新的表空间。</p>
<blockquote>
<p>系统缺省用户</p>
</blockquote>
<p><strong>SYS 用户</strong></p>
<pre><code>又叫特权用户，数据库中至高无上的用户。
它是数据库的系统管理员，负责的是数据的安装、维护、升级、备份、恢复、优化等操作。
不能用 normal 的身份登录，必须用 SYSDBA/SYSOPER 的身份登录。
即使其他的用户用 SYSDBA/SYSOPER 的身份登录，实际上登录的也是 SYS。
</code></pre><p><strong>SYSTEM 用户</strong></p>
<pre><code>数据库的管理员。SYSTEM 用户之下保存着数据库运行的一些基本字典数据。
它拥有 DBA 的角色。主要负责对数据库中各种对象，各种资源的管理。
</code></pre><p><strong>其他用户 (如SCOTT)</strong></p>
<pre><code>普通用户，能够执行被授权范围之内的操作。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Oracle-的体系结构&quot;&gt;&lt;a href=&quot;#Oracle-的体系结构&quot; class=&quot;headerlink&quot; title=&quot;Oracle 的体系结构&quot;&gt;&lt;/a&gt;Oracle 的体系结构&lt;/h1&gt;&lt;p&gt;数据库是一个以某种有组织的方式存储的数据集合。 它本质上是用计算机存储记录的系统，是位于用户和系统之间的一层管理软件。 Oracle 数据库是目前最流行、最强大的面向对象的关系型数据库(ORDBMS)。&lt;/p&gt;
    
    </summary>
    
      <category term="Oracle" scheme="http://liugch.top/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="http://liugch.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Spring的世界</title>
    <link href="http://liugch.top/2016/09/24/spring/"/>
    <id>http://liugch.top/2016/09/24/spring/</id>
    <published>2016-09-24T09:40:51.000Z</published>
    <updated>2016-10-30T06:44:32.132Z</updated>
    
    <content type="html"><![CDATA[<div style="font-size:34px">Spring4参考手册中文版</div>

<p></p><h1>前言</h1><br>我是前言。<p></p>
<p></p><h1 id="spring-core">Part III. 核心技术</h1><br>本部分参考手册完全覆盖了Srping 框架的全部技术<br><a id="more"></a><br>首先是Spring IoC控制反转。深入彻底的IoC讲解之后，紧随其后的是全面解说Spring AOP。Spring有自己的AOP框架,该框架概念简单易于理解，能解决Java企业应用中80%的需求<p></p>
<p>Spring也集成了AspectJ，AspectJ是现今java领域功能最丰富、最成熟的AOP实现。</p>
<p>最后面的部分是tdd测试驱动开发，也是Spring 开发团队最为推崇的开发方法，主要内容有单元测试和spirng对集成测试的支持。Spring 团队发现，正确的使用Ioc，会使单元测试和集成测试更加简单（因为类中使用Setter和构造函数，将使它们更容易的配合，而无需使用set up组装）。同时，为测试弄了专门的单独章节，希望你能领悟这一点</p>
<ul>
<li><a href="#beans">Chapter 4, The IoC container</a></li>
<li><a href="#resources">Chapter 5, Resources</a></li>
<li><a href="#validation">Chapter 6, Validation, Data Binding, and Type Conversion</a></li>
<li><a href="#expressions">Chapter 7, Spring Expression Language (SpEL)</a></li>
<li><a href="#aop">Chapter 8, Aspect Oriented Programming with Spring</a></li>
<li><a href="#aop-api">Chapter 9, Spring AOP APIs</a></li>
<li><a href="#testing">Chapter 10, Testing  </a></li>
</ul>
<p></p><h2 id="beans">IoC容器</h2>  <p></p>
<h3 id="beans-introduction">springIOC容器和beans简介</h3>  

<p>本章讲解spring的控制反转(IoC)的spring 框架实现 [1] 原理. IoC 又名 依赖注入 (DI). 它是一个由对象定义依赖的处理手法，也就是如何与其他对象协同工作, 可以通过以下途径定义依赖：构造参数注入、工厂方法的参数注入、属性注入(是指对象实例化后或者从工厂方法返回一个实例后设置其属性)。容器创建bean时候， 注入 依赖。 这个控制倒转了, 因此得名控制反转 (IoC)。反转了哪些控制，不再是由bean自己控制依赖类的实例化和定位, 而是使用了类似于 服务定位 模式的机制来控制。</p>
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 这两个包是spring IOC容器的基础包. <code>BeanFactory</code> 接口 提供了各种配置，用于管理任何对象. <code>ApplicationContext</code> 是 <code>BeanFactory</code>的子接口. 它提供以下功能，使集成Spring’s AOP功能 更容易; 消息资源处理(用于国际化);事件发布;应用层指定上下文环境，像用于web应用的<code>WebApplicationContext</code>.</p>
<p>简而言之, <code>BeanFactory</code> 提供了配置框架和基础功能, <code>ApplicationContext</code> 增加了更多的企业应用用能. <code>ApplicationContext</code> 是 <code>BeanFactory</code>的超集, 是本章的spring IOC示例中的指定容器. 用<code>BeanFactory</code> 替代 <code>ApplicationContext</code>, 更多的信息请参看 Section 4.17, “The BeanFactory”.</p>
<p>应用中的对象并且是由spring 容器 管理的，被称为beans.就是对象，由spring容器管理的诸如实例化、组装等等操作.  bean可以由应用中的多个对象组成。Bean通过容器和配置元数据 ，使用反射技术，去组装依赖对象。</p>
<h3 id="beans-basics">容器概述</h3><br>接口<code>org.springframework.context.ApplicationContext</code>代表了srping IoC 容器，负责实例化、配置和组装前面提到的beans。容器依据配置配置元数据去实例化、配置、组装。配置元数据可以用XML、Java 注解、或者Java编码表示。在配置元数据中，可以定义组成应用的对象，以及对象之间的依赖关系。<br><br>Spring 提供了一些开箱即用的<code>ApplicationContext</code>接口的实现。在单独的应用中，通常使用<code>ClassPathXmlApplicationContext</code>或者<code>FileSystemXmlApplicationContext</code>。当使用XML定义配置元数据时，可通过一小段xml配置使容器支持其他格式的配置元数据，比如Java 注解、Java Code。<br><br><br>大多数的应用场景中，不需要硬编码来实例化一个Spring IoC 的容器。举个栗子，web应用中，在web.xml中大概8行左右的配置就可以实例化一个Spring Ioc容器(see Section 4.16.4, “Convenient ApplicationContext instantiation for web applications”)。若再有STS(Spring eclipse 套件)，简单的钩钩点点即可完成此配置。<br><br>下面的示意图是spring工作原理。<code>ApplicationContext</code>将应用中的类与配置元数据相结合，实例化后，即可得到一个可配置、可执行的系统或应用。<br><strong>The Spring IoC container</strong><br><img src="http://docs.spring.io/spring/docs/4.0.5.RELEASE/spring-framework-reference/htmlsingle/images/container-magic.png" alt="spring 工作原理示意图"><br><br><h4 id="beans-factory-metadata">配置元数据</h4><br>如上图所示，Spring IoC容器使用某种格式的配置元数据；配置元数据，就是告诉Ioc容器如何将对象实例化、配置、组装。<br><br>配置元数据是默认使用简单直观的xml格式，也是本章样例中使用最多的，这些样例程序用以说明spring Ioc 容器的核心概念和功能<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 基于XML的元数据并不是唯一的格式。Spring IoC容器已经和提及到的元数据格式完全解耦了。目前，很多码农都选择<a href="#beans-java">Java-based configuration</a><br><br>欲了解其他元数据格式的使用，请参看:<br><em> <a href="#beans-annotation-config">Annotation-based configuration</a>: Spring 2.5 引进的支持java 注解配置元数据  
</em> <a href="#beans-java">Java-based configuration</a>:  Spring3.0时，将Spring JavaConfig project的很多功能集成到核心Spring框架中。Thus you can define beans external to your application classes by using Java rather than XML files.你可以使用java配置类定义bean，无需xml，该配置类与应用类无关。想要尝鲜的话，请参看<code>@Configuration</code>,<code>@Bean</code>,<code>@Import</code>,<code>@DependsOn</code>注解<br><br>Spring配置由Spring bean的定义组成，这些bean必须被容器管理，至少1个，通常会有多个。基于XML的配置元数据，大概这么配置，根节点<code>&lt;beans&gt;</code>中配置子节点<code>&lt;bean&gt;</code>。Java configuration使用是这样的，一个带有<code>@Configuration</code>类注解的类中，方法上使用<code>@Bean</code>方法注解。<br><br>bean的定义要与应用中实际的类相一致。可以定义service 层的对象、Dao对象、类似Struts的表现成的对象、像Hibernate SessionFactories这样的基础对象，JMS队列等等。通常不会去定义细粒度域对象，因为它们由DAO或者Service负责创建、加载。然而，通过集成AspectJ，可以配置非Srping容器创建的对象。参看<a href="#aop-atconfigurable">Using AspectJ to dependency-inject domain objects with Spring</a><br><br>下面的样例展示了基于XML配置元数据的基本格式:<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- bean的详细配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- bean的详细配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="comment">&lt;!-- 其他bean --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><code>id</code>属性是个字串，是bean的唯一标示符。<code>class</code>属性定义了bean的类型，要使用类的全限定类名（含有包路径）。<code>id</code>属性的值，可以作为合作bean的引用标示符。上面未展示如何引用其他对象；详情参看<a href="#beans-dependencies">Dependencies</a><br><br><br><h4 id="beans-factory-instantiation">容器实例化</h4><br>Spring IoC的实例化易如反掌。<code>ApplicationContext</code>构造函数支持定位路径，定位路径也可以是多个，它是标识实际资源的字串，容器使用该标识加载配置元数据，支持多种资源，比如：本地文件系统、CLASSPATH等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ApplicationContext context = </div><div class="line">	<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>&#125;);</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>在学习了Spring IoC容器之后，也许你想了解更多的Spring的资源，如前所述在第6章，资源使用URI语法定位输入流，Spring提供了方便的机制读取输入流。在第6.7章<a href="#resources-app-ctx">“Application contexts and Resource paths”</a>，专门讲述5用 资源路径构造应用上下文，资源路径也是惯用手法。<br>接下来的样例展示了配置service层对象:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- services --&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"itemDao"</span> <span class="attr">ref</span>=<span class="string">"itemDao"</span>/&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 有关属性配置 --&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="comment">&lt;!--更多的Service bean --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>下面的样例展示了数据访问对象<code>dao.xml</code>配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemDao"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上述内容中service层由<code>PetStoreServiceImpl</code>类、2个dao对象<code>JpaAccountDao</code>和<code>JpaItemDao</code>(基于JPA ORM标准)。属性<code>name</code>元素引用了JavaBean的属性，<em>ref</em>元素引用了其他bean定义。这个引用表示实际对象之间的引用依赖。配置一个对象的依赖，详情请参看<a href="#beans-dependencies">Dependencies</a><br><br><h5 id="beans-factory-xml-import">引入基于xml的元数据</h5><br>多个配置文件共同定义bean非常有用。通常，每个XML配置文件在你的架构中代表一个逻辑层或者一个模块。<br><br>你可以使用应用上下文(applicationContext)的构造函数去加载所有xml中定义的bean。这个构造函数使用多个资源定位，就像前面中提到的。或者，也可以用一个或者多个资源引用，即使用<code>&lt;import/&gt;</code>标签加载其他文件定义的bean。举个栗子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"services.xml"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"resources/messageSource.xml"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"/resources/themeSource.xml"</span>/&gt;</span></div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上例中，从三个外部文件加载定义的bean:<code>services.xml</code>,<code>messageSource.xml</code>,<code>themeSource.xml</code> 。被引入的文件的路径对于引入配置文件来说都是相对路径，所以<code>service.xml</code>必须在引入配置文件的相同文件路径或者相同的类路径中。而<code>messageSource.xml</code>和<code>themeSource.xml</code>必须在引入配置文件所在的文件夹下的<code>resouce</code>文件夹下。正如你所看到的 <code>/</code>开头会被忽略掉，因为这些路径是相对路径，推荐不要使用<code>/</code>开头的格式。导入(imported)文件内容，包含根节点<code>&lt;beans/&gt;</code>，配置中XML bean定义 必须经过Spring语法校验通过。<br><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 使用”../“表示父目录的相对路径是可以的，但是真心不推荐这样创建一个依赖应用外部文件的做法。尤其指出，使用<em>“classpath:”</em>资源类型的URLs(像这样：”classpath:../services.xml”)，也是不推荐的，因为运行时处理过程会选择”最近的”根路径然后引入他的父目录配置文件。Classpath配置的改变，会导致应用选择一个不同的、错误的目录。<br>&gt; 你可以使用全路径限定资源定位取代相对路径，比如：”file:C:/config/services.xml” 或者”classpath:/config/services.xml”。还有，你可以使用抽象路径来解耦应用和配置文件。使用一个逻辑定位更可取 ,比如：通过”${..}”占位符，使用JVM运行时计算出的路径。<br><br><h4 id="beans-factory-client">使用容器</h4><br><code>ApplicationContext</code>是一个高级工厂的接口，能维护各种bean以及他们之间依赖的注册。使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，就能从定义的bean中获取实例。<br><code>ApplicationContext</code>能让你读取bean定义、访问他们，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create and configure beans</span></div><div class="line">ApplicationContext context =</div><div class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">// retrieve configured instance</span></div><div class="line">PetStoreService service = context.getBean(<span class="string">"petStore"</span>, PetStoreService.class);</div><div class="line"></div><div class="line"><span class="comment">// use configured instance</span></div><div class="line">List&lt;String&gt; userList = service.getUsernameList();</div></pre></td></tr></table></figure><br><br>使用<code>getBean()</code>从beans中获取实例。<code>ApplicationContext</code>接口有几种方法可以办到,但是理想的做法是不要使用他们。实际上，应用中根本就不该使用<code>getBean()</code>方法，这样就不依赖Sprig API了。比如，Spring集成了很多web框架，为各种web框架类提供了依赖注入，比如web框架的Controller和JSF-managed beans<br><br><h3 id="beans-definition">Bean概述</h3><br>Spring IoC容器管理一个或多个bean。这些bean根据提供给容器的配置元数据创建的，比如使用XML格式<code>&lt;bean/&gt;</code>定义。<br>在容器内部，这些bean的定义用 <code>BeanDefinition</code>对象表示，<code>BeanDefinition</code>包含了下列元数据：<br><em> 全路径（含包路径）类名：代表bean的实际实现类。
</em> Bean行为配置元素，它规定了bean在容器中行为(作用域，生命周期回调函数等等)<br><em> 引用其他bean，就是为了bean能正常工作而所需的其他bean的引用。这些引用类也称为合作类或者依赖类。
</em> 其他配置，为实例设置的其他属性配置。比如说，管理连接池的bean的连接数，池大小的上限。<br><br>这些元数据将转换成bean定义(<code>BeanDefinition</code>类）的属性。<br><br><strong>The bean definition</strong><br><br><strong>属性</strong>  | <strong>详情</strong><br>————- | ————-<br><strong>class</strong> | <a href="#beans-factory-class">Section 5.3.2, “Instantiating beans”</a><br><strong>name</strong>  | <a href="#beans-beanname">Section 5.3.1, “Naming beans”</a><br><strong>scope</strong> | <a href="#beans-factory-scopes">Section 5.5, “Bean scopes”</a><br><strong>constructor arguments</strong> | <a href="#beans-factory-collaborators">Section 5.4.1, “Dependency injection”</a><br><strong>properties</strong> | <a href="#beans-factory-collaborators">Section 5.4.1, “Dependency injection”</a><br><strong>autowiring mode</strong> | <a href="#beans-factory-autowire">Section 5.4.5, “Autowiring collaborators”</a><br><strong>lazy-initialization mode</strong> | <a href="#beans-factory-lazy-init">Section 5.4.4, “Lazy-initialized beans”</a><br><strong>initialization method</strong> | <a href="#beans-factory-lifecycle-initializingbean">the section called “Initialization callbacks”</a><br><strong>destruction method</strong> | <a href="#beans-factory-lifecycle-disposablebean">the section called “Destruction callbacks”</a><br><br>除了bean的信息以外，<code>BeanDefinition</code>也包含创建特殊bean的信息，<code>ApplicationContext</code>的实现也允许注册由用户创建而非IoC容器创建的对象。通过访问ApplicationContext’s BeanFactory的方法<code>getBeanFactory()</code>，该方法返回BeanFactory的实现<code>DefaultListableBeanFactory</code>。<code>DefaultListableBeanFactory</code>类支持这种注册，通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法实现。然而，典型的应用只用元数据定义的bean就可以单独运行。<br><br><br><h4 id="beans-beanname">beans命名</h4><br>bean有一个或者多个标示符。这些标示符必须是所在容器范围内必唯一的。通常情况一下，一个bean仅有一个标示符，如果有需求需要多个，多出来的将被当做别名。<br><br>在XML格式配置元数据中，使用 <code>id</code> 或者 <code>name</code> 属性来作为bean的标示符。<code>id</code>属性只能有1个。命名规范是字符数字混编（myBean,fooService,等等），但也支持特殊字符，可以包含。若想给bean起个别名，则可使用<code>name</code>属性来指定，可以是多个，用英文的逗号(<code>,</code>)分隔、分号(<code>;</code>)也行、空格也行。注意，在Spring3.1以前，<code>id</code>属性定义成了<code>xsd:ID</code>类型，该类型强制为字符<em>（译者心里说：估计字母+特殊字符，不支持数字的意思，有待验证，没工夫验证去了，翻译进度太慢了。再说了，现在都用4了，你再说3.0怎么着怎么着，那不跟孔乙己似的跟别人吹嘘茴香豆有四种写法）</em>。3.1版开始，它被定义为<code>xsd:string</code>类型。注意，bean <code>id</code>的唯一性约束依然被容器强制使用，尽管xml解析器不再支持了。<em>译者注：在spring3（含）以前，id是可以相同的，容器会替换相同id的bean，而在新版中，容器初始化过程中发现id相同抛出异常，停止实例化</em><br><br><code>id</code> 和<code>name</code>属性不是bean所必须的。若未明确指定<code>id</code>或者<code>name</code>属性，容器会给它生成一个唯一name属性。当然了，如果你想通过bean的<code>name</code>属性引用，使用<code>ref</code>元素方式，或者是类似于<a href="#beans-servicelocator">Service Locator模式</a>方式检索bean(<em>译者想：应该是指调用ApplicationContext.getBean()方法获取bean，类似这种方式。Service Locator是一种设计模式，其实换个名字是不是更合适，DL（Dependency Lookup依赖查找）。虽然现在我也不明白，但是下面有专门的章节讲解，翻到时候再详细了解</em>)，就必须给bean指定    <code>name</code>了。之所以支持无name bean特性，是为了使内部类自动装配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Bean命名规范</div><div class="line"></div><div class="line">bean命名规范使用java命名规范中实例属性名(也称域，Field)规范。小写字母开头的驼峰式。像这样</div><div class="line">(不包括单引号)`accountManager`，`accountService`，`userDao`，</div><div class="line">`loginController`，等等</div><div class="line"></div><div class="line">规范的命名使配置易读易理解。若使用Spring AOP，通过名字增强(译注：大多数Spring AOP教材中</div><div class="line">的 通知)一坨bean时，规范的命名将带来极大的方便。</div><div class="line">```	</div><div class="line">&lt;h5 id=&apos;beans-beanname-alias&apos;&gt;bean定义之外设置别名&lt;/h5&gt;</div><div class="line">定义的bean内，可以给bean多个标识符，组合`id`属性值和任意数量的`name`属性值。这些标识符均可作为该bean的别名，对于有些场景中,别名机制非常有用，比如应用中组件对自身的引用。(*译注：一个类持有一个本类的实例作为属性，看起来应该是这样的，以下代码为推测，可以执行*)  </div><div class="line">**Bean类**</div><div class="line"></div><div class="line">```java	</div><div class="line">public class SomeBean &#123;</div><div class="line">	//注意看这个属性，就是本类</div><div class="line">	private SomeBean someBean;</div><div class="line">	</div><div class="line">	public SomeBean()&#123;&#125;</div><div class="line">	</div><div class="line">	public void setSomeBean(SomeBean someBean) &#123;</div><div class="line">		this.someBean = someBean;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><strong>配置元数据</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</div><div class="line">	<span class="comment">&lt;!--看bean的别名，使用,/;/空格 分隔都是可以是--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"someBeanId"</span> <span class="attr">name</span>=<span class="string">"someBean,someBeanA;someBeanB someBeanC"</span> <span class="attr">class</span>=<span class="string">"com.example.spring.bean.SomeBean"</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!--将别名为someBeanA 的bean 注入给 id为someBeanId 的bean的属性 'someBean'--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someBean"</span> <span class="attr">ref</span>=<span class="string">"someBeanA"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><strong>测试代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ContextConfiguration</span></div><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeBeanTests</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="meta">@Qualifier</span>(<span class="string">"someBeanId"</span>)</div><div class="line">	<span class="keyword">private</span> SomeBean someBean;</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>在bean的定义处指定所有别名有时候并不合适，然而，在其他配置文件中给bean设置别名却更为恰当。此法通常应用在大型系统的场景中，配置文件分散在各个子系统中，每个子系统都有本系统的bean定义。XML格式配置元数据，提供<code>&lt;alias/&gt;</code>元素，可以搞定此用法。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"fromName"</span> <span class="attr">alias</span>=<span class="string">"toName"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>这种情况下，在同容器中有个叫<code>fromName</code>的bean，或者叫其他的<code>阿猫阿狗</code>之类的，再使用此别名定义之后，即可被当做<code>toName</code>来引用。<br><br>举个栗子，子系统A中的配置元数据也许引用了一个被命名为<code>subsystemA-dataSource</code>的bean。子系统B也许引用了一个<code>subsystemB-dataSource</code>。将这两个子系统整合到主应用中，而主应用使用了一个<code>myApp-dataSource</code>，为了使3个bean引用同一个对象，得在MyApp配置元数据中使用别名定义:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"subsystemA-dataSource"</span> <span class="attr">alias</span>=<span class="string">"subsystemB-dataSource"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"subsystemA-dataSource"</span> <span class="attr">alias</span>=<span class="string">"myApp-dataSource"</span> /&gt;</span></div></pre></td></tr></table></figure><br><br>现在，每个组件和主应用都能通过bean 名引用dataSource，而bean名都是唯一的保证不与其他定义冲突(实际上创建了一个命名空间),但他们引用的都是同一个bean。<br><br><strong>Java-configuration</strong><br><br>如果你使用了<code>Java-configuration</code>，<code>@Bean</code>注解也提供了别名，详见<a href="#beans-java-bean-annotation">Section 5.12.3, “Using the @Bean annotation”</a><br><br><h4 id="beans-factory-class">bean实例化</h4><br>bean的定义，本质是如何创建一个或多个对象的配方。容器被请求时，会解析配置元数据中的bean定义并封装，使用封装配置创建（或者获取）对象实例。<br><br>若使用XML格式配置元数据，得为将要实例化的对象指定类型(或者说是类)，使用<code>&lt;bean/&gt;</code>元素的<code>class</code>属性实现。<code>class</code>属性 映射到<code>BeanDefinition</code>类实例的<code>Class</code>属性（域），这个<code>class</code>属性是<code>&lt;bean/&gt;</code>元素必须的。(例外情况，参看“<a href="#beans-factory-class-instance-factory-method">Instantiation using an instance factory method”</a> 和 <a href="#beans-child-bean-definitions">Section 5.7, “Bean definition inheritance”</a>。使用<code>Class</code>域属性，通过以下两种方式：<br><br><em> 通常，通过指定bean的<code>class</code> 属性，容器使用反射调用其构造函数直接创建bean，有点像Java 编码中使用<code>new</code>操作符。  
</em> 指定<code>class</code>实际类含有用于创建对象的静态工厂方法，这是不常使用的场景，容器会调用类的静态工厂方法创建bean。调用静态工厂方法返回的对象类型也许是相同类型，也许完全是其他类。<br><br><br><div class="sidebar"><br><b>内部类命名</b> 若要定义静态内部类，得将类名劈开。<br><br><br>举例来说，现在在<span class="scode">com.example</span>包有个类<span class="scode">Foo</span>,该类有静态内部类<span class="scode">Bar</span>,定义<span class="scode">Bar</span>的Spring bean的<span class="scode"><code>class</code></span>属性差不多是这样<br><br><br><code class="scode">com.example.Foo$Bar</code> <br><br><br><br>注意<span class="scode">$</span>字符，用它来分隔内部类名和外围类名<br></div><br><br><h4 id="beans-factory-class-ctor">用构造函数实例化</h4><br>若是使用构造函数方式创建bean，所有的常规类都可以使用Spring来创建、管理。也就是说，开发的类无需实现任何特殊接口或者使用某种特殊编码风格。仅需指定bean的<code>class</code>即可。对于特殊的bean管理，取决于你使用的IoC类型，也许需要一个默认的空构造。<br><br>Spring IoC容器几乎能管理任何你需要管理的类，不局限于真正的<code>JavaBeans</code>。大多数Spring的用户心中，真正的<code>JavaBean</code>是这样的：仅有1个默认的无参构造函数、属性、setter、getter。嗯，比如，现在需要使用一个废弃连接池，它肯定不符合<code>JavaBean</code>规范，Spring照样能管理。<br><br>使用XML格式配置元数据 定义bean的<code>class</code>，如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"anotherExample"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBeanTwo"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>如何为构造函数指定参数？如何在对象实力话之后设置其属性？请参看<a href="#beans-factory-collaborators">Injecting Dependencies</a><br><br><h5 id="beans-factory-class-static-factory-method">使用静态工厂方法实例化</h5><br>定义使用使用静态工厂方法创建的bean时，得指定工厂方法类的作为<code>class</code>属性值，并且还得指定工厂方法类中用于创建bean的方法名称，作为<code>factory-method</code>属性值。工厂方法可以有参数，调用该方法即可返回对象实例，就像通过构造函数创建对象实例一样。此种bean定义是为了兼容遗留系统中的静态工厂<br><br>下面的bean定义，是使用工厂方法创建bean的方式。定义中，无需指定返回对象的类型(class)，而是指定工厂方法类的<code>class</code>。下例中，<code>createInstance()</code>方法必须是一个<code>static</code>静态方法。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></div><div class="line">    <span class="attr">class</span>=<span class="string">"examples.ClientService"</span></div><div class="line">    <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</div></pre></td></tr></table></figure><br><br>继续<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><h5 id="beans-factory-class-instance-factory-method">使用实例工厂方法实例化</h5><br>和<a href="#beans-factory-class-static-factory-method">静态工厂方法</a>类似的还有实例工厂方法，使用实例工厂方法的方式实例化，是调用容器中已存在的bean的一个非静态方法来创建一个bean。用法是，1、<code>class</code>属性置空设置。 2、设置<code>factory-bean</code>属性，其值为当前容器(或者父容器)中bean的名字，该bean包含可供调用的创建对象的实例方法。3、设置<code>factory-method</code>属性，其值为工厂方法名。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 工厂类, 包含一个方法createInstance() --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></div><div class="line">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></div><div class="line">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</div></pre></td></tr></table></figure><br><br>工厂类如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultServiceLocator</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>工厂类可以有多个工厂方法:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></div><div class="line">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></div><div class="line">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></div><div class="line">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></div><div class="line">    <span class="attr">factory-method</span>=<span class="string">"createAccountServiceInstance"</span>/&gt;</div></pre></td></tr></table></figure><br><br>工厂类如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultServiceLocator</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> accountService;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>上例中展示了工厂类本身也可以通过 DI 管理和配置。参看<a href="#beans-factory-properties-detailed">DI详情</a><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;Srping 资料中,factory bean是指一个Spring配置的bean，该bean能通过实例或者静态工厂方法创建对象。对比之下，<code>FactoryBean</code>(注意大写)是指Spring术语<code>FactoryBean</code>。这段没太理解，解释factory bean和<code>FactoryBean</code>。<br><br><h3 id="beans-dependencies">依赖</h3><br>企业应用绝不会只有1个简单对象（或者说Spring bean）。哪怕是最简单的应用，也会包含许多对象协同工作。下一章节讲述，如何为真正的应用定义大量的、独立的bean，并让这些对象一起合作。<br><br><h4 id="beans-factory-collaborators">依赖注入</h4><br><em>依赖注入(DI)</em>，是一个有对象定义依赖的手法，也就是，如何与其他对象合作，通过构造参数、工厂方法参数、或是在对象实例化之后设置对象属性，实例化既可以构造也可以是使用工厂方法。容器在它创建bean之后注入依赖。这个过程从根本上发生了反转，因此又名控制反转（Ioc），因为Spring bean自己控制依赖类的实例化或者定位 ，Spring bean中就有依赖类的定义，容器使用依赖类构造器创建依赖类实例，使用<em>Service Locator</em>模式定位依赖类。<br><br>DI机制使代码简洁，对象提供它们的依赖，解耦更高效。对象无需自己查找依赖。同样的，类更容易测试，尤其当依赖接口或者抽象类时，测试允许在单元测试中使用<code>stub</code>或者<code>mock</code>（模拟技术）实现。<br><br>DI有2种主要方式，<a href="#beans-constructor-injection">构造注入</a> 和 <a href="#beans-setter-injection">setter注入</a><br>构造注入，容器调用构造函数并传参数，每个参数都是依赖。调用静态工厂方法并传参数方式构造bean和构造注入差不多，这里是指构造注入处理参数和静态工厂方法处理参数像类似。下例中展示了一个只能使用构造注入的类。注意，此类无任何特别之处，并未依赖容器指定的接口、基类、注解，就是一个<code>POJO</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// the SimpleMovieLister 依赖 a MovieFinder</span></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="comment">//Spring容器能注入MovieFinder的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 实际如何使用MovieFinder的业务逻辑省略了</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><h5 id="beans-factory-ctor-arguments-resolution">构造函数参数解决方案</h5><br>构造参数解决方案，会匹配所使用的参数类型。如果在bean的定义中，构造参数不存在歧义，那么，在bean定义中定义的构造参数的次序，在bean实例化时，就是提供给适合的构造参数的次序。看这个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> x.y;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(Bar bar, Baz baz)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>不存在歧义，假设<code>Bar</code>和<code>Baz</code>类没有集成关系，那么下面的配置是合法的，而且，不需要在<code>&lt;constructor-arg/&gt;</code>元素里指定构造参数的明确的<code>indexes</code>索引或者类型。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>若需要引用另一个bean，类型已知，构造函数就可以匹配参数类型(像上面的示例)。使用简单类型时， 想<code>&lt;value&gt;true&lt;/true&gt;</code>,Srping不能决定value类型情况，Spring就不能自己匹配类型。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> examples;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Number of years to calculate the Ultimate Answer</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</div><div class="line"></div><div class="line">    <span class="comment">// The Answer to Life, the Universe, and Everything</span></div><div class="line">    <span class="keyword">private</span> String ultimateAnswer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.years = years;</div><div class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>上面的场景中，如果使用<code>type</code>属性明确指定构造参数的类型,容器就可以使用类型匹配。比如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>使用<code>index</code>属性明确指定构造参数的次序。比如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>当构造函数有2个相同类型的参数,指定次序可以解决此种情况。注意<code>index</code>是从0开始<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ultimateAnswer"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>记住，若要使Spring能从构造函数查找参数名字,代码在编译时必须开启调试模式。若你没有开启调试模式（或者不想），可以使用<code>@ConstructorProperties</code> JDK 注解明确指定构造参数的<code>name</code>。样例程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> examples;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Fields omitted</span></div><div class="line"></div><div class="line">    <span class="meta">@ConstructorProperties</span>(&#123;<span class="string">"years"</span>, <span class="string">"ultimateAnswer"</span>&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.years = years;</div><div class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><h5 id="beans-setter-injection">setter注入</h5><br>Setter注入是容器调用bean上的setter方法,bean是使用无参构造函数返回的实例，或者无参静态工厂方法返回的实例。<br>下面样例中展示了只能使用Setter注入的类。这个类是传统java类，就是个POJO，不依赖容器指定的接口、基类、注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><code>ApplicationContext</code>对它所管理的bean支持构造注入和setter注入。也支持先构造注入再setter注入。定义依赖，会转换成某种形式的<code class="scode">BeanDefinition</code>类，<code class="scode">BeanDefinition</code>类与<code class="scode">PropertyEditor</code>实例配合，即可将属性从一种格式转换成其他格式。然而，大多数程序员不会直接使用这些类（也就是编程式），更多的是使用XML、注解(也就是<code class="scode">@Component</code><code class="scode">@Controller</code>等等),或者<code class="scode">@Configuration</code>注解的类中的方法上使用 <code class="scode">@Bean</code>。这些配置数据，都会在容器内部转换成<code>BeanDefinition</code>，用于加载整个Spring Ioc 容器。<br><br><strong>构造注入对比setter注入</strong><br><br>何时使用构造注入，何时使用setter注入，经验法则是:强制依赖用构造，可选依赖用Setter。注意，在settter方法上使用<code class="scode"><a href="#beans-required-annotation">@Required</a></code>注解即可另属性强制依赖。<br><br>Spring 团队建议,构造注入的实例是不可变的，不为null的。此外，构造注入组件要将完全初始化后的实例返回给客户端代码。还有，大量参数的构造函数是非常烂的，它意味着该类有大量的职责，得重构。<br><br>setter注入主要用于可选依赖,类内部可以指定默认依赖。否则类内所有使用依赖的地方，都得进行非空校验。setter注入的有个好处就是，类可以重配置或者再注入。因此，使用<code>JMX MBeans</code>进行管理的场景中，就非常适合setter注入。<br><br>使用何种依赖注入方式，对于某些类，非常有意义。有时协同第三方类处理，没有源码，由你来决定使用何种方式。比如，第三方类未暴露任何setter方法，那么构造注入也许就是唯一的可行的注入方式了。<br><br><br><h5 id="beans-dependency-resolution">依赖处理过程</h5><br>容器解析bean依赖如下：<br><em> <code>ApplicationContext</code>创建后用配置元数据中描述的所有bean进行初始化。配置元数据格式可以是XML、Java Code，或者注解。
</em> 每个bean的依赖，都会以下列形式表达:属性、构造参数，静态工厂方法的参数。当bean真正的创建时，这些依赖会被提供给bean。<br><em> 每个属性或者构造函数或者以value值形式在bean处直接设置，或者引用容器中其他bean。
</em> 每一个属性或者构造参数都是一个值，该值将会从指定的格式转换为属性、构造参数的真正类型。Spring默认会将一个<code>String</code>类value转换成内建类型，比如<code>int</code>,<code>long</code>,<code>String</code>,<code>boolean</code>等等<br><br>Spring容器在创建bean之前会验证bean的配置。在bean创建之前，bean的属性不会赋值。当容器创建之后，会创建被设置为预先初始化的<code>sington-scope</code>单例作用域bean，非单例作用域bean，只有在请求时才会创建。作用域，在5.5章有定义，<a href="#beans-factory-scopes">“Bean 作用域”</a>。一个bean的创建，可能会引起许多bean的创建。因为bean的依赖以及依赖的依赖得先创建好用于引用。不涉及首先创建的bean及其依赖类bean，会稍后创建。<br><br><strong>循环依赖</strong><br>如果你主要使用构造注入,可能会创建一个循环依赖，该依赖不能解析。<br><br>举个栗子：类A需要类B的实例，使用了构造注入,类B需要一个类A的实例，也用了构造注入。若在配置文件中配置类A的bean和类B的bean互相注入，Spring IoC容器在运行时发现循环引用，抛出异常<code>BeanCurrentlyInCreationException</code>。<br><br>一般使用Setter注入替代构造注入，这需要修改源码改配置，来解决循环依赖。避免使用构造注入或者只使用setter，都能避免循环依赖。 换句话说，虽然不推荐循环依赖，但是你可以使用setter注入来完成循环依赖。<br><br>和大多数场景（无循环引用）不一样的是，循环引用中的类A和类B中，得强制其中一个自己能完全初始化，然后注入给另一个（经典的先有鸡现有蛋的问题）。<br><strong>循环依赖end</strong><br><br>对于Spring，你经管放心，它非常智能。他能在容器加载期发现配置中的问题，比如：引用了一个不存在的bean、循环依赖。Spring在bean创建后，会尽可能迟的设置bean属性并处理依赖。这意味着，spring容器正确加载之后，当你请求一个对象而该对象的创建有问题或者是该对象的依赖有问题时,也能产生一个异常。举例来说，因为属性找不到，或者属性无效， 导致bean抛出异常。这可能会延迟发现配置问题，这就是为什么<code>ApplicationContext</code>默认会预先实例化单例bean。在这些bean被实际请求之前就创建，会消耗一些时间和内存，但是在<code>ApplicationContext</code>创建后你就能发现配置问题，而不是更迟。如果你愿意 ,也可以重写该行为，让单例bean延迟初始化。<br><br><br>如果没有循环依赖，当一个或者多个合作bean被注入到他们的依赖类时，每一个合作bean将会比依赖类更早的实例化。也就是说，如果bean A依赖bean B，Spring Ioc容器在调用A的setter方法之前，会先实例化B。换句话说，bean先实例化(非单例)，然后设置依赖，然后调用相关声明周期方法（比如配置的init方法，或者是初始化回调函数）。<br><br><h5 id="beans-some-examples">注入依赖样例</h5><br>The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions:<br>下面例子中使用了XML配置元数据，setter注入方式。XML 配置文件中的片段定义了bean:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 使用内嵌的ref元素完成setter注入 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用ref属性完成setter注入 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>看java代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AnotherBean beanOne;</div><div class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanOne = beanOne;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanTwo = beanTwo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntegerProperty</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>In the preceding example, setters are declared to match against the properties specified in the XML file. The following example uses constructor-based DI:<br>上例中，setter方法名要和XML文件中的<code>property</code>元素的<code>name</code>属性相匹配。下面演示使用构造注入 ：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>看java代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AnotherBean beanOne;</div><div class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(</span></span></div><div class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i) &#123;</div><div class="line">        <span class="keyword">this</span>.beanOne = anotherBean;</div><div class="line">        <span class="keyword">this</span>.beanTwo = yetAnotherBean;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>在bean定义中指定的构造函数参数，将会赋值给<code>ExampleBean</code>类的参数。<br><br>现在考虑下这个样例的变种，将使用构造器改为静态工厂方法返回对象实例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>看java代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//私有构造函数</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleBean</span><span class="params">(...)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 静态工厂方法; the arguments to this method can be</span></div><div class="line">    <span class="comment">// considered the dependencies of the bean that is returned,</span></div><div class="line">    <span class="comment">// regardless of how those arguments are actually used.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title">createInstance</span> <span class="params">(</span></span></div><div class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i) &#123;</div><div class="line"></div><div class="line">        ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);</div><div class="line">        <span class="comment">// some other operations...</span></div><div class="line">        <span class="keyword">return</span> eb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>静态工厂方法的参数，应该通过<code>constructor-arg</code>元素产生，就像是bean的构造函数一样.工厂方法返回的类的类型无需和工厂类类型相同，虽然本例中他们是相同的。实例工厂方法(非静态）和静态工厂方法本质相同（除了使用<code>facory-bean</code>属性替代<code>class</code>属性，其他都相同），因此细节就不讨论了。<br><br><h4 id="beans-factory-properties-detailed">依赖和配置详解</h4><br>前面章节提到的，你可以定义的bean的属性和构造参数引用其他的Spring bean(合作者)，或者是使用value属性设置其值。Spring XML格式配置元数据至此<code>&lt;property/&gt;</code>和<code>&lt;constructor-arg/&gt;</code>子元素，用以实现构造注入和属性注入。<br><br><h5 id="beans-value-element">直接赋值(原始类型、String等等)</h5><br><code>&lt;property /&gt;</code>元素的<code>value</code>属性为对象域属性或者构造参数设置了一个可读的字串。Spring的会将其转换为实际的与属性或者参数的数据类型。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"masterkaoli"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>下面的样例，是使用了XML配置中的<a href="#beans-p-namespace">p命名空间</a>，他让XML更加简洁<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></div><div class="line">        <span class="attr">destroy-method</span>=<span class="string">"close"</span></div><div class="line">        <span class="attr">p:driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></div><div class="line">        <span class="attr">p:url</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span></div><div class="line">        <span class="attr">p:username</span>=<span class="string">"root"</span></div><div class="line">        <span class="attr">p:password</span>=<span class="string">"masterkaoli"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上面的XML更简洁；然而，错别字，要在运行期才能发现而不能再开发期发现，除非你使用IDE支持自动补全。这样的的IDE的助手真心推荐。<br><br>也可以这样配<code>java.unit.Properties</code>实例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mappings"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</div><div class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</div><div class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>Spring 容器通过JavaBean的<code>PropertyEditor</code>机制将<code>&lt;value/&gt;</code>元素内的值转换到<code>java.util.Properties</code>实例。这是非常棒的，Spring团队最喜欢的几处好用之处之一：用内嵌<code>&lt;value/&gt;</code>元素替代 值属性风格。<br><br><br><h5 id="beans-idref-element">元素<span class="scode">idref</span></h5><br><code>idref</code>元素用来将容器内其它bean的id传给<code>&lt;constructor-arg/&gt;</code> 或 <code>&lt;property/&gt;</code>元素，同时提供错误验证功能。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theClientBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"theTargetBean"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上面的bean定义在运行时等同于下面这一段定义：<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"client"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span> <span class="attr">value</span>=<span class="string">"theTargetBean"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>第一种格式比第二种要跟可取 ，因为使用<code>idref</code>标签，在开发期将允许容器校验引用bean真是存在。在第二个中，对于client bean是属性 <code>targetName</code>的值则没有校验执行 .<code>client</code> bean真正的实例化时，错别字才会被发现（可能会导致致命错）。如果<code>client</code> bean是一个<a href="#beans-factory-scopes">原型bean</a>，这个错字导致的异常也许会等到部署后才能被发现。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 在4.0 beans xsd ，<code>idref</code>上的<code>local</code>属性不在支持。因此它能提供正规bean引用 。当你升级到4.0的语法时，记得清除已经存在于<code>idref</code>元素上的<code>local</code>属性。<br><br><br>一个老生常谈的问题(至少是2.0以前了)，<code>&lt;idref/&gt;</code>带来的好处，在使用<code>ProxyFactorybean</code>bean定义<a href="#aop-pfb-1">AOP拦截器</a>时，当指定拦截器名字是使用<code>&lt;idref/&gt;</code>元素将，容器会校验拦截目标是否存在。<br><br><h5 id="beans-ref-element">引用其他bean(协作类)</h5><br><code>ref</code>元素是<code>&lt;constructor-arg/&gt;</code>元素和<code>&lt;property/&gt;</code>元素内决定性元素。用它设置bean的属性以引用另一个容器管理的bean。引用的bean就是要设置属性的bean的依赖，在设置属性值之前它就要被初始化。(如果协作类是单例bean，它会在容器初始化时首先完成初始化)。差不多所有的bean都会引用其他对象。指定<code>id/name</code>的对象的作用域和依赖校验通过<code>bean</code>,<code>local</code> ,<code>parent</code>属性来配置。<br>指定引用bean通常使用<code>&lt;ref/&gt;</code>标签，它允许引用本容器或者父容器中任意的bean，无需配置在同一个xml文件中 。<code>&lt;ref/&gt;</code>标签中<code>bean</code>的属性值，使用的被引用bean的<code>id</code>或者<code>name</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"someBean"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>通过指定目标bean的<code>parent</code>属性来引用当前容器的父容器中的bean。<code>parent</code>属性的值可以和引用bean的<code>id</code>或者<code>name</code>（引用bean的name之一）相同，引用的bean必须存在于当前容器的父容器中。若容器存在继承的情况，并且需要封装现有父容器中的某个bean到一个代理中，就可以用此种引用机制，一个与<code>parent</code> bean重名的bean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 父容器中 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.SimpleAccountService"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>子容器中<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="accountService" &lt;!-- 和parent bean重名 --&gt;</div><div class="line">    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;</div><div class="line">    &lt;property name="target"&gt;</div><div class="line">        &lt;ref parent="accountService"/&gt; &lt;!--注意如何引用 parent bean --&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!-- 其他配置和依赖 --&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 在4.0 beans xsd ，<code>ref</code>上的<code>local</code>属性不在支持。因次它不再支持正规bean的引用 。当你升级到到4.0时，记得清除已经存在于<code>ref</code>元素上的<code>local</code>属性。<br><br><h5 id="beans-inner-beans">内部bean</h5><br>在<code>&lt;property/&gt;</code>元素或者<code>constructor-arg/&gt;</code>元素内定义<code>&lt;bean/&gt;</code>元素，就是所谓的内部类。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 不是引用而是定义一个bean --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span> <span class="comment">&lt;!-- 这就是内部类 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>内部bean的定义无需<code>id</code>或<code>name</code>；容器会忽略这些属性。也会忽略<code>scope</code>标记。内部通常是匿名的,伴随着外部类（的创建）而创建 。不能引用内部bean(ref属性不能指向内部bean)，除非使用闭合<code>bean</code>标签。<br><br><em>译者注，内部bean更直观</em><br>fuck goods，上干活<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Person person;</div><div class="line"> </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Person person)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.person = person;</div><div class="line">	&#125;</div><div class="line"> </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Person person)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.person = person;</div><div class="line">	&#125;</div><div class="line"> </div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"Customer [person="</span> + person + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>再来一段<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">	private String name;</div><div class="line">	private String address;</div><div class="line">	private int age;</div><div class="line"> </div><div class="line">	//getter and setter methods</div><div class="line"> </div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return "Person [address=" + address + ", </div><div class="line">                               age=" + age + ", name=" + name + "]";</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>通常情况下，使用在<code>CustomerBean</code>bean内设置<code>ref</code>属性值为<code>Person</code>bean的标示符，即完成注入。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">	http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;</div><div class="line"> </div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"CustomerBean"</span> <span class="attr">class</span>=<span class="string">"com.example.common.Customer"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span> <span class="attr">ref</span>=<span class="string">"PersonBean"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"PersonBean"</span> <span class="attr">class</span>=<span class="string">"com.example.common.Person"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"MrChen"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"address1"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"28"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>In general, it’s fine to reference like this, but since the ‘MrChen’ person bean is only used for Customer bean only, it’s better to declare this ‘MrChen’ person as an inner bean as following :<br>一般情况下，这样的引用很好用。但是如果’MrChen’这个person bean只用于<code>Customer</code>。最好是使用内部bean来声明<code>Person</code>，看起来更加直观，更具有可读性.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"> </div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"CustomerBean"</span> <span class="attr">class</span>=<span class="string">"com.mkyong.common.Customer"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"person"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mkyong.common.Person"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"mkyong"</span> /&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"address1"</span> /&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"28"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>This inner bean also supported in constructor injection as following :<br> 内部bean也支持构造注入<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"CustomerBean"</span> <span class="attr">class</span>=<span class="string">"com.mkyong.common.Customer"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mkyong.common.Person"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"mkyong"</span> /&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"address1"</span> /&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"28"</span> /&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><h5 id="beans-collection-elements">集合</h5><br><code>&lt;list/&gt;</code>,<code>&lt;set/&gt;</code>,<code>&lt;map/&gt;</code>,<code>&lt;props/&gt;</code>元素，用来设置<code>Java Collection</code>属性和参数，分别对应<code>List</code>,<code>Set</code>,<code>Map</code>,<code>Properties</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moreComplexObject"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--调用setAdminEmails(java.util.Properties) --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"development"</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 调用setSomeList(java.util.List) --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someList"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代用setSomeMap(java.util.Map) --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someMap"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"an entry"</span> <span class="attr">value</span>=<span class="string">"just some string"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">"a ref"</span> <span class="attr">value-ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 调用 setSomeSet(java.util.Set) --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someSet"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>map.key，map.value，或者set.value，以可以是以下元素<br><br>    bean | ref | idref | list | set | map | props | value | null<br><br><h5 id="beans-collection-elements-merging">集合合并</h5><br>集合合并<br>Spring容器也支持集合合并。应用开发者可以定义父集合<code>&lt;list/&gt;</code>,<code>&lt;map/&gt;</code>,<code>&lt;set/&gt;</code>或者<code>&lt;propx/&gt;</code>元素，该元素可以有子集合<code>&lt;list/&gt;</code>,<code>&lt;map/&gt;</code>,<code>&lt;set/&gt;</code>或者<code>&lt;props/&gt;</code>元素集成或者重写父集合中的值。也就是,子集合中的值是合并父子集合后的值，其中子集合中的值会覆盖父集合中的值。<br><em>这一章节讨论父-子bean机制。不熟悉父子bean定义机制的，最好是先去补充下然后回来继续</em><br>下例中展示了集合合并<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"sales"</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>注意，在bean <code>child</code>定义中，指定<code>property</code> <code>adminEmails</code>的<code>&lt;props/&gt;</code>元素中<code>merge=true</code>属性。当<code>child</code>bean被容器解析并且实例化时，实例有一个<code>adminEmails</code>的<code>Properties</code>集合，该集合包含了父子容器中<code>adminEmails</code>集合合并后的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">administrator=administrator@example.com</div><div class="line">sales=sales@example.com</div><div class="line">support=support@example.co.uk</div></pre></td></tr></table></figure><br><br>子<code>Properties</code>集合的将继承所有父集合中<code>&lt;props/&gt;</code>定义的值，并且重名属性值会覆盖父集合中的值.<br><br>这个合并行为，同样可以用在<code>&lt;list/&gt;</code>,<code>&lt;map/&gt;</code>,<code>&lt;set/&gt;</code>类型上。对于<code>&lt;list/&gt;</code>元素，spring合并行为与<code>List</code>类型的合并一样，也就是，spring合并行为维持集合有序；父集合中的元素索引位置比子集合元素索引位置靠前。对于<code>Map</code>,<code>Set</code>,<code>Properties</code>集合类型,不存在次序。因此，没有次序影响<code>Map</code>,<code>Set</code>,<code>Properties</code>，这涉及到容器内部使用的这些类型的所有实现类。<br><em>译注：这里没有提到List会不会发生覆盖 ,既然没提到，那就是List没有覆盖行为。当然了，实践才是王道，动手实验才能验证推测，研读源码才能知道原理，下面上干货</em><br><br>Java代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionMerge</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> List&lt;String&gt; list;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> list;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.list = list;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>XML配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">class</span>=<span class="string">"com.example.spring.bean.collection.CollectionMerge"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">	        <span class="tag">&lt;<span class="name">list</span> &gt;</span></div><div class="line">	            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">	            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">	        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">parent</span>=<span class="string">"parent"</span> &gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">	        <span class="tag">&lt;<span class="name">list</span> <span class="attr">merge</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">	            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">	            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">	        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</div><div class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class="line"></div><div class="line"><span class="meta">@ContextConfiguration</span></div><div class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMergeTests</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="meta">@Qualifier</span>(<span class="string">"child"</span>)</div><div class="line">	<span class="keyword">private</span> CollectionMerge service;</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		assertEquals(<span class="number">4</span>, service.getList().size());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>经过动手实验，证明Spring合并对于List类型，并无覆盖。接下来，我们看看其源码实现<br><br><strong>MutablePropertyValues.mergeIfRequired()方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> PropertyValue <span class="title">mergeIfRequired</span><span class="params">(PropertyValue newPv, PropertyValue currentPv)</span> </span>&#123;</div><div class="line">	Object value = newPv.getValue();</div><div class="line">	<span class="comment">//属性值是否可合并类</span></div><div class="line">	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> Mergeable) &#123;</div><div class="line">		Mergeable mergeable = (Mergeable) value;</div><div class="line">		<span class="comment">//属性值是否设置了merge=true</span></div><div class="line">		<span class="keyword">if</span> (mergeable.isMergeEnabled()) &#123;</div><div class="line">			<span class="comment">//合并当前属性</span></div><div class="line">			Object merged = mergeable.merge(currentPv.getValue());</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PropertyValue(newPv.getName(), merged);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> newPv;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>上面代码中<code>Mergeable</code>接口共有5个实现类<code>ManagedList</code>,<code>ManagedArray</code>,<code>ManagedMap</code>,<code>ManagedSet</code>,<code>ManagedProperties</code><br><br><strong>ManagedList.merge(Object parent)方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">merge</span><span class="params">(Object parent)</span> </span>&#123;</div><div class="line">		<span class="comment">//防御性抛异常</span></div><div class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.mergeEnabled) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Not allowed to merge when the 'mergeEnabled' property is set to 'false'"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//不能合并非List类型集合</span></div><div class="line">		<span class="keyword">if</span> (!(parent <span class="keyword">instanceof</span> List)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot merge with object of type ["</span> + parent.getClass() + <span class="string">"]"</span>);</div><div class="line">		&#125;</div><div class="line">		List&lt;E&gt; merged = <span class="keyword">new</span> ManagedList&lt;E&gt;();</div><div class="line">		<span class="comment">//注意顺序，先增加父bean中的value值，所以文档中说父集合元素索引位置靠前</span></div><div class="line">		merged.addAll((List) parent);</div><div class="line">		merged.addAll(<span class="keyword">this</span>);</div><div class="line">		<span class="keyword">return</span> merged;</div><div class="line">	&#125;</div></pre></td></tr></table></figure><br><br><em>译注:我勒个去，为了找这段代码，洒家差点累吐血。由此可见，译者是非常用心的用生命去翻译文档。</em><br><br><strong>合并限制</strong><br>不能合并不同类型的集合，比如合并<code>Map</code>和<code>List</code>(<em>译注：上面的源码中有这样的代码，不知聪明的小读者是否注意到了</em>)。如果你非得这么干，那么就会抛出个异常。<code>merge</code>属性必须指定给父-子继承结构bean中的子bean，如果指定给了父集合则无效，不会产生预期的合并结果。<br><br><strong>强类型集合</strong><br>Java5中出现了范型，所以可以给集合使用强类型限制。比如说，声明一个只含有<code>String</code>类型的<code>Collection</code>。若使用Spring 注入一个强类型<code>Collection</code>给一个bean，那么就可以利用Spring的类型转换特性 ，该特性能将给定的值转换成合适的类型值，然后赋值给你的强类型<code>Collection</code>。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Float&gt; accounts;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccounts</span><span class="params">(Map&lt;String, Float&gt; accounts)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.accounts = accounts;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>看，飞碟<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accounts"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"9.99"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"2.75"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"six"</span> <span class="attr">value</span>=<span class="string">"3.99"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>在<code>foo</code>bean的<code>accounts</code>属性注入前，强类型集合<code>Map&lt;String,Float&gt;</code>的泛型信息通过反射获取。因此Spring的类型转换机制识别出元素的value类型将会转换为<code>Float</code>，<code>9.99,2.75,3.99</code>将会转换成<code>Float</code>类型。<br><br><h5 id="`beans-null-element`">Null值和空字串</h5><br>Spring treats empty arguments for properties and the like as empty Strings. The following XML-based configuration metadata snippet sets the email property to the empty String value (“”).<br>Spring对于属性的空参数转换为空字串。下面的XML片段，设置值email属性为空格字串(“”)<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上面的xml配置相当于这样的java代码<br><br>    exampleBean.setEmail(“”)<br><br><code>&lt;null/&gt;</code>元素处理null值：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上面配置相当于<br><br>    exampleBean.setEmail(null)<br><br><h5 id="beans-p-namespace">XML简写p命名空间</h5><br>p-命名空间能让你使用<code>bean</code>元素属性替代内嵌<code>property/&gt;</code>元素，用来描述属性值或者协作类。<br><br>Spirng支持<a href="#xsd-config">命名空间</a>扩展配置,命名空间基于XML Schema定义。本章讨论的<code>beans</code>配置格式定义在XML Schema文档中。然而，p命名空间并不是在XSD文件中，而是存在于Spring核心中。<br><br>下面XML片段解释了:1使用了标准XML，第2个使用p-命名空间<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"classic"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p-namespace"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span></span></div><div class="line">        <span class="attr">p:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上例中解释了，在bean定义中使用p-namespace设置<code>email</code> 属性。它告诉Spring这里有一个<code>property</code>声明。前面提到过，p-namespace 并不存在schema定义，所以<code>p</code>可以修改为其他名字。<br><em>译注,干活都是译者自己撰写用于验证，而非参考手册原版中的内容,之所以验证，是因为原版E文有看不懂的地方、或者翻译拿不准、或者就是闲来无事、或者就是为了凑篇幅，这些事儿得通过写代码验证搞定了</em><br>up fuck goods上干货<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:ppp</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line">        </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p-namespace"</span> <span class="attr">class</span>=<span class="string">"com.example.spring.bean.p.PNamespaceBean"</span></span></div><div class="line">        <span class="attr">ppp:email</span>=<span class="string">"foo@email.com"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>注意p命名空间的用法<code>xmlns:ppp=&quot;http://www.springframework.org/schema/p&quot;</code>和<code>ppp:email=&quot;foo@email.com&quot;</code><br><br>go on fuck goods继续干货<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PNamespaceBean</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String email;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> email;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.email = email;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>下面样例中，2个bean都引用了同一个bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</div><div class="line"></div><div class="line">	&lt;!--传统--&gt;</div><div class="line">    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;</div><div class="line">        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</div><div class="line">        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">	&lt;!--时髦--&gt;</div><div class="line">    &lt;bean name=&quot;john-modern&quot;</div><div class="line">        class=&quot;com.example.Person&quot;</div><div class="line">        p:name=&quot;John Doe&quot;</div><div class="line">        p:spouse-ref=&quot;jane&quot;/&gt;</div><div class="line"></div><div class="line">	&lt;!----&gt;</div><div class="line">    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;</div><div class="line">        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure><br><br>样例中2个p-namespace设置属性值，出现了一种新的格式声明引用。第一个bean中，使用了<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>应用bean jane.第二个bean中，使用了<code>p:spouse-ref=&quot;jane&quot;</code>做了相同的好事儿,此时,<code>spouse</code>是属性名，然而<code>-ref</code>表示这不是直接量而是引用另一个bean。<br><br>&gt;<em>译注</em> 好事儿，我小时候虽然做好事儿不留名，但是总能被发现，令我非常苦恼。我的妈妈常常揪着我的耳朵问：这又是你干的好事儿吧。<br><br><h5 id="beans-c-namespace">c-namespace命名空间</h5><br><br>和<a href="#beans-p-namespace">p-namespace</a>相似,c-namespace，是Spring3.1中新出的,允许行内配置构造参数，而不需使用内嵌的<code>constructor-arg</code>元素<br><br>用<code>c</code>:namespace重构<a href="#beans-constructor-injection">构造注入</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- traditional declaration --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- c-namespace declaration --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:bar-ref</span>=<span class="string">"bar"</span> <span class="attr">c:baz-ref</span>=<span class="string">"baz"</span> <span class="attr">c:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><code>c:</code>namespace和<code>p:</code>使用了相同机制(<code>ref</code>后缀表示引用)，通过names设置构造参数。因为它未定义在XSD schema中（但是存在于Spring内核中）,所以需要先声明。<br><br>有一些情况比较特殊，不能识别或者看到构造参数(比如无源码且编译时无调试信息)，此时可以求助于参数索引:<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:_0-ref</span>=<span class="string">"bar"</span> <span class="attr">c:_1-ref</span>=<span class="string">"baz"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 由于XML语法，索引标记需要<code>_</code>开头作为XML属性名称,而不能使用数字开头(尽管某些ID支持)<br><br>在实际中，构造注入(name匹配/类型匹配/索引匹配)是非常高效的，一般情况下,推荐使用 name匹配方式配置。<br><br><br><h5 id="beans-compound-property-names">复合属性</h5><br>在设置bean属性时，可以使用复合或者内嵌属性,组件路径可以有多长写多长，除了最后一个属性，其他属性都不能为<code>null</code>。看下面的bean定义<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"foo.Bar"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fred.bob.sammy"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>bean <code>foo</code>有属性<code>fred</code>,<code>fred</code>有属性<code>bob</code>,<code>bob</code>有属性<code>sammy</code>,最后的<code>sammy</code>属性赋值<code>&quot;123&quot;</code>。在bean<code>foo</code>构造后，<code>fred</code>属性和<code>bob</code>属性都不能为<code>null</code>否则抛异常<code>NullPointerException</code><br><br><h4 id="beans-factory-dependson">使用depends-on</h4><br><br>若bean是另个bean的依赖，通常是指该bean是另个bean的属性。在XML中通过<code>&lt;ref/&gt;</code><a href="#beans-ref-element">元素</a>配置实现。然而，bean之间并不全是直接依赖。举个栗子,类中有个静态初始化需要出发,像注册数据库驱动这样的。<code>depends-on</code>属性能强制这些先决条件首先完成执行初始化，然后再去使用它（比如用于注入）。<br>下面的样例中，展示了使用<code>depends-on</code>来表达bean之间的依赖关系：<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></div></pre></td></tr></table></figure><br><br>也可以依赖多个bean，为<code>depends-on</code>属性值提供一个bean name列表，用逗号，空白，分号分隔。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager,accountDao"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"manager"</span> <span class="attr">ref</span>=<span class="string">"manager"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 在<a href="#beans-factory-scopes-singleton">单例</a>bean中，<code>depends-on</code>属性既可以设定依赖的初始化时机，也可以相应的设定依赖的销毁时机。在bean被销毁之前,bean使用<code>depdnds-on</code>属性定义的依赖bean会首先被销毁。因此<code>depends-on</code>也能控制销毁顺序。<br><br><h4 id="beans-factory-lazy-init">延迟初始化</h4><br><code>ApplicationContext</code>的各种实现默认的初始化处理过程，都是尽早的创建、配置所有的单例bean。通常，这种预先实例化是非常好的，因为在配置的错误或者环境问题立刻就能暴露出来，而不是数小时甚至数天后才发现。若不需要此行为，可以通过设置<code>lazy-initialized</code>延迟加载来阻止预先初始化。<code>lazy-initialized</code>bean告诉Ioc容器，只有在第一次请求的时候采取初始化，而不是在启动容器时初始化。<br><br><br>在XML中，属性<code>lazy-init</code>控制<code>&lt;bean/&gt;</code>元素的初始化。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.ExpensiveToCreateBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"not.lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.AnotherBean"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br><code>ApplicationContext</code>解析上面的配置，在启动时，不会预先初始化这个标记为lazy的bean，为标记lazy的bean则会立刻初始化。<br><br>如果一个非延迟的单例bean依赖了lazy延迟bean，<code>ApplicationContext</code>会在启动时就创建lazy延迟bean,因为它必须满足单例bean依赖。延迟bean注入给单例bean，就意味着，它不会延迟加载的。<br><br>通过设置<code>&lt;beans/&gt;</code>元素的<code>default-lazy-init</code>属性，可以设置容器级别的延迟加载。看样例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><h4 id="beans-factory-autowire">自动装配</h4><br>Spring容器提供自动装配，用于组织bean之间的依赖。可以让Spring，通过检查<code>ApplicationContext</code>内容完成自动注入。自动装配有以下优点:<br><br><em> 自动装配能明显减少属性和构造参数的配置。（在这方面，还有其他的机制也能达到此目的,比如bean 模板，<a href="#beans-child-bean-definitions">在后面的章节里有详细的讲解</a>）
</em> 自动装配可扩展性非常好。比如，给类增加了依赖,无需修改配置,依赖类就能自动注入。因此，自动装配在开发期非常有用，在代码不稳定时，无需修改编码即可完成切换。<br><br>在XML中，设置<code>&lt;bean/&gt;</code>元素的<code>autowire</code>属性来设定bean的自动装配模式。自动装配有5种模式。可以选择任意一种，来设置bean的装配模式。（<em>译注，这不是废话么，有5中模式，每种都能随便用，假设有一种不能用，那就是4种模式了么</em>）<br><br><strong>Table 5.2. 自动装配模式</strong><br><br>模式 | 解释<br>—– | —–<br>no | (默认的)非自动装配。必须使用<code>ref</code>元素定义bean引用。对于大规模系统，推荐使用，明确的指定依赖易于控制，清楚明了。它在某种程度上说明了系统的结构。<br>byName | 通过属性名称property name自动装配。Spring会查找与需要自动装配的属性同名bean。举个栗子，若在bean定义中设置了by name方式的自动装配，该bean有属性<code>master</code>(当然了，还得有个setMaster(..)写属性方法),Spring会查找一个名叫<code>master</code>的bean，并将它注入给<code>master</code>熟悉。<br>byType | 若在容器中存在一个bean，且bean类型与设置自动装配bean的属性相同，那么将bean注入给属性。若与属性同类型的bean多于1个，则会抛出我们期待已久的致命异常，也就意味着这个bean也许不适合自动注入。若不存在匹配的bean，啥都不会发生;属性也不会设置，然后就没有然后了。<br>constructor | Analogous to byType, but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.和byType模式类似，但是应用于构造参数。若在容器中不存在与构造参数类型相同的bean，那么接下来呢，抛异常呗，还能干啥?<br><br><em>byType</em>或者<em>constructor</em>自动装配模式,可以装配arrays数组和范型集合。 这种个情况<br>下，容器内匹配类型的bean才会注入给依赖。若key类型是<code>String</code>,你也能自动装配强类型<code>Maps</code>。一个自动装配的Map，所有 匹配value类型的bean都会注入<code>Map.value</code>，此时，Map的key就是相应的bean的name。<br><br>可以结合自动装配和依赖检查，依赖检查会在装配完成后执行。<br><br><h5 id="beans-autowired-exceptions">自动装配的局限和缺点</h5><br>自动装配最好是贯穿整个项目。若不是全部或大部分使用自动装配，而仅仅自动装配一两个bean定义，可能会把开发者搞晕。(<em>译注，最可能的原因是，开发者对自动装配机制不熟悉，或者想不到项目中居然还使用了自动装配模式，当发生问题时，擦的，找都没地方找去，调试信息里只能看到经过横切织入事务代理的proxy</em>)<br><br>总结局限和缺点:<br><em> 属性中和构造参数明确的依赖设置会覆盖自动装配。不能自动装配所谓的简单属性，比如原始类型，<code>Strings</code>和<code>Classes</code>(简单属性数组)。这是源于Spring的设计。
</em> 和明确装配相比，自动装配是不确切的。正如上面的列表中提到的，Spring谨慎避免匹配模糊，若真的匹配不正确，则导致错误发生，Spring 管理的对象之间的关系记录也变的不明确了。<br><em> 对于根据Spring容器生成文档的工具，装配信息将变的无用。
</em> 容器内多个bean定义可能会匹配设置为自动装配的<code>setter</code>方法或者构造参数的类型。对于arrays，collections,或者maps,这不是个问题。然而对于期望单一值的依赖，这种歧义将不能随意的解决。如果发现多个类型匹配，将会抛出异常 .<br><br>在后面的场景中，给你几条建议:<br><em> 放弃自动装配，使用明确装配
</em> 避免通过在bean定义中设置<code>autowire-candidate</code>属性为false的方式来设置自动装配，下一章节会讲<br><em> 通过设置<code>&lt;bean/&gt;</code>袁术的<code>primary</code>属性为<code>true</code>来指定单个bean定义作为主候选bean。
</em> 使用基于注解的配置实现更细粒度的控制，参看<a href="#beans-annotation-config">Section 5.9, “Annotation-based container configuration”</a>.<br><br><br><h5 id="beans-factory-autowire-candidate">排除自动装配bean</h5><br>在每个bean的设置中，你可以排除bean用于自动装配。XML配置中，设置<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>属性为<code>false</code>；容器将不使用该bean自动装配。（包括注解配置,像<code>@Autowired</code>）<br><em> 使用对bean名字进行模式匹配来对自动装配进行限制。其做法是在<beans>元素的’default-autowire-candidates’属性中进行设置。比如，将自动装配限制在名字以’Repository’结尾的bean，那么可以设置为”</beans></em>Repository“。对于多个匹配模式则可以使用逗号进行分隔。注意，如果在bean定义中的’autowire-candidate’属性显式的设置为’true’ 或 ‘false’，那么该容器在自动装配的时候优先采用该属性的设置，而模式匹配将不起作用。<em>译注这一段翻译是从网上copy过来的，我勒个擦，得赶紧睡觉去了</em><br><br>这些设置非常有用。但是这些被排除出自动注入的bean是不会自动注入到其他bean，但是它本身是可以被自动注入的。<br><br><br><h4 id="beans-factory-method-injection">方法注入</h4><br>一般情况，容器中的大部分的bean都是<a href="#beans-factory-scopes-singleton">单例的</a>。当单例bean依赖另一个单例bean，或者一个非单例bean依赖另个非单例bean是，通常是将另一个bean定义成其他bean的属性。当bean的生命周期不同时，那么问题来了。假设单例bean A依赖非单例bean(prototype) B，也许会在每个方法里都需要B。容器之创建了一个单例bean A，因此只有一次将B注入的机会。A调用B，需要很多B的实例 ,但是容器不会这么干。<br><br>解决办法是放弃一些IoC控制反转。令A实现接口<code>ApplicationContextAware</code>，此时A能<a href="#beans-factory-aware">够感知容器</a>，即获取<code>ApplicationContext</code>，每次当A调用B时，调用容器的<a href="#beans-factory-client">getBean(“B”)方法用以创建B</a>的实例。看样例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span></div><div class="line"><span class="keyword">package</span> fiona.apple;</div><div class="line"></div><div class="line"><span class="comment">// Spring-API imports</span></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</div><div class="line">        <span class="comment">// grab a new instance of the appropriate Command</span></div><div class="line">        Command command = createCommand();</div><div class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// notice the Spring API dependency!</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">"command"</span>, Command.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(</span></span></div><div class="line">            ApplicationContext applicationContext) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>并不推荐上面的做法，因为业务代码耦合了Spring 框架。方法注入,是SpringIoc容器的高级特性，能够简洁的满足此场景。<br><br>想要了解更多的方法注入，参看此<a href="https://spring.io/blog/2004/08/06/method-injection/" target="_blank" rel="external">博客</a><br><br><h5 id="beans-factory-lookup-method-injection">查找式方法注入</h5><br>查找式是指，容器为了覆盖它所管理的bean的方法，在容器范围内查找一个bean作为返回结果。通常是查找一个原型(prototype)bean，就像是上面章节中提到过的场景。Srping框架，使用<code>CGLIB</code>类库生成动态子类的字节码技术，覆盖方法。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 为了能让动态子类能运行，其父类不能是<code>final</code>类,被覆盖的方法也不能是<code>final</code>。还有，你得自己测试父类是否含有<code>abstract</code>方法，如果有，需要你提供默认实现。最后，被方法注入的对象不能序列化。Spring 3.2以后，不需要<code>CGLIB</code>的类路径了，因为<code>CGLIB</code>被打包入了org.springframework 包，和Spring-core 这个jar包在一起了。既是为了方便也是为了避免<code>CGLIB</code>包与应用中用到的<code>CGLIB</code>包冲突。<br><br>来看看前面提到的<code>CommandManager</code>类的代码片段，Spring容器会动态的覆盖<code>createCommand()</code>方法的实现。这样<code>CommandManager</code>类就不会依赖任何Spring API了。下面是修改过后的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> fiona.apple;</div><div class="line"></div><div class="line"><span class="comment">// 不再有 Spring imports!</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</div><div class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></div><div class="line">		<span class="comment">//</span></div><div class="line">        Command command = createCommand();</div><div class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></div><div class="line">	<span class="comment">//okay....但是方法实现在哪里?</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>在含有被注入方法的类中（像<code>CmmandManager</code>类），被注入方法需要使用以下签名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</div></pre></td></tr></table></figure><br><br>动态生成子类会实现抽象方法。若该方法不是抽象的，动态生成自来则会重写在源类中的方法。配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"command"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"command"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>在<code>commandManager</code>类调用<code>createCommand</code>方法时，动态代理类将会被识别为<code>commandManager</code>返回一个<code>command</code> bean的实例。将<code>command</code>bean设置成<code>prototype</code>,一定要小心处理。若被设置成了<code>singleton</code>，每次调用将返回同一个<code>command</code>bean。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 感兴趣的小读者也找找<code>ServiceLocatorFactoryBean</code>类(在<code>org.springframework.beans.factor.config</code>包)来玩玩。使用<code>ServiceLocatorFactoryBean</code>类的处理手法和另一个类<code>ObjectFactoryCreatingFactoryBean</code>类似，但是<code>ServiceLocatorFactoryBean</code>类与虚拟指定你自己的lookup接口(查找接口)，这与Spring指定lookup接口略有不同。详情参看这些类的javadocs<br><br><em>译注，今天加班晚了点，到家时23:30了，可是今天还没翻。进了家门，打开电脑，翻一小节再说，要不估计睡不着觉了。对于我自己的毅力，我还是有相当的认识的，比如：无论咳的多么严重，都能坚持抽烟，由此可见一斑。以上是玩笑。我的意志力并不强，但是意志薄弱也有意志薄弱的积极的正面的意义，比如我养成了每天翻点东西的习惯，哪怕就是再困、再饿、再累，也得翻译一下，因为要是不翻译的话，我就得跟自己的习惯作斗争了，准确的说是和自己斗争，而我却又没有与自己斗争的念想，我根本打不过我自己，就这样，我又翻了一小节</em><br><br><h5 id="beans-factory-arbitrary-method-replacement">任意方法替换</h5><br>还有一种方法注入方式，不如<code>lookup method</code>注入方式好用，可以用其他bean方法实现替换受管理的bean的任意方法。你可以跳过本节，当真的需要时再回来也是可以的。<br><br>在xml配置中,设置<code>replaced-method</code>元素，就可用其他实现来替换已经部署的bean中存在的方法实现。考虑下面的类，有一个我们要重写的方法<code>computeValue</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">        <span class="comment">// balbalba</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 其他方法...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>有个类实现了<code>org.springframework.beans.factory.support.MethodReplacer</code>接口，类中有新的方法定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 意味着用来重写MyValueCalculator类中computeValue(String)方法的实现</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></div><div class="line">        String input = (String) args[<span class="number">0</span>];</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> ...;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>bean定义，用来部署的源类，要设置方法重写，大概这么搞：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>可以在<code>&lt;replaced-method/&gt;</code>元素内设置一个或多个<code>&lt;arg-type/&gt;</code>元素来指明被替换方法的参数类型。只有被覆盖的方法在类有重载，参数签名才是必要的。为了方便，<code>String</code>类型的参数只需要其完全限定类型名称的字串即可。比如，下面列出的均可匹配<code>java.lang.String</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.String</div><div class="line">String</div><div class="line">Str</div></pre></td></tr></table></figure><br><br>因为参数的数量基本就可以确定方法（重载的方法，基本上是参数数量有区别），此简写能大量减少打字,让你仅打几个字符就能匹配参数类型。<br><em>译注，Spring是工业品质的框架，如此细微的人性化设计，值得学习</em><br><br><h3 id="beans-factory-scopes">bean作用域</h3><br>Spring bean定义时，实际上是创建类实例的配方。这个观点非常重要，因为她意味着，通过一个配方，即可创建很多类的对象。<br><br>对于依据bean定义产生的bean,不仅可以控制依赖、设置对象的值，还可以对象作用域。这个手法强大而灵活，因为在配置过程中就可以可以控制的bean的作用域，无需在代码层面去控制，用代码去控制简直就是煎熬。要部署的bean可有设置1个或多个作用域：开箱即用，Spring框架支持5中作用域，其中有三种只有用web-aware<code>ApplicationContext</code>才能使用。<br><br>下面了列出的作用域开箱即用，你也可以<a href="#beans-factory-scopes-custom">自定义作用域</a><br><br><strong>Table 5.3. Bean scopes</strong><br><br><strong>作用域</strong>  | <strong>描述</strong><br>———  | ——–<br><a href="#beans-factory-scopes-singleton">单例singleton</a> | 默认的。一个bean定义，在一个IoC容器内只会产生一个对象。<br><a href="#beans-factory-scopes-prototype">prototype原型</a> | 一个bean定义会产生多个对象实例<br><a href="#beans-factory-scopes-request">request请求</a> | 一个bean定义产生的bean生命周期为一个HTTP请求；也就是，每一个HTTP请求都会根据bean定义产生一个对象实例。该作用域只有在Spring web上下文环境中才有效。<br><a href="#beans-factory-scopes-session">session会话</a> | 产生的bean生命周期在HTTP 会话期间。该作用域只有在Spring web上下文环境中才有效<br><a href="#beans-factory-scopes-global-session">gloabal session全局session</a> | 声明周期为全局HTTP会话。通常使用portlet context时常用。该作用域只有在Spring web上下文环境中才有效。<br><a href="#beans-factory-scopes-application">application应用</a> | 生命周期与<code>ServletContext</code>一样。该作用域只有在Spring web上下文环境中才有效<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; Spring3.0起 多了一个作用域-<em>thred</em>,但它默认是未注册的(不可用的意思?)。详情请参看文档去吧<code>SimpleThreadScope</code>。有关如何注册该作用域和注册自定义作用域，参看本章使用<a href="#beans-factory-scopes-custom-using">自定义作用域</a><br><br><h4 id="#beans-factory-scopes-singleton">单例作用域</h4><br>单例bean只会产生一个实例,对于所有的请求，Spring容器都只会返回一个实例。<br><br>换句话说,当定义了单例bean，Srping容器只会创建一个实例，这个实例存储在单例池中，单例池应该属于缓存，接下来所有对于该单例bean的请求和引用，都将返回缓存中的对象。<br><br><strong>Figure 5.2.</strong><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/singleton.png" alt="替换的文本可选的"><br><br><br>Spring单例bean的概念，和四人帮GOF那本《设计模式》中定义的<em>单例模式</em>不同。GOF的单例是硬编码级的对象作用域，因此导致每一个类加载器内会产生单例类的一个实例。Spring的单例恰如其名，在容器范围内只会产生一个类实例。Spring中，bean默认的作用域都是单例作用域。使用xml 定义单例bean，像这样:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 和下面的写法相等，因为单例作用域是默认的，所以这么写有些画蛇添足，意思就是废话了 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></div><div class="line">``` </div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">id</span>=<span class="string">'beans-factory-scopes-prototype'</span>&gt;</span>prototype原型作用域<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">设置bean作用域为`prototype`，就是非单例,对于每次请求都将返回一个该类的新实例。也就是说，原型bean注入另一个bean，或者是请求原型bean，都是通过在容器上调用`getBean()`方法产生的。一般来说 ，原型bean用于有状态bean，单例bean用于无状态bean。</div><div class="line"></div><div class="line">下图示例了Srping原型作用域。一个数据访问对象(DAO)通常不会配置成原型作用域,因为通常DAO不会持有任何会话状态；因为作者偷懒，所以重用了上面单例示意图。</div><div class="line">![替换的文本可选的](http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/prototype.png)</div><div class="line"></div><div class="line">接下来看看如何在XML中定义原型bean:</div><div class="line">```xml</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>和其他作用域相比，Srping并不管理原型bean的完整的生命周期：容器实例化，配置或者组装原型独享，注入给其他类，然后并未进一步记录那个原型bean。因此，尽管对象的初始化回调方法会调用，不受scope影响,但是对于原型bean,销毁回调不会被调用。客户端代码必须清理原型对象并且释放原型bean持有的资源。为了让Spring容器释放原型bean持有的资源，可以用自定义的bean<code>[post-processor](#beans-factory-extension-bpp)</code>,<br>它持有需要被清理bean的引用。<br><br>某种意义上，对于原型bean来说,Spring容器的角色就是替换了new 操作符。所有的生命周期管理，在经过实例化之后，都需要由客户端来处理。(Spring 容器中bean的生命周期详情，请参看本章<a href="#beans-factory-lifecycle">5.6.1生命周期回调</a>)<br><br><h4 id="beans-factory-scopes-sing-prot-interaction">单例依赖原型</h4><br>单例类依赖了原型类，要知道依赖在单例类初始化的时候就已经注入好了。因此，若你注入了一个原型bean给单例bean，将会是一个新的原型bean的实例注入了单例bean实例。原型bean实例将会是唯一的实例，再也不会为单例bean产生新的实例。<br><br>假若你需要单例bean在运行时重复的获取新的原型bean实例。那就不能将原型bean注入给单例bean，因为那样注入只会发生一次，就是发生在在Srping容器实例化单例bean并解析注入依赖时。如果需要多次获取新的原型bean实例，参看本章<a href="#beans-factory-method-injection">5.4.6方法注入</a><br><br><h4 id="beans-factory-scopes-other"> Request, session, and global session scopes</h4><br><code>request</code>,<code>session</code>,<code>global session</code>作用域，只有在spring web <code>ApplicationContext</code>的实现中(比如<code>XmlWebApplicationContext</code>)才会起作用，若在常规Spring IoC容器中使用，比如<code>ClassPathXmlApplicationContext</code>中，就会收到一个异常<code>IllegalStateException</code>来告诉你不能识别的bean作用域<br><br><h5 id="beans-factory-scopes-other-web-configuration">初始化web配置</h5><br>为了支持<code>request,sesssion,global session</code>这种级别bean的作用域(web作用域bean)，在定义bean之前需要一些初始化的小配置。（Spring标准作用域，包括单例和原型，无需此配置。）<br><br>如何配置要根据具体的<code>Servlet</code>环境<br><br>若使用 Spring Web MVC访问这些作用域bean，实际上是使用Srping <code>DispatcherServlet</code>类或者<code>DispatcherPortlet</code>类处理request，则无需特别配置：<code>DispatcherServlet</code> 和 <code>DispatcherPortlet</code>已经暴露了所有的相关状态。<br><br>若使用了Servlet 2.5的web容器，使用了非Spring的<code>DispacherServlet</code>处理请求(比如，JSF或者Struts)，则需要注册<code>org.springframework.web.context.request.RequestContextListener ServletRequestListener</code>。若使用的Servlet 3.0+，这些设置可以通过编程式方式使用<code>WebApplicationInitializer</code>接口完成。若使用的是较老的容器,增加下面配置添加到你的web应用的<code>web.xml</code>文件中：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></div><div class="line">            org.springframework.web.context.request.RequestContextListener</div><div class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure><br><br>如果设置<code>listener</code>有问题的话，可以考虑使用<code>RequestContextFilter</code>。filter映射要根据web 应用配置来调整:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure><br><br><code>DispatcherServlet</code>,<code>RequestContextListener</code>,<code>RequestContextFilter</code>都是做相同的事儿，也就是绑定<code>HTTP</code>request对象到服务的<code>Thread</code>线程中，并开启接下来<br>用到的<code>session-scoped</code>功能。<br><br><h5 id="beans-factory-scopes-request">Request作用域</h5><br>考虑下面这种bean定义:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.foo.LoginAction"</span> <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>Spring 使用该bean定义为每一次HTTP 请求创建一个新的<code>LoginAction</code>bean 的实例。也就是,<code>loginAction</code>bean作用域范围在HTTP 请求级别。可以改变实例的内部状态，多少实例都可以，因为根据此<code>loginAciton</code>bean定义创建的其他bean实例并不会看到这些状态的改变；他们为各自的request拥有。当reqeust完成处理，request作用的bean就被丢弃了。<br><br><br><h5 id="beans-factory-scopes-session">session作用域</h5><br>考虑下面这种bean定义:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>在一个session会话期间,Spring容器使用<code>userPreferences</code>定义创建了一个<code>UserPreferences</code>bean的实例。换句话说<code>userPreferences</code>bean在HTTP Session会话期间有效。和<code>request-scoped</code>bean相类似,可以改变bean实例的内部状态，不管bean创建了多少实例都可以，要知道，使用相同的<code>userPreferences</code>定义创建的其他的bean实例看不到这些状态的改变，因为他们都是为各自的HTTP Session服务的。当HTTP Session最终被丢弃时，该session内的<code>session-scoped</code>作用域的bean实例也会被丢弃。<br><br><h5 id="beans-factory-scopes-global-session">全局Session作用域</h5><br>考虑下面这种bean定义:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"globalSession"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>全局session作用域与标准HTTP <a href="#beans-factory-scopes-session">Session作用域</a>类似，仅能应用于基于portlet的web应用的上下文环境中。portlet规范中定义的<code>global Session</code>概念是，在由单个portlet web应用创建的所有的的portlets中共享。全局session作用域的bean和<code>global portlet Session</code>全局portlet会话生命周期相同。<br>若是在标准的基于Servelt web应用中定义了全局session作用域bean，那么将会使用标准的Session作用域,不会报错。<br><br><h5 id="beans-factory-scopes-application">应用作用域</h5><br>考虑下面这种bean定义:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"appPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.AppPreferences"</span> <span class="attr">scope</span>=<span class="string">"application"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>Spring 容器使用该定义为整个web应用创建一个<code>AppPreferences</code>bean的实例。<code>appPreFerences</code>bean作用域是<code>ServeletContext</code>级别,存储为一个常规的<code>ServletContext</code>属性。这个Spring单例作用域有几分相似，但是和单例作用域相比有两个重要不同：1、他是每一个<code>ServeltContext</code>一个实例，而不是Spring<code>ApplicationContext</code>范围。2、它是直接暴露的，作为<code>ServletContext</code>属性，因此可见。<br><br><h5 id="beans-factory-scopes-other-injection">不同级别作用域bean之间依赖</h5><br>Spring IoC容器不仅管理bean的实例化，也负责组装（或者依赖）。如果想将HTTP request作用域bean注入给其他bean，就得给作用域bean(request或者session)注入一个AOP代理用来替换作用域bean。通过注入一个代理对象暴露于作用域bean相同的的接口，他是代理对象也能从相关作用域（request或者session）中检索到真正的被代理对象,并委派方法调用实际对象的方法。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 不需要再单例或者原型bean内部使用<code>&lt;aop:scoped-proxy/&gt;</code><br><br>下面的配置虽然简单，但是重要的理解“为什么”和“如何搞”<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/aop</div><div class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- instructs the container to proxy the surrounding bean --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.foo.SimpleUserService"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- a reference to the proxied userPreferences bean --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>为了创建一个代理，得在作用域bean定义内插入子元素<code>&lt;aop:scoped-proxy/&gt;</code>。详情参看 <a href="#beans-factory-scopes-other-injection-proxies">“Choosing the type of proxy to create”</a> 和 <a href="#xsd-config">Chapter 34, XML Schema-based configuration.)</a>。<code>request</code>, <code>session</code>, <code>globalSession</code> , <code>custom-scope</code>，为什么这些级别的作用域需要<code>&lt;aop:scoped-proxy/&gt;</code>元素？ 下面来做个小测验，一个单例bean定义，对比一下，它如果要实现前面提到的作用域bean注入，该如何配置。（下面的<code>userPreferences</code>bean，实际上并不完整）。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上例中，HTTP Session作用域bean<code>userPreferences</code>注入给了单例bean<code>userManger</code>。注意，<code>userManager</code>bean是一个单例bean:每个容器只会实例化一个，他的依赖(本例中只有一个，<code>userPreferences</code>bean)也仅会注入一次。也就是说，<code>userManager</code>bean只能操作相同的<code>userPreferences</code>对象，就是注入的那一个。<br><br><br><br>将一个短生命周期作用域bean注入给长生命周期作用域bean，比如将HTTP Session作用域bean作为依赖注入给一个单例bean。然而，你需要一个<code>userManager</code>对象，在HTTP Session会话期间，需要与session同生命周期的对象<code>userPreferences</code>。 因此，容器会创建一个对象，该对象拥有和<code>UserPreferences</code>完全相同的public接口并暴露所有的public接口。，该对象能根据作用域机制获取真真的<code>UserPreferences</code>对象。容器会将这个代理对象注入给<code>userManager</code>bean,<code>userManager</code>类则浑然不知这货居然是个代理。样例中，当<code>UserManager</code>实例调用依赖<code>UserPreferences</code>对象上的方法时，，实际上调用的是代理对象上的方法。代理对象从 <code>Session</code>范围内获取真正的<code>UserPreferences</code>对象，并将在代理对象上方法的调用“呼叫转移”给检索到的真正的<code>UserPreferences</code>对象。<br><br>将一个<code>request</code>,<code>session</code>,<code>globalSession</code>作用域bean注入给其他作用域bean，下面是正确的、完整的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br><h5 id="beans-factory-scopes-other-injection-proxies">选择代理类型</h5><br>使用<code>&lt;aop:scoped-proxy/&gt;</code>元素为bean 创建代理时，Spring 容器默认使用<code>CGLIB</code>类型创建代理。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; CGLIB代理只会拦截public方法调用。非public方法不会“呼叫转移”给实际的作用域bean。<br><br>还有个选择，通过配置，使Spring容器为这些作用域bean创建标准的JDK <code>interface-based</code>代理,设置<code>&lt;aop:scoped-proxy/&gt;</code>元素<code>proxy-target-class</code>属性的值为<code>false</code>即可。使用标准JDK接口代理好处是无需引入第三方jar包。然而，作用域bean 至少实现一个接口，需要注入作用域bean的类则依赖这些接口。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultUserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"false"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userPreferences"</span> <span class="attr">ref</span>=<span class="string">"userPreferences"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>For more detailed information about choosing class-based or interface-based proxying, see Section 9.6, “Proxying mechanisms”.<br>关于如何选择<code>class-based</code>和<code>interface-based</code>代理，详情参看<a href="#aop-proxying">Section 9.6, “Proxying mechanisms”</a>.<br><br><h4 id="beans-factory-scopes-custom">自定义作用域</h4><br>bean的作用域机制是可扩展的；可以定义自己的作用域，甚至重新定义已存在的作用域，经管后者不推荐，并且，不能重写内置单例作用域和原型作用域。<br><br><br><h5 id="beans-factory-scopes-custom-creating">创建自定义作用域</h5><br>实现<code>org.springframework.beans.factory.config.Scope</code>接口，就可以将自定义作用域集成到Srping容器中,本章主要将如何实现该接口。如何实现自定义作用域，参看Spring内置的作用域实现和<code>Scope</code>类的javadocs,javadocs中解释了有关需要实现的方法的细节。<br><br><code>Scope</code>接口共有4个方法用于从作用域获取对象、从作用域删除对象、销毁对象(应该是指作用域内，英文档中未提到)<br><br>下面的方法作用是返回作用域中对象。比如，<code>session</code>作用域的实现，该方法返回<code>session-scoped</code>会话作用域bean(若不存在，方法创建该bean的实例，并绑定到session会话中，用于引用，然后返回该对象)<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">get</span><span class="params">(String name, ObjectFactory objectFactory)</span></span></div></pre></td></tr></table></figure><br><br>下面的方法作用是从作用域中删除对象。以<code>session</code>作用域实现为例,方法内删除对象后，会返回该对象，但是若找不到指定对象，则会返回<code>null</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">remove</span><span class="params">(String name)</span></span></div></pre></td></tr></table></figure><br><br>下面的方法作用是注册销毁回调函数，销毁是指对象销毁或者是作用域内对象销毁。销毁回调的详情请参看javadocs或者Spring 作用域实现。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable destructionCallback)</span></span></div></pre></td></tr></table></figure><br><br>下面的方法，用于获取作用域会话标识。每个作用域的标识都不一样。比如，<code>session</code>作用域的实现中，标识就是<code>session</code>标识（应该是指sessionId吧）<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">getConversationId</span><span class="params">()</span></span></div></pre></td></tr></table></figure><br><br><h5 id="beans-factory-scopes-custom-using">使用自定义作用域</h5><br><br>可能是<code>HelloWorld</code>，或者是更多的自定义的<code>Scope</code>实现,得让Spring知道新写的作用域。下面的方法就是如何注册新的作用域到Spring 容器的核心方法:<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void registerScope(String scopeName, Scope scope);</div><div class="line">```  </div><div class="line"></div><div class="line">This method is declared on the ConfigurableBeanFactory interface, which is available on most of the concrete ApplicationContext implementations that ship with Spring via the BeanFactory property.</div><div class="line">此方法声明在`ConfigurableBeanFactory`接口中,该在大部分`ApplicationContext`具体实现中都是可用的，通过`BeanFactor`属性设置</div><div class="line"></div><div class="line">`registerScope(..)`方法第一个参数是作用域名称，该名称具有唯一性。比如Spring容器内置的作用域`singleton`和`prototype`。第二个参数是自定义作用域实现的实例，就是你想注册的、使用的那个自定义作用域。</div><div class="line"></div><div class="line">写好了自定义作用域的实现，就可以像下面那样注册它了：</div><div class="line">![注意](http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png)  </div><div class="line">&gt; 下面的`SimpleThreadScope`作用域，是Spring内置的，但是默认并未注册到容器中。</div><div class="line">你自定义的作用域实现，应该也使用相同的代码来注册。</div><div class="line"></div><div class="line">```java</div><div class="line">Scope threadScope = new SimpleThreadScope();</div><div class="line">beanFactory.registerScope("thread", threadScope);</div></pre></td></tr></table></figure><br><br>接下来是创建一个bean定义，该定义要遵守自定义作用域的规则<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"thread"</span>&gt;</span></div></pre></td></tr></table></figure><br><br>自定义作用域的实现,不局限于编程式注册。也可以使用<code>CustomScopeConfigurer</code>类声明式注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*译注*，编程式就是指硬编码,hard-code，声明式就是指配置，可以是xml可以是注解总之无需直接使用代码去撰写相关代码。不得不说，*编程式和声明式*与*硬编码和配置*相比，更加高端大气上档次。技术人员尤其要学习这种官方的、概念性的、抽象的上档次的语言或者说式地道的表达，假若谈吐用的全是这种词汇，逼格至少提升50%，镇住其他人（入行时间不长的同行，或者面试官）的概率将大大提升。当然了，和生人谈吐要用高逼格词汇，比如*声明式*，*编程式*，然而和自己人就要用人话了，比如*硬编码*,*xml配置*，因为他们得能先听懂才能干活。</div><div class="line">总之，**装逼用官话,聊天用人话**，闲话少絮，看如何声明式注册(因为此处要装逼，人话是看如何xml)</div></pre></td></tr></table></figure><br><br>blablablab<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/aop</div><div class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scopes"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"thread"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.SimpleThreadScope"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span> <span class="attr">scope</span>=<span class="string">"thread"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Rick"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bar"</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; When you place <aop:scoped-proxy> in a FactoryBean implementation, it is the factory bean itself that is scoped, not the object returned from getObject().<br>&gt; 如果在<code>FactoryBean</code>实现中设置了<code>&lt;aop:scoped-proxy/&gt;</code>，表示是工厂bean他本身的作用域，并不是<code>getObject()</code>返回的对象的作用域。TODO<br><br><h3 id="beans-factory-nature">Customizing the nature of a bean自定义bean的xxx擦这个nature该怎么翻</h3>

<p></p><h4 id="beans-factory-lifecycle">生命周期回调函数</h4><br>Spring容器可以控制bean的生命周期,通过实现Spring<code>InitializingBean</code>和<code>DisposableBean</code>接口。容器会调用<code>InitializingBean</code>接口的<code>afterPropertiesSet()</code>方法,也会调用<code>DisposableBean</code>接口的<code>destroy()</code>方法。,也就是运行bean自定义的初始化方法和销毁方法。<p></p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p><strong>Tip</strong><br>JSR-250中,在现代Spring应用中，一般都是用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解定义生命周期回调函数。使用注解的话，你的bean就无需和Spring API耦合了。，详情参看<a href="#beans-postconstruct-and-predestroy-annotations">Section 5.9.7, “@PostConstruct and @PreDestroy”</a><br>如果不想用JSR-250，但又想解耦（Spring API），可以在定义对象的配置中指定<code>init-method</code>和<code>destroy-method</code></p>
</blockquote>
<p>Spring使用<code>BeanPostProcessor</code>实现类处理所有的回调接口并调用相应的方法，接口由Spring 负责查找。若需要自定义功能或其他生命周期行为，Spring并未提供开箱即用的支持,但是可以自己实现<code>BeanPostProcessor</code>类。详情参看<a href="#beans-factory-extension">“Section 5.8, “Container Extension Points”</a></p>
<p>除了<code>initialization</code>和<code>destruction</code>方法,Spring bean也可以实现<code>Lifecycle</code>接口，这些接口可以参与Spring容器生命周期的<code>startup</code>和<code>shutdown</code>过程。</p>
<p>本章讲解生命周期回调接口。</p>
<p></p><h5 id="beans-factory-lifecycle-initializingbean">初始化回调</h5><br><code>org.springframework.beans.factory.InitializingBean</code>接口类的作用是，在容器设置bean必须的属性之后，执行初始化工作。<code>InitializingBean</code>接口中只有一个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure><p></p>
<p>推荐，尽量不用<code>InitializingBean</code>接口，因为这将导致不必要的与Spring的耦合。还有更好的办法，使用<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a>注解，或者指定一个POJO的<code>initialization</code>方法。XML配置元数据中，使用<code>init-method</code>属性用来指定，其值为初始化方法名，初始化方法得是一个无参无返回值(void)方法。如果使用java Config，得在<code>@Bean</code>注解中使用<code>initMehtod</code>属性 ,详情参看 <a href="#beans-java-lifecycle-callbacks">the section called “Receiving lifecycle callbacks”</a>。看代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some initialization work</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和下面的效果相同，但上面的没有耦合Spring。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some initialization work</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p></p><h5 id="beans-factory-lifecycle-disposablebean">销毁回调</h5><br>实现<code>org.springframework.beans.factory.DisposableBean</code>接口，作用是Spring销毁bean时调用该方法。    <code>DisposableBean</code>接口只有一个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure><p></p>
<p>和上面初始化函数一样，推荐你不要使用<code>DisposableBean</code>回调接口，因为会产生不必要的耦合之类的balbalbal。还是和上面一样，能使用 <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PreDestroy</code></a>注解或者指定一个spring bean定义支持的方法TODO？？若使用XML配置，可是使用<code>&lt;bean/&gt;</code>元素的<code>destroy-method</code>属性来完成该设置。若是使用Java config，可以使用<code>@Bean</code>注解的<code>destroyMethod</code>属性来完成销毁回调设置。<a href="#beans-java-lifecycle-callbacks">see the section called “Receiving lifecycle callbacks”</a>。看样例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和下面代码效果一样，但是上面的代码不和Spring耦合<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p><code>&lt;bean&gt;</code>元素的<code>destroy-method</code>属性可以指定一个特别的值，设置该值后Spring将会自动探测指定类上的public <code>close</code>或者<code>shutdown</code>方法。这个设置<em>自动探测销毁方法</em>的属性，也可以设置给<code>&lt;beans/&gt;</code>元素的<code>default-destroy-method</code>属性，用来设置<code>&lt;beans&gt;</code>元素内的所有的<code>&lt;bean&gt;</code> <em>自动探测销毁方法</em>，详情参看<a href="#beans-factory-lifecycle-default-init-destroy-methods">section called “Default initialization and destroy methods”</a>。注意，在Java config配置元数据中，这种<em>自动探测</em>是默认的。</p>
</blockquote>
<p><em>译注，现在是羊年除夕夜23:40，再过30分钟，公司服务器上的一些定时器就要开始运行了。不知道还会不会线程挂起了，多线程中使用网络输出流时如果发生断网，线程则会处于阻塞状态，然后就没有然后一直阻塞，已经修改过了。外面的烟花炮仗声逐渐的密集了起来，放炮仗，污染太重了，国家抑制的手段就和抑制烟草手段一样，重税。心乱了，不能专心翻译了。</em></p>
<p></p><h5 id="beans-factory-lifecycle-default-init-destroy-methods">默认的初始化函数和销毁函数</h5><br>若不是使用<code>InitializingBean</code>和<code>DisposableBean</code>接口实现初始化和销毁回到方法，通常使用规范的方法名比如<code>init</code>,<code>initialize()</code>,<code>dispose()</code>等等。理论上，生命周期回调方法名的规范性，应该贯穿于整个项目中，所有的开发者都应该使用相同的方法名保持一致性。<em>译注，编码规范，Spring最讲究这个了</em><p></p>
<p>可以配置容器查找所有bean的初始化回调和销毁回调，当应用类中的初始化回调方法命名为<code>init()</code>，就不需要在bean定义中配置<code>init-method=&quot;init&quot;</code>属性。Spring IoC容器在bean初始化时调用<code>init()</code>回调。该功能强制初始化和销毁回调方法命名的规范性。</p>
<p>Suppose that your initialization callback methods are named init() and destroy callback methods are named destroy(). Your class will resemble the class in the following example.<br>假设，初始化回调方法命为<code>init()</code>，销毁回调方法命名为<code>destroy()</code>。应该和下面的样例差不多:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBlogService</span> <span class="keyword">implements</span> <span class="title">BlogService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> BlogDao blogDao;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlogDao</span><span class="params">(BlogDao blogDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.blogDao = blogDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// this is (unsurprisingly) the initialization callback method</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blogDao == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The [blogDao] property must be set."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blogService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultBlogService"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogDao"</span> <span class="attr">ref</span>=<span class="string">"blogDao"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在顶级<code>&lt;bean/&gt;</code>元素中定义了<code>default-init-method</code>属性，使Spring Ioc 容器解析bean中名为<code>init</code>的方法为初始化回调方法。当bean创建实例并组装时，若bean类中有个一个<code>init()</code>方法，该初始化回调会在合适的时间调用。</p>
<p></p><h5 id="beans-factory-lifecycle-combined-effects">联合混合使用多种生命周期回调机制</h5><br>Spring2.5 以后,控制bean生命周期行为，有三种生命周期回调机制，或者说是三种方式实现:<a href="#beans-factory-lifecycle-initializingbean">InitializingBean</a> 和 <a href="#beans-factory-lifecycle-disposablebean">DisposableBean</a> 回调接口；自定义<code>init()</code>和<code>destroy()</code>方法;<a href="#beans-postconstruct-and-predestroy-annotations"> @PostConstruct and @PreDestroy </a>注解。这些方式可以混合使用。  <p></p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>如何一个bean上配置了多种生命周期回调机制,并且每种机制都使用了不同的方法，那么所有的回调方法都会按次序执行。然而，如果配置了相同的方法名，比如<code>init()</code>方法作为初始化方法，该方法在多种生命周期回调机制中都有配置，但是，该方法只会执行一次。</p>
</blockquote>
<p>在一个bean中，配置多种生命周期回调机制，每种机制使用了不同的初始化方法，会按照下列次序调用：  </p>
<ul>
<li>带<code>@PostConstruct</code>注解的方法</li>
<li><code>InitializingBean</code>回调接口中的<code>afterPropertiesSet()</code>方法</li>
<li>自定义的<code>init()</code>方法</li>
</ul>
<p>销毁回调也使用相同的次序</p>
<ul>
<li>带<code>@PreDestroy</code>注解的方法</li>
<li><code>DisposableBean</code>回调接口中的<code>destroy()</code>方法</li>
<li>自定义的<code>destroy()</code>方法</li>
</ul>
<p></p><h5 id="beans-factory-lifecycle-processor">容器启动和关闭回调</h5><br><code>Lifecycle</code>接口定了对象有自己生命周期需求的必须的方法（比如启动停止某些后台处理）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>任何Spring管理的对象都可以实现此接口。当<code>ApplicationContext</code>接口启动和关闭时，它会调用本容器内所有的<code>Lifecycle</code>实现。通过<code>LifecycleProcessor</code>来调用,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意<code>LifecycleProcessor</code>接口继承了<code>Lifcycle</code>接口。同时，增加了2个方法，用于处理容器的<code>refreshed</code>和<code>closed</code>事件。</p>
<p><code>startup</code>和<code>shutdown</code>方法调用次序非常重要。若两个对象有依赖关系,依赖方会在依赖启动之后启动,会在依赖停止之前停止。然而,有时依赖并不直接。也许你仅知道某些类型对象优先于另外一种类型启动。此场景中，<code>SmartLifecycle</code>接口也许是个好主意,该接口有个方法<code>getPhase()</code>,此方法是其父接口<code>Phased</code>中的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动时，最低层次的<code>phase</code>最先启动，停止时，该次序逆序执行。因此，若对象实现了<code>SmartLifecycle</code>接口，它的<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>，那么该对象最先启动，最后停止。若是返回了<code>Integer.MAX_VALUE</code>，那么该方法最后启动最先停止（因为该对象依赖其他bean才能运行）。关于<code>phase</code>的值，常规的并未实现<code>SmartLifecycle</code>接口的<code>Lifecycle</code>对象，其值默认为0。因此，负<code>phase</code>值表示要在常规<code>Lifecycle</code>对象之前启动（在常规<code>Lifecycyle</code>对象之后停止），使用 正值则恰恰相反。</p>
<p>如你所见，<code>SmartLifecycle</code>中<code>stop()</code>方法有一个回调参数。所有的实现在关闭处理完成后会调用回调的<code>run()</code>方法。TODO 。它相当于开启了异步关闭功能，和<code>LifecycleProcessor</code>接口默认实现<code>DefaultLifecycleProcessor</code>类的异步，该类会为每个<code>phase</code>的回调等待超时。每个<code>phase</code>默认的超时是30秒。可以重写该类默认的实例，该类在容器内默认bean名称是<code>lifecycleProcessor</code>。如果你仅想修改超时，这么写就足够了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleProcessor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.DefaultLifecycleProcessor"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutPerShutdownPhase"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>As mentioned, the LifecycleProcessor interface defines callback methods for the refreshing and closing of the context as well. The latter will simply drive the shutdown process as if stop() had been called explicitly, but it will happen when the context is closing. The refresh callback on the other hand enables another feature of SmartLifecycle beans. When the context is refreshed (after all objects have been instantiated and initialized), that callback will be invoked, and at that point the default lifecycle processor will check the boolean value returned by each SmartLifecycle object’s isAutoStartup() method. If “true”, then that object will be started at that point rather than waiting for an explicit invocation of the context’s or its own start() method (unlike the context refresh, the context start does not happen automatically for a standard context implementation). The “phase” value as well as any “depends-on” relationships will determine the startup order in the same way as described above.</p>
<p>TODO 书接前文，<code>LifecycleProcessor</code>接口也定义了容器的<code>refreshing</code>和<code>closing</code>事件。后者会驱动<code>shutdown</code>处理，就像是明确的调用了<code>stop()</code>方法,但是它是发生在容器关闭期间。<code>refresh</code>回调开启了<code>SmartLifecycle</code>bean的另一个功能 。当上下文环境刷新时(在所有的对象实例化和初始化之后),则会调用refresh回调，同时，默认的<code>lifecycle processor</code>检查每个<code>SmartLifecycle</code>对象的<code>isAutoStartup()</code>方法返回的布尔值。若为<code>true</code>,对象则会在那时启动，而不是等待容器显示调用之后或者是他自己的<code>start()</code>方法调用之后(这和容器刷新不同，标准的容器实现启动不会自动发生)。<code>phase</code>值和<code>depends-on</code>关系一样，都使用了相同的方法决定了的启动次序。</p>
<p></p><h5 id="beans-factory-shutdown">非web应用中安全的关闭Spring IoC容器</h5><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  <p></p>
<blockquote>
<p>本章适用于非web应用。基于Spring web的应用的<code>ApplicationContext</code>实现类，已经提供了支持，用于在应用关闭时安全的关闭Spring IoC容器。</p>
</blockquote>
<p>在一个非web应用的环境中使用Spring IoC容器;比如,在一个富客户端桌面的环境中；得在JVM中注册一个<code>shutdown</code>钩子。这么做是为了安全的关闭，在关闭时保证所单例bean的相关的<code>destroy</code>方法会被调用，这样就可以释放所有的资源。当然了，你必须得正确的配置和实现销毁回调。</p>
<p>要注册shutdown钩子，得调用<code>registerShutdownHood()</code>方法，该方法在<code>AbstractApplicationContext</code>类中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.support.AbstractApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        AbstractApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(</div><div class="line">                <span class="keyword">new</span> String []&#123;<span class="string">"beans.xml"</span>&#125;);</div><div class="line"></div><div class="line">        <span class="comment">// add a shutdown hook for the above context...</span></div><div class="line">        ctx.registerShutdownHook();</div><div class="line"></div><div class="line">        <span class="comment">// app runs here...</span></div><div class="line"></div><div class="line">        <span class="comment">// main method exits, hook is called prior to the app shutting down...</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h4 id="beans-factory-aware">ApplicationContextAware and BeanNameAware</h4><br><code>org.springframework.context.ApplicationContextAware</code>接口实现类的实例将会持有<code>ApplicationContext</code>的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>因此可以编程式的使用<code>ApplicationContext</code>手动的创建bean,通过<code>ApplicationContext</code>接口或者是该接口的子类，比如<code>ConfigurableApplicationContext</code>，该类还增加了方法。用途之一是编程式的检索bean，有时非常有用。然而，大多数情况下，要避免编程式检索bean，这样的话你的代码就会和Spring耦合，这不是IoC的风格，Ioc的风格是协作类作为bean的属性。<code>ApplicationContext</code>类的其他方法提供了文件资源的访问接口、发布应用事件、访问<code>MessageSource</code>消息资源。这些附加的功能请参看<a href="#context-introduction">Section 5.15, “Additional Capabilities of the ApplicationContext”</a></p>
<p>自Spring2.5起，可以使用自动装配获取<code>ApplicationContext</code>引用。传统的<code>constructor</code>和<code>byType</code>自动装配模式(详情参看 <a href="#beans-factory-autowire">Section 5.4.5, “Autowiring collaborators”</a>能为构造参数或者<code>setter</code>方法提供一个<code>ApplicationContext</code>类的依赖注入。为了更加灵活，还增加了自动注入的注解功能，它能自动注入属性和自动注入多参数方法。使用注解，<code>ApplicationContext</code>可以自动注入到<code>ApplicationContext</code>类型的属性、构造参数、方法参数。详情参看<a href="#beans-autowired-annotation">Section 5.9.2, “@Autowired”</a>.</p>
<p><code>org.springframework.beans.factory.BeanNameAware</code>接口的实现类，若是由<code>ApplicationContext</code>创建了该类的实例,该实例将会持有相关的对象定义的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(string name)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The callback is invoked after population of normal bean properties but before an initialization callback such as InitializingBean afterPropertiesSet or a custom init-method.<br>TODO这个回调在设置属性之后调用，但是在<code>initialization</code>回调之前，比如<code>InitializingBean</code>的<code>afterPropertiesSet</code>或者 自定义的<code>init-method</code></p>
<p></p><h4 id="aware-list">Other Aware interfaces</h4><br>Besides ApplicationContextAware and BeanNameAware discussed above, Spring offers a range of Aware interfaces that allow beans to indicate to the container that they require a certain infrastructure dependency. The most important Aware interfaces are summarized below - as a general rule, the name is a good indication of the dependency type:<p></p>
<p>除上面讨论过的<code>ApplicationContextAware</code>和<code>BeanNameAware</code>，Spring提供了一些了<code>Aware</code>接口，这些接口可以提供容器中相关的基础(SpringAPI)依赖。最重要的<code>Aware</code>接口参看下面的摘要，命名相当规范，看名字就能知道依赖类型：<br><strong>Table 5.4. Aware interfaces</strong><br>名称 | 注入依赖 | 详情<br>—- | —- | ——<br>ApplicationContextAware | ApplicationContext |     <a href="#beans-factory-aware">Section 5.6.2, “ApplicationContextAware and BeanNameAware”</a><br>ApplicationEventPublisherAware | 发布事件 | <a href="#context-introduction">Section 5.15, “Additional Capabilities of the ApplicationContext”</a><br>BeanClassLoaderAware | 加载bean的类加载器 |<a href="#beans-factory-class"> Section 5.3.2, “Instantiating beans”</a><br>BeanFactoryAware | 声明BeanFactory | <a href="#beans-factory-aware">Section 5.6.2, “ApplicationContextAware and BeanNameAware”</a><br>BeanNameAware | 生命bean 的名字 | <a href="#beans-factory-aware">Section 5.6.2, “ApplicationContextAware and BeanNameAware”</a><br>BootstrapContextAware | Resource adapter BootstrapContext the container runs in. Typically available only in JCA aware ApplicationContexts | <a href="#cci">Chapter 26, JCA CCI</a><br>LoadTimeWeaverAware | Defined weaver for processing class definition at load time | <a href="#aop-aj-ltw">Section 9.8.4, “Load-time weaving with AspectJ in the Spring Framework”</a><br>MessageSourceAware | Configured strategy for resolving messages (with support for parametrization and internationalization) | <a href="#context-introduction">Section 5.15, “Additional Capabilities of the ApplicationContext”</a><br>NotificationPublisherAware | Spring JMX notification publisher | <a href="#jmx-notifications">Section 25.7, “Notifications”</a><br>PortletConfigAware | Current PortletConfig the container runs in. Valid only in a web-aware Spring ApplicationContext | <a href="#portlet">Chapter 20, Portlet MVC Framework</a><br>PortletContextAware | Current PortletContext the container runs in. Valid only in a web-aware Spring ApplicationContext | <a href="#portlet">Chapter 20, Portlet MVC Framework</a><br>ResourceLoaderAware | Configured loader for low-level access to resources | <a href="#resources">Chapter 6, Resources</a><br>ServletConfigAware | Current ServletConfig the container runs in. Valid only in a web-aware Spring ApplicationContext | <a href="#mvc">Chapter 17, Web MVC framework</a></p>
<p>注意，这些接口的用法使代码与Spring API耦合，这不符合IoC风格。同样，除非有需求的基础bean才使用编程式访问容器。</p>
<h3 id="beans-child-bean-definitions">Spring Bean的继承</h3><br>Spring bean定义包含各种配置信息，包括构造参数，属性值，容器特定信息例如初始化方法、静态工厂方法等等。Spring子bean定义继承父bean定义配置。子bean能覆盖值，若有需要还能增加其他配置。使用继承能少打好多字。这是模板的一种形式，讲究的就是效率。<br><br>编程式的方式使用<code>ApplicationContext</code>场景，子bean的定义代表<code>ChildBeanDefinition</code>类。大多数用户不需要使用如此底层的SpringAPI，通常是使用类似<code>ClassPathXmlApplicationContext</code>的bean声明。若用XML配置，通过<code>parent</code>属性表示子bean定义，指定父bean的标识作为<code>parent</code>属性值。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">abstract</span>=<span class="string">"true"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithDifferentClass"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></div><div class="line">        <span class="attr">parent</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>若子bean中未指定<code>class</code>属性，则子bean集成父bean的<code>class</code>属性，子bean可以重写覆盖此属性。若要覆盖重写<code>class</code>属性，子bean的class类型必须兼容父bean的class,也就是，子bean必须能接收父bean的属性值。<br><br>其他的属性也是通常取自子bean的配置：<em>depends on, autowire mode, dependency check, singleton, lazy init</em>.<br><br>前面样例中，使用<code>abstract</code>属性指定了父bean为抽象定义。如父bean中未指定class,则必须指定父bean为抽象bean。看代码:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithClass"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></div><div class="line">        <span class="attr">parent</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>上述的父bean不能实例化，因为她不完整，是抽象的bean，作为子bean的纯模板时，它是非常有用的。试试通过属性引用或者使用<code>getBean()</code>方法调用该bean，会抛错。容器内部的<code>preInstantiateSingletons()</code>方法会忽略抽象bean。<br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; <code>ApplicationContext</code>类默认会预先实例化所有的单例bean。因此，如果有做模板用的父bean，父bean定义中指定了<code>classs</code>属性,则必须指定<code>abstract</code>为<code>true</code>,这是非常重要的,否则容器会预先实例化该bean。<br><br><h3 id="beans-factory-extension">容器扩展点</h3><br>通常开发者无需自己实现<code>APplicationContext</code>，而是使用插件扩展Spring IoC容器，插件是某些指定的集成接口的实现。下面记账讲解这些集成接口。<br><br><h4 id="beans-factory-extension-bp">使用BeanPostProcessor自定义bean</h4><br><code>BeanPostProcessor</code>接口定义了实例化逻辑、依赖逻辑等回调方法,即可以自定义也可以覆盖容器默认方法。若果要在Spring容器完成实例化、配置、初始化bean之后执行自定义逻辑,则以插件方式实现<code>BeanPostProcessor</code>。<br><br>可以配置多个<code>BeanPostProcessor</code>实例，可以设置<code>BeanPostProcessors</code>的<code>order</code>属性来控制其执行次序。让<code>BeanPostProcessor</code>实现<code>Ordered</code>接口，就能设置次属性。如果使用自定义<code>BeanPostProcessor</code>，也得考虑实现<code>Ordered</code>接口。更多的细节，参阅<code>BeanPostProcessor</code>和<code>Ordered</code>接口的javadocs。也可以查阅<a href="#">programmatic registration of BeanPostProcessors</a><em>译注，SPring参考手册中这个链接确实没有</em><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>NOTE</strong><br>&gt;<code>BeanPostProcessors</code>操作bean的<em>实例</em>;也就是，Spring IoC容器实例化bean的实例时<code>BeanPostProcessors</code>开始运行。<br>&gt;<br>&gt;<code>BeanPostProcessors</code>在各自容器内有效。当使用容器继承时，<code>BeanPostProcessors</code>缺不会继承。如果在某容器内定义了<code>BeanPostProcessor</code>，近在本容器中生效。或句话说，一个容器中的bean不会使用另一个容器内的<code>BeanPostProcessor</code>处理，继承的容器也不行。<br>&gt;<br>&gt;要改变bean定义(也就是，bean定义的蓝图，<em>译注蓝图应该是指各种配置元数据，比如xml、注解等</em>),你得使用<code>BeanFactorPostProcessor</code>，详情参看<a href="#beans-factory-extension-factory-postprocessors">in Section 5.8.2, “Customizing configuration metadata with a BeanFactoryPostProcessor”</a><br><br><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口有2个回调方法组成。当这样的类在容器内注册为<code>post-processor</code>，容器创建所有bean,在容器初始化方法(比如<code>InitializingBean</code>的<code>afterProperieSet()</code>方法和其他所有的声明的<code>init</code>方法)和所有bean 初始化回调之前，运行<code>post-processor</code>回调。<br><br><code>ApplicationContext</code>自动探测在配置元数据中定义的<code>BeanPostProcessor</code>。<code>ApplicationContext</code>注册这些bean为<code>post-processors</code>，这样就可以在bean创建之前调用。Bean的<code>post-processors</code>可以像其他bean那样部署到容器里。<br><br>注意，在<code>configuration</code>类中，使用<code>@Bean</code>工厂方法声明<code>BeanPostProcessor</code>，该工厂方法的返回类型必须是该实现类或者至少得是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，清楚的标识出<code>post-processor</code>。否则,<code>ApplicationContext</code>不会开启根据类型自动探测。因为<code>BeanPostProcessor</code>需要尽早的实例化，这样在容器中即可用于其他bean的初始化,因此这种尽早的类型探测至关重要。<br><br>&gt;<strong>注意</strong><br>&gt;<strong>编程式注册BeanPostProcessor</strong><br>&gt;尽管推荐的<code>BeanPostProcessor</code>的注册方式是通过<code>ApplicationContext</code>的自动探测机制,但是也可以使用<code>ConfigurableBeanFactory</code>类调用其<code>addBeanPostProcessor</code>实现编程式的注册。编程式注册是非常有用的，比如用于在注册之前实现等价的逻辑，再比如跨容器复制<code>post processors</code>。注意使用编程式注册<code>BeanPostProcessors</code>并不会遵守<code>Ordered</code>接口的次序。注册的顺序就是执行的次序。此外还得记得，编程式的注册<code>BeanPostProcessors</code>会在自动探测注册的<code>BeanPostProcessors</code>之前处理,无论自动探测注册的<code>BeanPostProcessors</code>指定了多么优先的次序。<br>&gt;<strong>注意</strong><br>&gt;<strong>BeanPostProcessor和AOP的自动代理</strong><br>&gt;Classes that implement the BeanPostProcessor interface are special and are treated differently by the container. All BeanPostProcessors and beans that they reference directly are instantiated on startup, as part of the special startup phase of the ApplicationContext. Next, all BeanPostProcessors are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a BeanPostProcessor itself, neither BeanPostProcessors nor the beans they reference directly are eligible for auto-proxying, and thus do not have aspects woven into them.<br>&gt;容器会特殊对待<code>BeanPostProcessor</code>接口。所有的<code>BeanPostProcessors</code>及引用了<code>BeanPostProcessors</code>的bean会在启动时实例化，作为<code>ApplicationContext</code>特殊的启动阶段。接下来，所有的<code>BeanPostProcessors</code>都会按照次序注册到容器中，在其他bean使用<code>BeanPostProcessors</code>处理时也会使用此顺序。因为AOP的<em>auto-proxying</em>自动代理是<code>BeanPostProcessor</code>的默认实现，它既不引用<code>BeanPostProcessors</code>也不引用其他bean，不会发生<em>auto-proxying</em>自动代理,因此不会有切面织入。TODO<br>&gt;<br>&gt;对于<code>BeanPostProcessor</code>类型的bean，会看到这样一条日志:”Bean foo is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)”<br>&gt;注意，如果有bean通过自动注入或者<code>@Resource</code>(可能会导致自动注入)注入到<code>BeanPostProcessor</code>,在使用类型匹配检索依赖bean时Spring也许会访问到不期望的bean，导致生成不合适的auto-proxying自动代理或者其他<code>post-processing</code>。举个栗子，如果使用<code>@Resouce</code>依赖注解，而且<code>field/setter</code>上注解的名字和bean中声明名字不一致时,Spring将会使用类型匹配访问其他bean。<br><br><br>下面 示例中讲解了在<code>ApplicationContext</code>中如何撰写、注册、使用<code>BeanPostProcessors</code><br><br><strong>栗子：Hello World,BeanPostProcessor风格</strong><br>第一个示例，讲解基础用法。栗子展示了一个自定义<code>BeanPostProcessor</code>实现，功能是在容器创建bean时，调用每一个bean的<code>toString()</code>方法并输出到控制台。<br>上干活，fuck goods<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> scripting;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// simply return the instantiated bean as-is</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean,</span></span></div><div class="line">            String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean,</span></span></div><div class="line">            String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/lang</div><div class="line">        http://www.springframework.org/schema/lang/spring-lang.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">lang:groovy</span> <span class="attr">id</span>=<span class="string">"messenger"</span></span></div><div class="line">            <span class="attr">script-source</span>=<span class="string">"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">lang:property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple Is Just So Dreamy."</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">lang:groovy</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line">    when the above bean (messenger) is instantiated, this custom</div><div class="line">    BeanPostProcessor implementation will output the fact to the system console</div><div class="line">    --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"scripting.InstantiationTracingBeanPostProcessor"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>注意<code>InstantiationTracingBeanPostProcessor</code>是如何定义的。它甚至没有名字，因为它能像其他bean那样依赖注入。（上面的配置中，使用<code>Groovy script</code>创建了个bean。Spring动态语言支持的详细讲解参看<a href="#dynamic-language">Chapter 29, Dynamic language support</a><br><br>下面的java应用使用上面的配置和代码执行,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.scripting.Messenger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"scripting/beans.xml"</span>);</div><div class="line">        Messenger messenger = (Messenger) ctx.getBean(<span class="string">"messenger"</span>);</div><div class="line">        System.out.println(messenger);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>将会输出：<br>Bean messenger created : org.springframework.scripting.groovy.GroovyMessenger@272961<br>org.springframework.scripting.groovy.GroovyMessenger@272961<br><br><strong>Example: The RequiredAnnotationBeanPostProcessor</strong><br>对于扩展Spring IoC容器，使用回调函数或者注解联结一个自定义<code>BeanPostProcessor</code>实现类是常用的手段。例如Spring的<code>RequiredAnnotationBeanPostProcessor</code>，是个<code>BeanPostProcessor</code>实现类，spring内置，作用是确保Spring bean定义上的带注解的JavaBean属性确实被注入了值。<br><br><h4 id="beans-factory-extension-factory-postprocessors">使用BeanFactoryPostProcessor自定义配置元数据</h4><br>接下来的扩展点讲一讲<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>。此接口的语法和<code>BeanPostProcessor</code>类似，有一个主要的不同之处：<code>BeanFactoryPostProcessor</code>操作bean的配置元数据;也就是，Spring IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据并且在容器实例化bean之前可能修改配置。<br><br>可以配置多个<code>BeanFactoryPostProcessors</code>，通过设置<code>order</code>属性控制它们的执行次序。<code>BeanFactoryPostProcessor</code>若是实现了<code>Ordered</code>接口，则可设置该属性。若是自定义<code>BeanFactorPostProcessor</code>，同时得考虑实现<code>Ordered</code>接口。详情参阅<code>BeanFactoryPostProcessor</code>的javadocs。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>NOTE</strong><br>&gt; 如果要改变bean实例（根据配置元数据创建的对象）,那么就需要使用<code>BeanPostProcessor</code>(上一章描述的<a href="#beans-factory-extension-bpp">in Section 5.8.1, “Customizing beans using a BeanPostProcessor”</a>)。当使用<code>BeanFactoryPostProcessor</code>处理实例时（使用BeanFactory.getBean()方法）,如此早的处理bean实例，违反了标准的容器生命周期。通过<code>bean post processing</code>也许会引起负面影响。<br>&gt; <code>BeanFactoryPostProcessors</code>的作用域也是在各自的容器内。如果使用容器继承，这一点也是应该注意的。如果在某容器内定义了<code>BeanFactoryPostProcessor</code>,则仅应用于本容器。某容器内的bean定义，不会使用另一个容器的<code>BeanFactoryPostProcessors</code>处理，容器之间有继承关系也不行。<br><br>为了让配置元数据的改变应用，声明在<code>ApplicationContext</code>内的bean工厂<code>post-processor</code>都是自动执行。Spring包含一系列的预先定义的bean工厂<code>post-processors</code>,比如<code>PropertyOverrideConfigurer</code>和<code>PropertyPlaceholderConfigurer</code>。也可以使用自定义<code>BeanFactoryPostProcessor</code>，比如注册一个自定义属性编辑器。<br><br><code>ApplicationContext</code>自动探测<code>BeanFactoryPostProcessor</code>接口的实现类。容器使用这些bean作为bean工厂<code>post-processors</code>。可以像其他bean那样将<code>post-processor</code>部署在容器内。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>NOTE</strong><br>&gt; 若使用<code>BeanPostProcessors</code>,通常不会给<code>BeanFactoryPostProcessors</code>配置延迟初始化。如果没有其他bean引用<code>BeanFactoryPostProcessor</code>,则<code>post-processor</code>根本不会实例化。因此设置延迟初始化将会被忽略，<code>BeanFactoryPostProcessor</code>将会及时实例化，甚至在<code>&lt;beans/&gt;</code>元素设置了<code>default-lazy-init</code>属性为<code>true</code>也不行。<br><br><h5 id="beans-factory-placeholderconfigurer">Example: the Class name substitution PropertyPlaceholderConfigurer</h5><br>可以使用<code>PropertyPlaceholderConfigurer</code>将bean的属性值使用标准的Java Properties格式定义在一个单独的文件中。这样可以将应用的自定义环境配置属性隔离出来，比如数据库URLs和密码，这样就降低了修改容器内XML配置或者Java 代码的的复杂性和风险。<br><br>考虑下面的XML配置片段，使用了<code>placeholder</code>值定义了<code>DataSource</code>。样例展示了一个外部的<code>Properties</code>文件的属性配置。运行时，<code>PropertyPlaceholderConfigurer</code>会应用到配置元数据中，替换指定格式的<code>placeholders</code>,格式为<code>${property-name}</code>，这样的格式与<code>Ant/log4j/JSP EL</code>风格相同。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/foo/jdbc.properties"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>在标准java Properties格式文件中实际的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</div><div class="line">jdbc.url=jdbc:hsqldb:hsql:<span class="comment">//production:9002</span></div><div class="line">jdbc.username=sa</div><div class="line">jdbc.password=root</div></pre></td></tr></table></figure><br><br>因此，字串<code>${jdbc.username}</code>在运行时赋值为<code>sa</code>，其他的<code>${key}</code>都会被替换为文件中与<code>key</code>对应的值。<code>PropertyPlaceholderConfigurer</code>检查bean定义中大多数的<code>placeholders</code>占位符,<code>placeholder</code>的前缀和后缀都是自定义的。<br><br>使用Spring2.5引入的上下文命名空间，就可以用一个专用配置元素配置属性<code>placeholders</code>占位符。可以指定多个<code>locations</code>，多个<code>locations</code>使用<code>,</code>逗号分割。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:com/foo/jdbc.properties"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br><code>PropertyPlaceholderConfigurer</code>不仅仅检索指定的<code>Properties</code>文件。默认情况，若是在指定的<code>Properties</code>配置文件中找不到指定的属性<code>property</code>,也会检查Java 的系统属性<code>System properties</code>。通过设置<code>systemPropertiesMode</code>属性的值，定义默认查找行为，该属性值有几个取值：<br><br><em> never：不检查系统属性
</em> fallback:如果未在指定文件中解析出属性值，则检查系统属性。此项为默认行为。<br><em> override:先检查系统属性。系统属性会覆盖其他配置文件中的属性。<br><br><code>PropertyPlaceholderConfigurer</code>更多详情参看javadocs<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>TIP</strong><br>&gt; 可以使用<code>PropertyPlaceholderConfigurer</code>替换类名，有时，某些类在运行时才能确定，那么这将非常有用。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/foo/strategy.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>custom.strategy.class=com.foo.DefaultStrategy<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceStrategy"</span> <span class="attr">class</span>=<span class="string">"$&#123;custom.strategy.class&#125;"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br>&gt; 若类在运行时期间不能解析为合法类，<code>ApplicationContext</code>创建非延迟初始化bean的<code>preInstantiateSingletons()</code>期间抛错误，<br><br><h5 id="beans-factory-overrideconfigurer">Example: the PropertyOverrideConfigurer</h5><br><code>PropertyOverrideConfigurer</code>，是另一个ben工厂的<code>post-processor</code>,类似于<code>PropertyPlaceholderConfigurer</code>，但是有不同之处，bean源定义可以设置默认值或者根本不设置值。若一个<code>overriding Properties</code>文件不包含某个bean属性,就使用默认的上下文定义。<br><br>注意bean定义并不知道它会被重写，所以使用了重写配置在XML配置中并不直观。如果有多个<code>PropertyOverrideConfigurer</code>实例为相同的bean属性配置了不同的值，最后一个实例配置生效。<br><br>Properties文件配置格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">beanName.property=value</div></pre></td></tr></table></figure><br><br>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql:mydb</div></pre></td></tr></table></figure><br><br>上述文件中的配置，将会赋值给在容器中的定义的bean的相应属性 ，bean的名字是<code>datasource</code>,有<code>driver</code>属性和<code>url</code>属性<br><br>Compound property names are also supported, as long as every component of the path except the final property being overridden is already non-null (presumably initialized by the constructors). In this example…<br><br>同样支持复合属性，属性路径可以要多长有多长，但是属性不能为null(),看样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo.fred.bob.sammy=123</div></pre></td></tr></table></figure><br><br>bean <code>foo</code>有属性<code>fred</code>,<code>fred</code>有属性<code>bob</code>，<code>bob</code>有属性<code>sammy</code>，<code>sammy</code>赋值为<code>123</code><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>Note</strong><br>&gt; 指定重写值都是字面值；不会解析为bean引用。就算是指定的值，在XML的bean定义中bean的名字，也不会解析为该引用，而是解析为字面值。<br><br>使用Spring 2.5中引入的上下文命名空间,可以为配置属性指定专用配置元素<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"classpath:override.properties"</span>/&gt;</span></div></pre></td></tr></table></figure><br><br><h4 id="beans-factory-extension-factorybean">使用FactoryBean自定义实例化逻辑</h4><br>对象实现<code>org.springframework.beans.factory.FactoryBean</code>接口,则成为它本身的工厂。<br><br><code>FactoryBean</code>接口是Spring IoC容器实例化逻辑的扩展点。假如初始化代码非常复杂，此时使用java编码比使用XML配置更容易表达。这种场景中，就可以自定义<code>FactoryBean</code>,在类中撰写复杂的初始化程序，并将其作为插件加入到容器中。<br><br><code>FactoryBean</code>接口有3个方法：
</em> Object getObject():返回本工厂创建的对象实例。此实例也许是共享的，依赖于该工厂返回的是单例或者是原型。<br><em> boolean isSingleton():如果<code>FactoryBean</code>返回的是单例,该方法返回值为<code>true</code>,否则为<code>false</code>
</em> Class getObjectType():返回对象类型。对象类型是<code>getObject()</code>方法返回的对象的类型，如果不知道的类型则返回null。<br><br><code>FactoryBean</code>概念和接口在Spring框架中大量使用。Spring内置的有超过50个实现。<br><br>当使用<code>ApplicationContext</code>的<code>getBean()</code>方法获取<code>FactoryBean</code>实例本身而不是它所产生的bean，则要使用<code>&amp;</code>符号+id。比如，现有<code>FactoryBean</code>，它有id，在容器上调用<code>getBean(&quot;myBean&quot;)</code>将返回<code>FactoryBean</code>所产生的bean，调用<code>getBean(&quot;&amp;myBean&quot;)</code>将返回<code>FactoryBean</code>它本身的实例。<br><br><h3 id="beans-annotation-config">基于注解的把配置元数据</h3><br><strong>注解比XML好么?</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">注解比XML好么，简单的说得看情况。详细的说，各有优缺点。因为定义的方式，注解在声明处提供了大量的</div><div class="line">上下文信息，所以注解配置要更简洁。然而,XML擅长在不接触源码或者无需反编译的情况下组装组件。</div><div class="line">虽然有这样的争议：注解类不再是`POJO`，并且配置更加分散难以控制，</div><div class="line">但是还是有人更喜欢在源码上使用注解配置。</div><div class="line"></div><div class="line">无论选择哪一样，Spring都能很好的支持，甚至混合也行。值得指出的是，</div><div class="line">使用`[JavaConfig](#beans-java)`选项，Spring能在不接触目标组件源码的情况下</div><div class="line">无侵入的使用注解，这可以通过IDE完成 [Spring Tool Suite](https://spring.io/tools/sts)</div></pre></td></tr></table></figure><br><br>对于XML配置，还有另外一个选择，基于注解的配置，它是依赖于字节码元数据，替代XML组装组件。码农码畜可以使用注解替代XML描述bean的组装，开发者将配置撰写到组件类上，使用注解标注相关的类、方法、域上。就像前面提到的 <a href="#beans-factory-extension-bpp-examples-rabpp">in the section called “Example: The RequiredAnnotationBeanPostProcessor”</a>，使用<code>BeanPostProcessor</code>联结注解是常见的扩展Spring IoC容器的手段。举个栗子，Spring2.0引入的通过<a href="#beans-required-annotation"><code>@Required</code></a>注解强制检查必须属性值。Spring 2.5采用了类似的手法使用注解处理依赖注入。本质上，<code>@Autowired</code>注解提供了相同的能力，在这一章有详解<a href="#beans-factory-autowire">Section 5.4.5, “Autowiring collaborators”</a>,但是<code>@Autowired</code>提供了更细粒度的控制和更强的能力。Spirng 2.5也增加了对JSR-250注解的支持，比如<code>@PostConstruct</code>,<code>@PreDestory</code>。Srping3.0增加支持了JSR-330(JAVA依赖注入)注解,这些注解在<code>javax.inject</code>包内，例如<code>@Inject</code>和<code>@Named</code>。详情参看那些注解的<a href="#beans-standard-annotations">相关章节</a>。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>注意</strong><br>&gt; 注解注入在XML注入<em>之前</em>执行，因此同时使用这两种方式注入时，XML配置会覆盖注解配置。<br><br>同样的Spring风格，就像特别的bean定义那样注册他们，但是也能像下面这样隐式注册（注意包含context namespace上下文命名空间）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>(隐式注册的<code>post-processors</code>包括<code>AutowiredAnnotationBeanPostProcessor</code>,<code>CommonAnnotationBeanPostProcessor</code>,<code>PersistenceAnnotationBeanPostProcessor</code>,还有前面提到的<code>RequiredAnnotationBeanPostProcessor</code>)<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>注意</strong><br>&gt; <code>&lt;context:annotation-config/&gt;</code>仅会检索它所在的应用context上下文中bean上的注解。也就是，如果在<code>WebApplicationContext</code>中为<code>DispatcherServlet</code>设置<code>&lt;context:annotation-config/&gt;</code>，它仅会检查<code>controllers</code>中<code>@Autowired</code>的bean,并不会检查<code>service</code>。详情参看<a href="#mvc-servlet">Section 17.2, “The DispatcherServlet”</a><br><br><h4 id="beans-required-annotation">@Required</h4><br><code>@Required</code>注解应用于bean的setter方法，像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Required</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>这个注解意思是受到影响的bean属性在配置时必须赋值,在bean定义中明确指定其属性值或者通过自动注入。若该属性未指定值，容器会抛异常。这导致及时明确的失败，避免<code>NullPointerExceptions</code>或者晚一些时候才发现。仍然推荐，你在编码过程中使用断言，举个栗子，在<code>init</code>方法，做了这些强制的必须引用的检查，但是属性值甚至不再容器范围内。<br><br><h4 id="beans-autowired-annotation">@Autowired</h4><br>如你所料,<code>@Autowired</code>注解也是应用在”传统的”setter方法上：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>注意</strong><br>&gt; 在下面的样例中，使用JSR 330的<code>@Inject</code>注解可以替代<code>@autowired</code>注解。<a href="#beans-standard-annotations">详情参看这里</a><br><br>也可以将注解用于带一个或多个参数的其他方法上，看样例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span></div><div class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</div><div class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</div><div class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><code>@Autowired</code>也可以应用于构造函数上或者属性上：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>也可以用在数组上 ，注解标注于属性或者方法上，数组的类型是<code>ApplicationContext</code>中定义的bean的类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>同样也可以应用于集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt;<strong>注意</strong><br>&gt; 如果你想指定数组元素或者集合元素的次序，那么可以通过以下方式：bean实现<code>org.springframework.core.Ordered</code>接口，或者使用<code>Order</code>或者使用<code>@priority</code>注解。<br><br>甚至Map也可以自动注入autowired，只要key的类型是<code>String</code>。 Map的value将会包含期待类型的所有bean，key是相应bean的name:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>默认情况下，当没有候选bean可用的时候自动注入会失败；在方法上、构造函数上、域上的注解，默认是必须的。这个也是可以设置为非必须的，看样例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; Only one annotated constructor per-class can be marked as required, but multiple non-required constructors can be annotated. In that case, each is considered among the candidates and Spring uses the greediest constructor whose dependencies can be satisfied, that is the constructor that has the largest number of arguments.<br>&gt;  每个类中只有一个被注解的构造函数能被标记为<code>required</code>,但是其他构造函数也能被注解。这种情况下，每个构造函数都会在候选者之间被考虑，Spring使用<em>贪婪模式</em>选取构造函数，也就是拥有最多数量构造参数的那一个。TODO<br>&gt; 推荐使用<code>@Autowired</code>的<code>required</code>属性覆盖<code>@Required</code>注解。<code>required</code>属性表名那个属性对于自动注入可能不需要,如果不能被装配则属性将会被忽略。<code>Required</code>，另一方面，更加强调的是，强制执行设置属性值，可以通过容器提供的任何手段。<br><br>可以使用<code>@Autowired</code>注入常见的Spring API的依赖：<code>BeanFactory</code>,<code>ApplicationContext</code>,<code>Environment</code>,<code>ResourceLoader</code>,<code>ApplicationEventPublisher</code>,<code>MessageSource</code>。这些接口和他们的子类及实现类都可以比如，<code>ConfigurableApplicationContext</code>,<code>ResourcePatternResolver</code>都可以自动解析,无需特别设置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ApplicationContext context;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; <code>@Autowired, @Inject, @Resource, and @Value</code>注解由<code>BeanPostProcessor</code>接口的实现类处理，也就是说你不能使用自定义的<code>BeanPostProcessor</code>或者自定义<code>BeanFactoryPostProcessor</code>应用这些注解。这些类型的组装，必须明确的由XML或者使用Spring <code>@Bean</code>方法完成。<br><br><h4 id="beans-autowired-annotation-qualifiers">使用限定符对自动注入注解微调</h4><br>因为根据类型自动注入会导致多个候选者，对于选择哪个候选者则需要更细粒的控制。其中一种方式是使用Spring的<code>@Qualifier</code>注解。可以将<code>qualifier</code>关联指定参数，让类型匹配自动注入可精准的选择所需的bean。看样例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Qualifier</span>(<span class="string">"main"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><code>@Qualifier</code>注解也可以在构造参数或者方法参数上使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(@Qualifier(<span class="string">"main"</span>)</span>MovieCatalog movieCatalog,</span></div><div class="line">            CustomerPreferenceDao customerPreferenceDao) &#123;</div><div class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</div><div class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>下面看看相应的bean定义，也就是上例中<code>Qualifier(&quot;main&quot;)</code>的bean是如何定义的，也就是如何制定bean的<code>Qualifier</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"main"</span>/&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"action"</span>/&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>bean的name会作为备用<code>qualifier</code>值。因此你可以定义bean的id为<code>main</code>替代内嵌的<code>qualifier</code>元素，这将同样会匹配上。然而，虽然可以使用此惯例通过name去引用,但是<code>@Autowired</code>是基于类型驱动注入,qualifiers只是可选项。这就意味着<code>qualifier</code>值，甚至是bean 的name作为备选项，只是为了缩小类型匹配的范围；他们并不能作为引用的bean的唯一标示符。好的<code>qualifier</code>值是<code>main</code>,<code>EMEA</code>,<code>persistent</code>,能表达具体的组件的特性,这些qualifier独立于bean的<code>id</code>，因为id可能是匿名bean自动生成的。<br><br>限定符Qualifiers也能应用于集合，就像上面讨论的那样，举个栗子，设置<code>Set&lt;MovieCtalog&gt;</code>。这个场景中，根据声明的限定符qualifiers所匹配的bean都会被注入到集合内。这意味着限定符qualifiers并不是唯一的;它们更像是简单的分类。比如，定义多个bean<code>MovieCatalog</code>,使用相同的限定符qulifier值<code>action</code>;这些bean都将被注入到带有<code>@Qualifier(&quot;action&quot;)</code>注解的<code>Set&lt;MovieCatalog&gt;</code>中。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 若要通过name名字来驱动注解注入，首先不能使用<code>@Autowired</code>,甚至不能使用<code>@Qualifier</code>来表示引用bean。而是，使用JSR-250的<code>Resource</code>注解，该注解能在语法上标识出目标组件的唯一标识，匹配时将会忽略声明bean的类型。<br>&gt;<br>&gt; 使用此语法的导致了这样的结果,包含某类型bean的集合或者map不能通过<code>@Autowired</code>注解注入，因为<code>@Resouce</code>并不是使用类型匹配的。这些bean使用<code>@Resource</code>,将会通过唯一的name引用指定的集合或者map。<code>@Autowired</code>应用于域field,构造函数，和多参数方法，允许在参数上使用<code>qualifier</code>限定符注解缩小取值范围。作为对比，<code>@Resouce</code>仅支持域field和bean属性的setter方法，该方法只能有一个参数。因此，如果你注入的目标是构造函数或者是多参数方法，你得使用<code>qualifiers</code>限定符。<br><br>You can create your own custom qualifier annotations. Simply define an annotation and provide the @Qualifier annotation within your definition:<br>你可以创建自定义的限定符qualifier注解。定义一个简单的的注解，在定义上提供一个<code>@Qulifier</code>注解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Genre &#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>这是，你就能在自动装配域和参数上使用自定义<code>qualifier</code>限定符:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Genre</span>(<span class="string">"Action"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog actionCatalog;</div><div class="line">    <span class="keyword">private</span> MovieCatalog comedyCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComedyCatalog</span><span class="params">(@Genre(<span class="string">"Comedy"</span>)</span> MovieCatalog comedyCatalog) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.comedyCatalog = comedyCatalog;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>接下来，提供候选者bean定义的信息。可以在<code>&lt;bean/&gt;</code>标签上增加<code>&lt;qualifier/&gt;</code>标签子元素，然后指定type类型和value值来匹配自定义的<code>qualifier</code>注解。<code>type</code>是自定义注解的权限定类名(包路径+类名)。如果没有重名的注解，那么可以使用类名(不含包路径)。看样例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"Genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        _<span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"example.Genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>在<a href="#beans-classpath-scanning">Section 5.10, “Classpath scanning and managed components”</a>中，你会看到基于注解的XMLqualifier限定名元数据。详细的信息参看<a href="#beans-scanning-qualifiers">Section 5.10.8, “Providing qualifier metadata with annotations”</a>.<br><br>在某些场景中，若不给注解指定value值的话可能不能满足需求。出于范型目的的注解，可以应用到不同类型的依赖。比如，你可以提供一个离线目录在无网络连接时候任然可以检索。先定义一个简单的注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Offline &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>然后在自动装配的field域或者propety属性上增加该注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Offline</span></div><div class="line">    <span class="keyword">private</span> MovieCatalog offlineCatalog;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>现在，bean的定义只需要指定限定qualifier类型:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"Offline"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br>也可以为自定义限定名qualifier注解增加属性，用于替代简单的value属性。如果有多个属性值在自动装配的域field或者是参数上指定，bean的定义必须全部匹配这些属性值才能作为自动装配的候选者。举个栗子，看样例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MovieQualifier &#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">genre</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Format <span class="title">format</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>Format是个枚举enum:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Format &#123;</div><div class="line">    VHS, DVD, BLURAY</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>需要自动装配的域field都是用自定义qulifier注解，注解中都设置了2个属性：<code>genre和format</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Action"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog actionVhsCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Comedy"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog comedyVhsCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@MovieQualifier</span>(format=Format.DVD, genre=<span class="string">"Action"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog actionDvdCatalog;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@MovieQualifier</span>(format=Format.BLURAY, genre=<span class="string">"Comedy"</span>)</div><div class="line">    <span class="keyword">private</span> MovieCatalog comedyBluRayCatalog;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>最后，Spring bean的定义应该包含匹配qualifier的values值。这个例子中展示了bean<code>meta</code>属性替代的<code>&lt;qualifier/&gt;</code>子元素。如果可以，<code>&lt;qualifier/&gt;</code>及其属性优先生效，但是若没有<code>qualifier</code>出现，自动装配机制会使用<code>&lt;meta/&gt;</code>标签的值，看样例，后面的2个bean定义演示了<code>meta</code>标签:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"MovieQualifier"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"VHS"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"MovieQualifier"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"VHS"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"DVD"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"BLURAY"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><h4 id="beans-generics-as-qualifiers">范型作为自动装配限定符</h4><br><code>@Qualifier</code>注解，也常用于java范型作为隐式的限定符qualification。比如：假如有下列配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StringStore <span class="title">stringStore</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IntegerStore <span class="title">integerStore</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>假设上面的bean实现了范型接口，也就是<code>Store&lt;String&gt;</code>和<code>Store&lt;Integer&gt;</code>，那么久可以使用<code>@Autowired</code>注解<code>Store</code>接口，范型作为限定符qualifier:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span></div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span></div></pre></td></tr></table></figure><br><br>范型限定符qualifiers也同样应用于自动装配<code>Lists</code>,<code>Maps</code>和<code>Arrays</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span></div><div class="line"><span class="comment">// Store&lt;String&gt; beans will not appear in this list</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;</div></pre></td></tr></table></figure><br><br><h4 id="beans-custom-autowire-configurer">CustomAutowireConfigurer</h4><br><code>CustomAutowireConfigurer</code>是<code>BeanFactoryPostProcessor</code>，允许注册自定义限定符qualifier注解类型，无需指定<code>@Qualifier</code>注解：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customAutowireConfigurer"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.annotation.CustomAutowireConfigurer"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customQualifierTypes"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>example.CustomQualifier<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><br><br><code>AutowireCandidateResolver</code>是自动装配候选者而定：<br><em> 每一个bean定义中的<code>autowire-candidate</code>值
</em> <code>&lt;bean/&gt;</code>元素上<code>default-autowire-candidates</code>可用的模式<br><em> the presence of @Qualifier annotations and any custom annotations registered with the CustomAutowireConfigurer
</em> 出现的<code>@Qualifier</code>注解和任何通过<code>CustomAutowireConfigurer</code>注册的自定义注解。<br><br>当多个bean的qualify限定符作为自动装配的候选者，“首要bean”决定于：候选者中有bean指定了<code>primary</code>属性值为<code>true</code>，那么它将陪选中（注入）。<br><br><h4 id="#beans-resource-annotation">@Resouce</h4><br>Spring也支持JSR-250<code>@Resource</code>注解注入，标注在域field或者属性setter方法上。这是 Java EE 5 and 6中常用的模式，比如JSF1.2管理的bean或者JAX-WS2.0的endpoints。 Spring管理Spring对象支持这些模式。<br><br><code>@Resource</code>使用name属性，Spring默认解释其value值作为注入bean的名字。看样例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span>(name=<span class="string">"myMovieFinder"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>如果没有明确的指定name ,默认的name取值就是域field name或者从setter方法派生。如果是域name,则原封不动的使用该域;如果是setter方法派生，将获取setter方法内设置的属性property名字(<em>译注，应该就是field name域名字</em>)。所以下面的样例中，会吧bean名字为”movieFinder”注入给setter方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; <code>ApplicationContext</code>若使用了<code>CommonAnnotationBeanPostProcessor</code>，注解提供的name名字将被解析为bean的name名字。如果配置了明确的Spring的<code>SimpleJndiBeanFactory</code>，这些name名字将通过<code>JNDI</code>解析。然而，推荐你使用默认的行为，简单的使用Spring的<code>JNDI</code>，这样可以保持逻辑引用，而不是直接引用。<br><br><code>@Resource</code>没有明确指定name时，和<code>@Autowired</code>相似,对于特定bean(SpringAPI内的bean)，<code>@Resource</code>会以类型匹配方式替代bean name名字匹配方式，比如：<code>BeanFactory, ApplicationContext, ResourceLoader, ApplicationEventPublisher, and MessageSource</code>接口<br><br>因此，下面的样例中，<code>customerPreferenceDao</code>field域首先查找名字为<code>customerPreferenceDao</code>的bean，若未找到，则会使用类型匹配<code>CustomerPreferenceDao</code>类的实例。<code>context</code>field域将会注入<code>ApplicationContext</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</div><div class="line"></div><div class="line">    <span class="meta">@Resource</span></div><div class="line">    <span class="keyword">private</span> ApplicationContext context;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><h4 id="beans-postconstruct-and-predestroy-annotations">@PostConstruct and @PreDestroy</h4><br><code>CommonAnnotationBeanPostProcessor</code>不仅能识别<code>@Resource</code>注解，也能识别JSR-250生命周期注解。Spring 2.5提供了对这些注解的支持，也提供了以下注解的支持:<a href="#beans-factory-lifecycle-initializingbean">initialization callbacks</a> and <a href="#beans-factory-lifecycle-disposablebean">destruction callbacks</a>。<code>CommonAnnotationBeanPostProcessor</code>提供了这些注解的支持，它是Spring <code>ApplicationContext</code>注册，它会在相应的Spring bean生命周期调用相应的方法，就像是Spring生命周期接口方法，或者是明确声明的回调函数。在下面的样例中，会根据初始化方法执行缓存，在销毁时执行清理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateMovieCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// populates the movie cache upon initialization...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PreDestroy</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMovieCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// clears the movie cache upon destruction...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 关于多重生命周期变量机制，详情参看<a href="#beans-factory-lifecycle-combined-effects">the section called “Combining lifecycle mechanisms”</a><br><br><h3 id="beans-classpath-scanning">ClassPath扫描和管理组件</h3><br>本章大多数的样例都是使用XML格式配置元数据配置Spring bean，然后Spring容器根据这些配置产生<code>BeanDefinition</code>。虽然前面章节(<a href="#beans-annotation-config">Section 5.9, “Annotation-based container configuration”</a>)展示了大量的源码级别注解配置元数据的情况,但是，注解也仅仅用于驱动依赖注入，”base”bean依然是在明确的在XML文件中定义。本章将讲解新的内容，如何通过扫描classpath ，隐式检索特殊的Spring bean，也就是后面提到的候选者组件。候选者组件是class类,这些类经过过滤匹配，由Spring容器注册注册的bean定义，成为Spring bean。这样就没有XML什么事儿了，<em>译注go egg,太粗鲁了吧</em>，也就是无需使用XML定义bean，而是使用注解(比如<code>@Component</code>),<code>AspectJ</code>表达式,或者是自定义的过滤器，使用自定义的过滤器选择那些类将会被注册到容器中。<br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; Spring3.0开始，<code>JavaConfig</code>项目中很多功能已经集成到Spring框架中。这就可以使用Java定义beans而不是传统的XML了。看看<code>@Configuration</code>,<code>@Bean</code>,<code>@Import</code>,<code>@DependsOn</code>的样例，即可学习如何使用这些功能。<br><br><h4 id="beans-stereotype-annotations">@Component和各代码层注解</h4><br><code>@Repository</code>注解注解用于DAO层。使用此注解会自动转换异常，详情参看<a href="#orm-exception-translation">Section 15.2.2, “Exception translation”</a><br><br>Spring提供了各层代码注解：<code>@Component, @Service, and @Controller</code>。<code>@Component</code>是通用的Spring bean，也即是由Spring管理的组件。<code>@Repository, @Service, @Controller</code>和<code>@Component</code>相比，更加精准的用于各个代码层，它们分别用于持久化层persistence,service服务层,和presentation layers表现层。因此，可以将类注解<code>@Component</code>，但是如果使用<code>@Repository, @Service, or @Controller</code>替代，也许更适于工具去处理，或者和<code>aspects</code>关联。比如，在某层代码上做切点。也许在Spring框架未来的版本中，<code>@Repository, @Service, and @Controller</code>会附加更多的功能，也就是易于扩展。因此，对于在service层使用<code>@Component</code>还是<code>@Service</code>的纠结，无疑<code>@Service</code>是最好的选择。同理，在持久化层要选择<code>@Repository</code>,它能自动转换异常。<br><br><h4 id="beans-meta-annotations">Meta-annotations元注解</h4><br><em>译注，元注解就是修饰注解的注解</em><br>Spring提供的很多注解能作为“元注解”使用。元注解是简单的注解，可以应用于其他注解。比如，前面提及的<code>@Service</code>注解就是<code>@Component</code>的元注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Component</span> <span class="comment">// Spring will see this and treat @Service in the same way as @Component</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</div><div class="line"></div><div class="line">    <span class="comment">// ....</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>多个元注解也能联合起来，成为复合注解。比如，Spring MVC中的<code>@RestController</code>注解就是有<code>@Controller</code>和<code>@ResponseBody</code>。<br>With the exception of value(), meta-annotated types may redeclare attributes from the source annotation to allow user customization. This can be particularly useful when you want to only expose a subset of the source annotation attributes. For example, here is a custom @Scope annotation that defines session scope, but still allows customization of the proxyMode.<br>对于<code>value()</code>的异常，元注解也许会重新定义源码注解中的属性。当仅需要暴露源码注解子集注解属性时，这非常有用。比如，现有自定义<code>@Scope</code>注解定义了session 作用域,但是仍然允许代理模式的自定义。TODO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Scope</span>(<span class="string">"session"</span>)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SessionScope &#123;</div><div class="line"></div><div class="line">    <span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><h4 id="beans-scanning-autodetection">自动探测类和自动注册bean定义</h4><br>Spring能自定探测各代码层的类并在<code>ApplicationContext</code>内注册相应的<code>BeanDefinitions</code>。比如：下面两个类就可以被自动探测<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>blablabal<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</div><div class="line">    <span class="comment">// implementation elided for clarity</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>要想自动探测这些类并注册相应的Spring bean，得在<code>@Configuration</code>注解的类上增加<code>@ComponentScan</code>,其<code>basePackages</code>属性就是上面两个类的所在的父级包路径。(或者，可以使用两个类各自所在的包路径,用 <code>,逗号/;分号/ 空格</code>分隔的)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 为了简介，上面的也会使用注解的<code>value</code>替代<code>basepackage</code>,也就是<code>ComponentScan(&quot;org.example&quot;)</code><br><br>下面是XML格式的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 使用<code>&lt;context:component-scan&gt;</code>将会隐式的启用<code>&lt;context:annotation-config&gt;</code>。当使用<code>&lt;context:component-scan&gt;</code>时，一般不需要<code>&lt;context:annotation-config/&gt;</code>元素<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 扫描类包需要相应的目录在<code>classpath</code>内存在。使用<code>Ant</code>构建JAR包时，确保打包任务不要开启<em>仅打包文件(无需相应的目录)</em>选项。当然了，在某些环境装因为安全策略，classpath目录也许不能访问。比如，基于JDK1.7.0_45或更高版本的JDK的单独的应用(需要在manifests包清单中设置信任类库Trusted-Library；详情参看<a href="http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" target="_blank" rel="external">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>)<br><br>此外，当使用<code>component-scan</code>元素时，<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>都会隐式启用。意味着这两个组件也是自动探测和注入的–所有这些都不需要XML配置。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 通过设置<code>annotation-config</code>属性值为<code>false</code>即禁用<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>的注册。<br><br><h4 id="beans-scanning-filters">使用过滤器自定义扫描</h4><br>默认情况下，使用注解<code>@Component, @Repository, @Service, @Controller</code>以及基于<code>@Component</code>的元注解的类是唯一的被扫描的目标。然而，可以通过自定义过滤器轻易修改、扩展此行为。设置<code>@ComponentScan</code>注解的<em>includeFilters</em> 和<em>excludeFilters</em>参数(或者是XML中，设置<code>component-scan</code>元素的子元素include-filter or exclude-filter)。每个过滤器元素需要设置<code>type</code>和<code>expression</code>属性。下面的列表中描述的过滤器的选项：<br><br><strong>Table 5.5. Filter Types</strong><br><br>Filter Type | Example Expression | Description<br>———– | —————— | ————<br>annotation (default) | <code>org.example.SomeAnnotation</code> | 目标组件上出现类注解<br>assignable | <code>org.example.SomeClass</code> | 指定类或者接口<br>aspectj | <code>org.example..*Service+</code> | AspectJ 类型表达式匹配目标组件<br>regex | <code>org\.example\.Default.*</code> | 正则表达式匹配目标组件的类名<br>custom | <code>org.example.MyTypeFilter</code> | 自定义的<code>org.springframework.core.type .TypeFilter</code>接口实现<br><br><br>下例展示了如何忽略所有<code>@Repository</code>注解的类，而仅使用包含字串”stub”的repositories<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>,</div><div class="line">        includeFilters = <span class="meta">@Filter</span>(type = FilterType.REGEX, pattern = <span class="string">".*Stub.*Repository"</span>),</div><div class="line">        excludeFilters = <span class="meta">@Filter</span>(Repository.class))</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>和下面的XML配置效果相同<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span></span></div><div class="line">                <span class="attr">expression</span>=<span class="string">".*Stub.*Repository"</span>/&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span></span></div><div class="line">                <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Repository"</span>/&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 可以关闭默认的过滤器，通过在注解上设置<code>useDefaultFilters=false</code>，或者在<code>&lt;component-scan/&gt;</code>元素上设置<code>use-default-filters=&quot;false&quot;</code>属性。这将会关闭<code>@Component, @Repository, @Service, or @Controller</code>自动探测类注解。<br><br><h4 id="beans-factorybeans-annotations">在组件内定义Spring bean</h4><br>Spring组件也能为容器定义bean定义元数据。在<code>@Configuration</code>注解的类中使用<code>@Bean</code>注解定义bean元数据(也就是Spring bean)。看样例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Qualifier</span>(<span class="string">"public"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"publicInstance"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Component method implementation omitted</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><em>译注，上面样例是SPring参考手册中给出的源码，待验证@Component类中使用@Bean?不是@Configuration么TODO</em><br><br>这个类是一个Spring组件，有个方法<code>doWork()</code>。然而，它还有一个工厂方法<code>publicInstance()</code>，用于产生一个bean定义。<code>@Bean</code>注解了工厂方法，还设置了其他的bean定义的属性，比如使用<code>@Qulifier</code>设置了其标示符的值。此外还支持一些方法级别注解，<code>@Scope,@Lazy,</code>或者是自定义的qualifier 注解。<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 除了它本身作为组件初始化的角色，<code>@Lazy</code>注解也可以在<code>@Autowired</code>或者<code>@Inject</code>处使用。这种情况下，该注入将会变成延迟注入代理lazy-resolution proxy<br><br>前面讨论过的,<code>@Bean</code>注解的方法支持自动注入域和自动:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Qualifier</span>(<span class="string">"public"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"publicInstance"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// use of a custom qualifier and autowiring of method parameters</span></div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> TestBean <span class="title">protectedInstance</span><span class="params">(</span></span></div><div class="line">            @Qualifier(<span class="string">"public"</span>) TestBean spouse,</div><div class="line">            @<span class="title">Value</span><span class="params">(<span class="string">"#&#123;privateInstance.age&#125;"</span>)</span> String country) &#123;</div><div class="line">        TestBean tb = <span class="keyword">new</span> TestBean(<span class="string">"protectedInstance"</span>, <span class="number">1</span>);</div><div class="line">        tb.setSpouse(spouse);</div><div class="line">        tb.setCountry(country);</div><div class="line">        <span class="keyword">return</span> tb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Scope</span>(BeanDefinition.SCOPE_SINGLETON)</div><div class="line">    <span class="function"><span class="keyword">private</span> TestBean <span class="title">privateInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"privateInstance"</span>, i++);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Scope</span>(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)</div><div class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">requestScopedInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"requestScopedInstance"</span>, <span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>样例中，自动注入的方法参数，类型<code>String</code>,名称为<code>country</code>，将会被设置为另一个实例<code>privateInstance</code>的<code>Age</code>属性。Spring EL表达式语言通过<code>#{&lt;expression&gt;}</code>定义属性值。对于<code>@Value</code>注解，表达式解析器在解析表达式后，会查找bean的名字并设置value。<br><br>在Spring component中处理<code>@Bean</code>和在<code>@Configuration</code>中处理是不一样的。区别在于，在<code>@Component</code>中，不会使用<code>CGLIB</code>增强去拦截方法和属性的调用。在<code>@Configuration</code>注解的类中，<code>@Bean</code>注解的方法创建的bean对象的方法和属性的调用，是使用<code>CGLIB</code>代理。方法的调用不是常规的java语法。作为对比，<code>@Component</code>类中的对于<code>@Bean</code>注解的方法或者属性的调用，是标准的java语法。//TODO<br><br><br><h4 id="beans-scanning-name-generator">命名自动注册组件</h4><br>扫描处理过程其中一步就是自动探测组件,扫描器使用<code>BeanNameGenerator</code>对探测到的组件命名。默认情况下，各代码层注解(<code>@Component,@Repository,@Service,@Controller</code>)所包含的<code>name</code>值，将会作为相应的bean定义的名字。<br><br>如果这些注解没有<code>name</code>值，或者是其他一些被探测到的组件（比如使用自定义过滤器探测到的），默认的bean name生成器生成，以小写类名作为bean名字。比如，下面两个组件被探测到，bean name将会是<code>myMovieLister</code>和<code>movieFinderImpl</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span>(<span class="string">"myMovieLister"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 若你不需要默认的bean命名策略，也可以自己实现命名策略。首先，实现<code>BeanNameGenerator</code>接口，然后确保其包含默认的无参构造函数(即空构造)。然后，在配置扫描器后提供全限定类名:<br>&gt;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, nameGenerator = MyNameGenerator.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span></span></div><div class="line">        <span class="attr">name-generator</span>=<span class="string">"org.example.MyNameGenerator"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><br><br>生成规则应当如下，考虑和注解一起生成name，便于其他组件明确的引用。另一方面，当容器负责组装时，自动生成的名字要能胜任。<br><br><h4 id="beans-scanning-scope-resolver">为自动探测组件提供作用域</h4><br>通常来说，Spring管理的组件，默认的最常见的作用域是单例singleton。然而，有时候需要其他的作用域，Spring2.5提供了一个新的注解<code>@Scope</code>。只需要给他提供一个name,该注解即可设置作用域:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</div><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 若不想使用基于现有注解的方式,而是提供自定义作用域策略,得实现<code>ScopeMetadataResolver</code>接口，该实现得有一个空构造（无参构造）。然后，配置扫描时提供该实现类全限定类名:<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, scopeResolver = MyScopeResolver.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span></span></div><div class="line">            <span class="attr">scope-resolver</span>=<span class="string">"org.example.MyScopeResolver"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br>当使用某个非单例作用域时，为作用域对象生成代理也许非常必要。原因参看<a href="#beans-factory-scopes-other-injection">the section called “Scoped beans as dependencies”</a>。<code>component-scan</code>元素中有一个<code>scope-proxy</code>属性，即可实现此目的。它的值有三个选项：<code>no, interfaces, and targetClass</code>，比如下面的配置会生成标准的JDK动态代理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>, scopedProxy = ScopedProxyMode.INTERFACES)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span></span></div><div class="line">        <span class="attr">scoped-proxy</span>=<span class="string">"interfaces"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><br><br><h4 id="beans-scanning-qualifiers">为注解提供标示符Qualifier</h4><br>有关<code>@Qualifier</code>注解的讨论在<a href="#beans-autowired-annotation-qualifiers">in Section 5.9.3, “Fine-tuning annotation-based autowiring with qualifiers”</a>。那章节中的样例展示了<code>@Qualifier</code>注解和自定义标识符qualifier注解的用法，藉此用来更细粒度的控制自动注入。因为样例都是基于XML 的bean定义,所以标识符都是在XML中的bean定义上，通过设置<code>qualifier</code>或者<code>meta</code>子元素在设置的。当使用classpath扫描、自动探测组件时，得在候选者类上使用类注解来提供标识符qualifier元数据。下面的三个样例展示此技术：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Qualifier</span>(<span class="string">"Action"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Genre</span>(<span class="string">"Action"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Offline</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieCatalog</span> <span class="keyword">implements</span> <span class="title">MovieCatalog</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 如要使用同一个类产生多个bean定义，bean间的区别是qualifier标识符，可以使用XML替代注解定义bean，记住注解元数据是类定义本身的，因此<code>@Qualifier</code>产生的标识符只能属于一个bean定义，而XML的bean定义中的qualifier标识符才是属于bean实例的。<br>&gt; 就大多数的标注替换而言，元数据和类本身是结合在一起的；而使用xml的时候，允许同一类型的beans在qualifieer元数据中提供变量，因为元数据是依据实例而不是类来提供的。<br><br><h3 id="beans-standard-annotations">使用JSR-330标准注解</h3><br>Spring3.0开始，Spring提供了对JSR-330标准注解（依赖注入）的支持。这些注解以Spring注解相同的方式被扫描。你只需要在classpath中引入相关jar包<br><br><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意"><br>&gt; 若使用<code>Maven</code>,<code>javax.inject</code> artifact三围坐标在标准maven仓库中都是可用的(<a href="http://repo1.maven.org/maven2/javax/inject/javax.inject/1/)，在pom.xml中增加dependency" target="_blank" rel="external">http://repo1.maven.org/maven2/javax/inject/javax.inject/1/)，在pom.xml中增加dependency</a><br>&gt;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><br><br><h4 id="beans-inject-named">使用@Inject @Name依赖注入</h4><br>替代<code>@Autowired</code>，<code>@javax.inject.Inject</code>这样用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.inject.Inject;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>和<code>@Autowired</code>一样，<code>@Inject</code>可用于类注解、域注解、方法注解、构造参数注解。如果需要注入指定qualifier标识符的bean，应该使用<code>@Named</code>注解，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.inject.Inject;</div><div class="line"><span class="keyword">import</span> javax.inject.Named;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(@Named(<span class="string">"main"</span>)</span> MovieFinder movieFinder) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><h4 id="beans-named">@Named:相当于@Component</h4><br>使用<code>@javax.inject.Named</code>替代<code>@Component</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.inject.Inject;</div><div class="line"><span class="keyword">import</span> javax.inject.Named;</div><div class="line"></div><div class="line"><span class="meta">@Named</span>(<span class="string">"movieListener"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><code>@Component</code>通常不指定组件名字。<code>@Named</code>也能这么用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.inject.Inject;</div><div class="line"><span class="keyword">import</span> javax.inject.Named;</div><div class="line"></div><div class="line"><span class="meta">@Named</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>使用<code>@Named</code>，也可以Spring注解一样的使用component-scanning组件扫描<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><h4 id="beans-standard-annotations-limitations">标准注解的限制</h4><br>使用标准注解时，要知道下列重要功能不可用，这非常重要:<br><br><strong>Table 5.6. Spring annotations vs. standard annotations</strong><br><br>Spring | javax.inject.<em> | javax.inject restrictions / comments<br>——- | ————– | ———————————–<br>@Autowired | @Inject | @Inject 没有<code>required</code>属性<br>@Component | @Named | -<br>@Scope(“singleton”) |@Singleton | JSR-330默认的作用域类似于Spring的prototype原型作用域。为了保持Spring的一致性，在Spring容器中的JSR-330的bean声明，默认是singleton单例。除了singleton，若要设置作用域，得使用Spring的<code>@Scope</code>注解。<code>javax.inject</code>也提供了一个<code>@Scope</code>注解。然而，这个注解仅仅是为了让你创建自定义注解用的</em>译注,也就是元注解的源码注解?*。<br>@Qualifier | @Named | -<br>@Value | - | 无等价注解<br>@Required | - | 无等价注解<br>@Lazy | - | 无等价注解<br><br><h3 id="beans-java">基于Java的配置元数据</h3>

<p></p><h4 id="beans-java-basic-concepts">基本概念@Bean和@Configuration</h4><br>Spring新功能Java-cofiguration支持<code>@Configuration</code>类注解和<code>@Bean</code>方法注解<p></p>
<p><code>@Bean</code>注解用于表明一个方法将会实例化、配置、初始化一个新对象，该对象由Spring IoC容器管理。大家都熟悉Spring的<code>&lt;beans/&gt;</code>XML配置，<code>@Bean</code>注解方法和它一样。可以在任何Spring <code>@Component</code>中使用<code>@Bean</code>注解方法，当然了，大多数情况下,<code>@Bean</code>是配合<code>@Configuration</code>使用的。</p>
<p><code>@Configuration</code>注解的类表明该类的主要目的是作为bean定义的源。此外,<code>@Configuration</code>类允许依赖本类中使用<code>@Bean</code>定义的bean。看样例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的<code>AppConfig</code>类等价于下面的XML<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"com.acme.services.MyServiceImpl"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>@Bean and @Configuration</code>注解下面会深入的探讨。首先，以Java-based配置方式用各种方式创建Spring容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">**Full @Configuration vs lite @Beans mode?**</div><div class="line">**完全@Configuration模式 VS 简易@Beans模式**</div><div class="line">在非@Configuration 注解的类内使用@Bean的话，Spring容器使用简易模式处理@Bean。</div><div class="line">比如，在`@Component`注解的类内，甚至是`plain old class`内使用`@Bean`都将使用简易模式。</div><div class="line"></div><div class="line">和完全`@Configuration`模式不同，简易`@Bean·模式不能容易的使用类内依赖。</div><div class="line">一般来说，在简易模式中,`@Bean`方法不应该引用另一个在方法上注解的`@Bean`</div><div class="line"></div><div class="line">为了确保开启完全模式，只推荐在`@Configuration`注解的类中使用`@Bean`的手法。</div></pre></td></tr></table></figure>
<p></p><h5 id="beans-java-instantiating-container">使用AnnotationConfigApplicationContext实例化Spring IoC容器</h5><br>Spring的<code>AnnotationConfigApplicationContext</code>部分，是Spring3.0中新增的。这是一个强大的(<em>译注原文中是多才多艺的versatile</em>)<code>ApplicationContext</code>实现,不仅能解析<code>@Configuration</code>注解类，也能解析<code>@Componnet</code>注解的类和使用<code>JSR-330</code>注解的类。<p></p>
<p>使用<code>@Configuration</code>注解的类作为配置元数据的时候，<code>@Configuration</code>类本身也会注册为一个bean定义，类内所有的<code>@Bean</code>注解的方法也会注册为bean定义。</p>
<p>使用<code>@Component</code>和JSR-330注解类作为配置元数据时，他们本身被注册为bean定义,并假设DI(依赖注入)元数据，像类内使用的<code>@Autowired</code>或者<code>@Inject</code>都是必须的。</p>
<p></p><h5 id="beans-java-instantiating-container-contstructor">简单结构</h5><br>Spring以XML作为配置元数据实例化一个<code>ClassPathXmlApplicationContext</code>,以<code>@Configuration</code>类作为配置元数据时，Spring以差不多的方式，实例化一个<code>AnnotationConfigApplicationContext</code>。因此，Spring 容器可以实现零XML配置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</div><div class="line">    MyService myService = ctx.getBean(MyService.class);</div><div class="line">    myService.doStuff();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>上述代码中，<code>AnnotationConfigApplicationContext</code>不是仅能与<code>@Configuration</code>注解类配合使用。任何<code>@Component</code>或者JSR-330注解的类都可以作为其构造函数的参数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);</div><div class="line">    MyService myService = ctx.getBean(MyService.class);</div><div class="line">    myService.doStuff();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中，假设<code>MyServiceImpl,Dependency1 ,Dependency2</code>使用了Spring依赖注入注解，比如<code>@Autowired</code>。</p>
<p></p><h5 id="beans-java-instantiating-container-register">使用 register(Class&lt;?&gt;…)编程式构造Spring容器</h5><br><code>AnnotationConfigApplicationContext</code>也可以通过无参构造函数实例化，然后调用<code>registor()</code>方法配置。此法应用于编程式构造<code>AnnotationConfigApplicationContext</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</div><div class="line">    ctx.register(AppConfig.class, OtherConfig.class);</div><div class="line">    ctx.register(AdditionalConfig.class);</div><div class="line">    ctx.refresh();</div><div class="line">    MyService myService = ctx.getBean(MyService.class);</div><div class="line">    myService.doStuff();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h5 id="beans-java-instantiating-container-scan">开启组件扫描</h5><br>要开启组件扫描，只需要像这样注解<code>@Configuration</code>类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.acme"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>Spring老炮儿可能知道它和下面的xml是等同效果的，下面的xml使用了Spring <code>context</code>命名空间</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.acme"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</blockquote>
<p>上面的栗子中，会扫描<code>com.acme package</code>包，检索出所有<code>@Component-annotated</code>类，Spring容器将会注册这些类为Spring bean定义。<code>AnnotationConfigApplicationContext</code>暴露的<code>scan(String...)</code>方法也允许扫描类，完成相同的功能:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</div><div class="line">    ctx.scan(<span class="string">"com.acme"</span>);</div><div class="line">    ctx.refresh();</div><div class="line">    MyService myService = ctx.getBean(MyService.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>记住，<code>@Configuration</code>注解是<code>@Component</code>注解的元注解，所以它是<code>component-scanning</code>的候选者!上面栗子中，假设<code>AppConfig</code>在<code>com.acme package</code>包内生命的（或者是该包路径下的）,在<code>scan()</code>期间，它也会被扫描，在所有<code>@Bean</code>方法处理并且注册为Spring bean定义之后，它也会注册到容器中，然后在执行<code>refresh()</code>方法。 </p>
</blockquote>
<p><em>译注，E文看的不大明白，就翻看了源码</em></p>
<p>// 先看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">org.springframework.context.annotation.<span class="function">AnnotationConfigApplicationContext</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> &#123;</div><div class="line">	scan(basePackages);</div><div class="line">	refresh();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//接下来看扫描处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">org.springframework.context.annotation.<span class="function">ClassPathBeanDefinitionScanner</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> &#123;</div><div class="line">	<span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</div><div class="line">	<span class="comment">//扫描</span></div><div class="line">	doScan(basePackages);</div><div class="line"></div><div class="line">	<span class="comment">//注册config</span></div><div class="line">	<span class="comment">// Register annotation config processors, if necessary.</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</div><div class="line">		AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h5 id="beans-java-instantiating-container-web">使用AnnotationConfigWebApplicationContext支持WEB应用</h5><br><code>WebApplicationContext</code>接口一个实现<code>AnnotationConfigWebApplicationContext</code>，是<code>AnnotationConfigApplicationContext</code>的一个变体。在配置<code>ContextLoaderListener</code>、 Spring MVC <code>DispatcherServlet</code>等等时，使用此实现类。下面这段<code>web.xml</code>片段，是典型Spring MVC的Web应用的配置。注意<code>contextClass</code>类的context-param和init-param。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext</span></div><div class="line">        instead of the default XmlWebApplicationContext --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></div><div class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</div><div class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited</span></div><div class="line">        fully-qualified @Configuration classes. Fully-qualified packages may also be</div><div class="line">        specified for component-scanning --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext</span></div><div class="line">            instead of the default XmlWebApplicationContext --&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></div><div class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</div><div class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited</span></div><div class="line">            and fully-qualified @Configuration classes --&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure><p></p>
<p></p><h4 id="beans-java-bean-annotation">使用@Bean注解</h4><br><code>@Bean</code>是方法注解，和XML中的<code>&lt;bean/&gt;</code>元素十分相似。该注解支持<code>&lt;bean/&gt;</code>的一些属性，比如<a href="#beans-factory-lifecycle-initializingbean">init-method</a>, <a href="#beans-factory-lifecycle-disposablebean">destroy-method</a>, <a href="#beans-factory-autowire">autowiring</a>和<code>name</code><p></p>
<p></p><h5 id="beans-java-declaring-a-bean">声明bean</h5><br>要声明bean非常简单，只需要在方法上使用<code>@Bean</code>注解。使用此方法，将会在<code>ApplicationContext</code>内注册一个bean，bean的类型是方法的返回值类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>上面的配置和下面的XML配置等价:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">class</span>=<span class="string">"com.acme.TransferServiceImpl"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面两种配置，都会在<code>ApplicationContext</code>内产生一个bean定义，名称为<code>transferService</code>，该Spring bean绑定到一个类型为<code>TransferServiceImpl</code>的实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transferService -&gt; com.acme.TransferServiceImpl</div></pre></td></tr></table></figure></p>
<p></p><h5 id="beans-java-lifecycle-callbacks">接收生命周期回调</h5><br>使用<code>@Bean</code>注解的bean定义，都支持常规生命周期回调，能使用JSR-250中的<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，<a href="#beans-postconstruct-and-predestroy-annotations">JSR-250详情请参看这里</a><p></p>
<p>常规Spring<a href="#beans-factory-nature">生命周期</a>回调也完全支持，若bean实现了<code>InitializingBean, DisposableBean, or Lifecycle</code>，他们各自的方法都会被容器调用。</p>
<p>标准的那一套<code>*Aware</code>接口，像<code>BeanFactoryAware, BeanNameAware, MessageSourceAware, ApplicationContextAware</code>等等，也都完全支持。</p>
<p><code>@Bean</code>注解支持初始化回调和销毁回调，很像Spring XML中<code>&lt;bean/&gt;</code>元素的<code>init-method</code>和<code>destroy-method</code>属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// initialization logic</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// destruction logic</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span>(destroyMethod = <span class="string">"cleanup"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>默认情况下，使用java config定义的bean中<code>close</code>方法或者<code>shutdown</code>方法，会作为销毁回调自动调用。若bean中有<code>close</code>,<code>shutdown</code>方法，又不是销毁回调，通过设置<code>@Bean(destroyMethod=&quot;&quot;)</code>，即可关闭该默认的自动匹配销毁回调模式。<br>You may want to do that by default for a resource that you acquire via JNDI as its lifecycle is managed outside the application. In particular, make sure to always do it for a DataSource as it is known to be problematic.<br>对于某些由JNDI获取的资源，也许就要关闭自动匹配销毁回调行为了,因为该资源的生命周期并不由应用管理。尤其是，使用<code>DataSource</code>时一定要关闭它，不关会有问题。TODO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> NamingException </span>&#123;</div><div class="line">    <span class="keyword">return</span> (DataSource) jndiTemplate.lookup(<span class="string">"MyDS"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>Of course, in the case of Foo above, it would be equally as valid to call the init() method directly during construction:<br>当然了，上面<code>Foo</code>的例子中，也可以在构造函数中调用<code>init()</code>方法，和上面栗子中的效果相同<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Foo foo = <span class="keyword">new</span> Foo();</div><div class="line">        foo.init();</div><div class="line">        <span class="keyword">return</span> foo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>如果是直接使用java，对于对象，你想怎么搞就怎么搞，并不总需要依赖容器生命周期</p>
</blockquote>
<p></p><h5 id="beans-java-specifying-bean-scope">指定bean作用域scope</h5><p></p>
<p></p><h6 id="beans-java-available-scopes">使用@Scope注解</h6><br>通过<code>@Bean</code>注解定义的bean也许需要指定作用域。可以使用<a href="#beans-factory-scopes">bean作用域</a>章节中的任意标准作用域。<br>默认的作用域是<code>singleton</code>单例,但是可以使用<code>@Scope</code>注解覆盖此设置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Encryptor <span class="title">encryptor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h6 id="#beans-java-scoped-proxy">@Scope 和作用域代理</h6><br>Spring提供了非常方便的方式，通过<a href="#beans-factory-scopes-other-injection">scoped proxies</a>作用域代理完成作用域bean依赖。若使用XML配置，最简单的方式是使用<code>&lt;aop:scoped-proxy/&gt;</code>元素创建一个代理。若是在Java代码中配置bean,有一种等价的做法，使用<code>@Scope</code>注解并配置其<code>proxyMOde</code>属性.默认配置是没有代理<code>ScopedProxyMode.NO</code>,但是你可以设置<code>ScopedProxyMode.TARGET_CLASS</code>或者<code>ScopedProxyMode.INTERFACES</code>。<br>如果将XML格式的作用域代理示例转换成Java中使用<code>@Bean</code>，差不多是这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@Scope</span>(value = <span class="string">"session"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</div><div class="line"><span class="function"><span class="keyword">public</span> UserPreferences <span class="title">userPreferences</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> Service <span class="title">userService</span><span class="params">()</span> </span>&#123;</div><div class="line">    UserService service = <span class="keyword">new</span> SimpleUserService();</div><div class="line">    <span class="comment">// a reference to the proxied userPreferences bean</span></div><div class="line">    service.setUserPreferences(userPreferences());</div><div class="line">    <span class="keyword">return</span> service;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h5 id="beans-java-customizing-bean-naming">自定义bean名字</h5><br>默认情况下，配置类中，使用<code>@Bean</code>的方法名作为返回bean的名字。通过配置可以覆盖此设置，使用<code>name</code>属性 即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span>(name = <span class="string">"myFoo"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h5 id="beans-java-bean-aliasing">bean别名</h5><br>在之前讨论过的bean别名<a href="#beans-beanname">Section 5.3.1, “Naming beans”</a>,有时候需要给一个bean指定多个name。<code>@Bean</code>注解的<code>name</code>属性就是干这个用，该属性接收一个字串数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span>(name = &#123; <span class="string">"dataSource"</span>, <span class="string">"subsystemA-dataSource"</span>, <span class="string">"subsystemB-dataSource"</span> &#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h5 id="#beans-java-bean-description">bean描述</h5><br>有时候，给bean提供一个更具细节的描述，是非常有好处的。用于监视目的(通过JMX)的时候，非常有用。<br>给一个<code>@Bean</code>增加描述，可使用<code>@Description</code>注解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Description</span>(<span class="string">"Provides a basic example of a bean"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h4 id="beans-java-configuration-annotation">使用@Configuration注解</h4><br><code>@Configuration</code>是类注解，表名该类将作为bean定义的配置元数据。<code>@Configuration</code>类内只用<code>@Bean</code>注解方法。在<code>@Configuration</code>类上调用<code>@Bean</code>方法，也能用于内部bean依赖。详情参看<a href="#beans-java-basic-concepts">Section 5.12.1, “Basic concepts: @Bean and @Configuration”</a><p></p>
<p></p><h5 id="beans-java-injecting-dependencies">注入内部bean依赖</h5><br>当<code>@Beans</code>依赖其他bean,依赖的表达式非常简单，仅需要调用被依赖的bean的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>在上面的样例中，foo bean接收一个参数，该参数是通过构造返回的实例<code>bar</code>,以此完成注入。</p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>声明内部bean依赖的做法，仅在<code>@Configuration</code>类内的<code>@Bean</code>注解的方法上有效。<code>@Component</code>类不能使用此做法。</p>
</blockquote>
<p></p><h5 id="beans-java-method-injection">查找方法注入</h5><br>早先提到过,方法注入<a href="#beans-factory-method-injection">lookup method injection</a> 是一个高级功能，很少会用到。但是，在一个单例bean依赖原型作用域bean的场景中，就非常有用了。Java中，提供了很友好的api实现此模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</div><div class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></div><div class="line">        Command command = createCommand();</div><div class="line"></div><div class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></div><div class="line">        command.setState(commandState);</div><div class="line">    <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>使用基于java的元注解配置，可以创建一个<code>CommandManager</code>的子类，子类重写父类抽象 方法，该方法返回一个<code>new</code>创建的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> AsyncCommand <span class="title">asyncCommand</span><span class="params">()</span> </span>&#123;</div><div class="line">    AsyncCommand command = <span class="keyword">new</span> AsyncCommand();</div><div class="line">    <span class="comment">// inject dependencies here as required</span></div><div class="line">    <span class="keyword">return</span> command;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> CommandManager <span class="title">commandManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// return new anonymous implementation of CommandManager with command() overridden</span></div><div class="line">    <span class="comment">// to return a new prototype Command object</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommandManager() &#123;</div><div class="line">        <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> asyncCommand();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h5 id="beans-java-further-information-java-config">基于java配置的内部工作原理</h5><br>下面示例中，展示了<code>@Bean</code>注解的方法被调用了2次:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">clientService1</span><span class="params">()</span> </span>&#123;</div><div class="line">        ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();</div><div class="line">        clientService.setClientDao(clientDao());</div><div class="line">        <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">clientService2</span><span class="params">()</span> </span>&#123;</div><div class="line">        ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();</div><div class="line">        clientService.setClientDao(clientDao());</div><div class="line">        <span class="keyword">return</span> clientService;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ClientDao <span class="title">clientDao</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientDaoImpl();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p><code>clientDao()</code>被<code>clientService1()</code>调用了一次，被<code>clientService2()</code>调用了一次。因为这个方法会创建一个<code>ClientDaoImpl</code>类的实例并返回，也许你以为会有2个实例(分别返回给各个service)。这个定义会有问题：在Spring中，实例化bean默认的作用域是单例。这就是它的神奇之处:所有的<code>@Configuration</code>类在启动时，都是通过<code>CGLIB</code>创建一个子类。在调用父类的方法并创建一个新的实例之前，子类中的方法首先检查是否缓存过。注意，自Spring3.2其，不在需要将<code>CGLIB</code>加入到classpath中，因为<code>CGLIB</code>包已经被打包进<code>org.springframework</code>下，在Spring核心包中已经内置了。</p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>该行为也许有些不同，这得根据具体的bean的作用域。这里讨论的是singleton单例作用域。</p>
</blockquote>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>因为一些限制，导致<code>CLGIB</code>会在启动时动态增加功能</p>
<ul>
<li><strong>Configuration</strong>配置类不能是<code>final</code></li>
<li>他们应该有空构造</li>
</ul>
</blockquote>
<p></p><h4 id="beans-java-composing-configuration-classes">组装java配置元数据</h4><p></p>
<p></p><h5 id="beans-java-using-import">使用@Import注解</h5><br>在Spring XML配置中使用<code>&lt;import/&gt;</code>元素，意在模块化配置，<code>@Import</code>注解也允许从其他配置类中加载<code>@Bean</code>定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</div><div class="line"></div><div class="line">     <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(ConfigA.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>现在，实例化context时，不需要同时指定<code>ConfigA.class</code>和<code>ConfigB.class</code>，而是仅需要提供<code>ConfigB</code>即可:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);</div><div class="line"></div><div class="line">    <span class="comment">// now both beans A and B will be available...</span></div><div class="line">    A a = ctx.getBean(A.class);</div><div class="line">    B b = ctx.getBean(B.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方式简化了容器实例化，只需要一个类去处理，而不是需要开发者在构造期间记着大量的<code>@Configuration</code>。</p>
<p></p><h5 id="beans-java-injecting-imported-beans">在导入的bean上注入依赖</h5><br>上面的栗子可以运行，但是太简单了。在大部分实际场景中，bean都会跨配置依赖。若使用XML，这不是问题，因为不包含编译器，开发者简单的声明<code>ref=somBean</code>并相信Spring在容器实例化期间会正常运行。但是，使用<code>@Configuration</code>类,配置模型替换为java编译器，为了引用另一个bean，Java编译器会校验该引用必须是有效的合法Java语法。<p></p>
<p>非常幸运，解决这个这个问题非常简单。还记得不，<code>@Configuration</code>类在容器中本身就是一个bean，这意味着他们能使用高级<code>@Autowired</code>注入元数据，就像其他bean一样。</p>
<p>来一个更加真实的场景，使用了多个<code>@Configuration</code>类，每个配置都依赖其他配置中是bean声明:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> DataSource dataSource;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// return new DataSource</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</div><div class="line">    <span class="comment">// everything wires up across configuration classes...</span></div><div class="line">    TransferService transferService = ctx.getBean(TransferService.class);</div><div class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">"A123"</span>, <span class="string">"C456"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的场景中，<code>@Autowired</code>可以很好的工作，使设计更具模块化，但是自动注入的是哪个bean依然有些模糊不清。举个栗子，开发者正在查找<code>ServiceConfig</code>,你怎么知道一定会有<code>@Autowired</code>注解的<code>AccountRepository</code>类型bean声明?代码中并未明确指出，还好，Spring Tool Suite提供了可视化工具，用来展示bean之间是如何装配的，也许这就是你需要的。另外，你的Java IDE也很容易找到所有的有关<code>AccountReository</code>类型的声明和调用，并很快的定位返回该类型的<code>@Bean</code>方法。 </p>
<p>万一需求不允许这种模糊的装配，并且你要在IDE内从<code>Configuration</code>类直接定位到依赖类bean，考虑使用硬编码，即由依赖类本身定位:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RepositoryConfig repositoryConfig;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// navigate 'through' the config class to the @Bean method!</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上栗中，<code>AccountRepository</code>已经定义好了，它非常明确。然而，<code>ServiceConfig</code>和<code>RepositoryConfig</code>已经紧耦合在一起了；这是一个折中的方案。可以通过面向接口或者抽象类解耦。看这段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RepositoryConfig repositoryConfig;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RepositoryConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function">AccountRepository <span class="title">accountRepository</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRepositoryConfig</span> <span class="keyword">implements</span> <span class="title">RepositoryConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(...);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(&#123;ServiceConfig.class, DefaultRepositoryConfig.class&#125;) <span class="comment">// import the concrete config!</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// return DataSource</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</div><div class="line">    TransferService transferService = ctx.getBean(TransferService.class);</div><div class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">"A123"</span>, <span class="string">"C456"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在<code>ServiceConfig</code>已经和具体实现类<code>DefaultRepositoryConfig</code>解耦了，IDE内置的工具此时也很有用：它能很容器的获取<code>RepositoryConfig</code>实现的集成层级。与常规的面向接口的代码定位相比，用这种方式，导航<code>@Configuration</code>类和它们的依赖将毫无困难。</p>
<p></p><h5 id="beans-java-conditional">过滤@Configuration或者@Bean</h5><br>在某些需求下，开启或者关闭一个<code>@Configuration</code>类，甚至是针对个别<code>@Bean</code>方法开启或者关闭，通常很有用。Spring环境中，通常使用<code>@Profile</code>注解，在某种条件下来激活bean,来实现此效果(<a href="#beans-definition-profiles">see Section 5.13.1, “Bean definition profiles”</a> for details)。<p></p>
<p><code>@Profile</code>注解实现了更具弹性<code>@Conditional</code>注解。<code>@Conditional</code>注解表名，指定的<code>org.springframework.context.annotation.Condition</code>实现必须在<code>@Bean</code>注册之前运行。</p>
<p><code>Condition</code>接口的实现只需要实现一个简单的方法, <code>matches(...)</code>，该方法返回<code>true</code>或者<code>false</code>。举个栗子，下面是<code>Condition</code>的实现，用于@Profile<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (context.getEnvironment() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Read the @Profile annotation attributes</span></div><div class="line">        MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</div><div class="line">        <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (Object value : attrs.get(<span class="string">"value"</span>)) &#123;</div><div class="line">                <span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(((String[]) value))) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>See the @Conditional <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Conditional.html" target="_blank" rel="external">javadocs</a> for more detail.</p>
<p></p><h5 id="beans-java-combining">混合java和xml配置</h5><br>Spring的<code>@Configuration</code>类并非是为了完全替换Spring XML。有些工具，比如XML命名空间就是一种理想的配置方式。如果XML更方便或是必须的，你就得选择:或者选择基于XML的配置方式实例化容器，比如使用<code>ClassPathXmlApplicationContext</code>，或者选择基于Java配置风格使用<code>AnnotationConfigApplcationContext</code>加上<code>@ImportResource</code>注解导入必须的XML。<p></p>
<p></p><h6 id="beans-java-combining-xml-centric">基于XML混合使用@Configuration类</h6><br>ad-hoc风格也许是稍好的以XML引导Spring容器，并引入<code>@Configuration</code>类。举个栗子，已存在大量的使用了SPringXML的代码，有需求需要使用<code>@Configuration</code>类，这些配置类需要引入到现存的XML文件中，此种做法也许更容易。接下来看看此场景。<p></p>
<p><code>@Configuration</code>类本身在容器内就是一个bean。下面的样例中，创建了一个<code>@Configuration</code>类，类名是<code>AppConfig</code>，引入一个配置文件<code>system-test-config.xml</code>。由于<code>&lt;context:annotation-config/&gt;</code>打开，容器会识别<code>@Configuration</code>注解，并处理<code>AppConfig</code>类内声明的<code>@Bean</code>注解的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> DataSource dataSource;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferService(accountRepository());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">system-test-config.xml</div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.acme.AppConfig"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>jdbc.properties<br>jdbc.url=jdbc:hsqldb:hsql://localhost/xdb<br>jdbc.username=sa<br>jdbc.password=</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/com/acme/system-test-config.xml"</span>);</div><div class="line">    TransferService transferService = ctx.getBean(TransferService.class);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>在<code>system.test-config.xml</code>中，<code>AppConfig&lt;bean/&gt;</code>没有<code>id</code>属性，因为没有其他bean引用，也不会根据name从容器获取，所以id不是必须指定的，同样，<code>DataSource</code>bean，它只会根据类型自动装配，所以明确的id也不是必须的。</p>
</blockquote>
<p>因为<code>@Configuration</code>是<code>@Component</code>的元数据注解,<code>@Configuration</code>注解类也会自动作为扫描组件的候选者。还是上面的场景，我们能重新定义<code>system-test-config.xml</code>，使之能启用高级扫描组件。注意，在此场景中，我们不需要明确的声明<code>&lt;context:annotation-config/&gt;</code>，因为<code>&lt;context:component-scan/&gt;</code>会开启所有相同的功能。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">system-test-config.xml</div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.acme"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p></p><h6 id="beans-java-combining-java-centric">基于@Configuration混合使用xml配置</h6><br>在应用中，<code>@Configuration</code>类是主要的容器配置机制，但是仍然可能会需要一些XML。在这些场景中，使用<code>@ImportResource</code>，即可引用XML配置。这样配置可是实现此效果，基于java配置，尽可能少的使用XML。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:/com/acme/properties-config.xml"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String url;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String username;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String password;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url, username, password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">properties-config.xml</div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/com/acme/jdbc.properties"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>jdbc.properties<br>jdbc.url=jdbc:hsqldb:hsql://localhost/xdb<br>jdbc.username=sa<br>jdbc.password=</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</div><div class="line">    TransferService transferService = ctx.getBean(TransferService.class);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p></p><h3 id="beans-environment">环境抽象</h3><br><code>Environment</code>环境在容器中是一个抽象的集合，是指应用环境的2个方面: <a href="#beans-definition-profiles">profiles</a> 和 <a href="#beans-property-source-abstraction">properties</a>.<p></p>
<p><code>profile</code>配置是一个被命名的，bean定义的逻辑组，这些bean只有在给定的profile配置激活时才会注册到容器。不管是XML还是注解，Beans都有可能指派给profile配置。<code>Environment</code>环境对象的作用，对于profiles配置来说，它能决定当前激活的是哪个profile配置，和哪个profile是默认。</p>
<p>在所有的应用中，Properties属性扮演一个非常重要的角色,可能来源于一下源码变量:properties文件，JVM properties,system环境变量，JNDI,servlet servlet context parameters上下文参数,专门的Properties对象，Maps等等。<code>Environment</code>对象的作用，对于properties来说，是提供给用户方便的服务接口，方便撰写配置、方便解析配置。</p>
<p></p><h4 id="beans-definition-profiles">bean定义profiles</h4><br>bean定义profiles是核心容器内的一种机制，该机制能在不同环境中注册不同的bean。环境的意思是，为不同的用户做不同的事儿，该功能在很多场景中都非常有用，包括：<p></p>
<ul>
<li>开发期使用内存数据源，在QA或者产品上则使用来自JNDI的相同的数据源</li>
<li>开发期使用监控组件，当部署以后则关闭监控组件，是应用更高效</li>
<li>为用户各自注册自定义bean实现</li>
</ul>
<p>考虑一个实际应用中的场景，现在需要一个<code>DataSource</code>。开测试环境中，这样配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</div><div class="line">        .setType(EmbeddedDatabaseType.HSQL)</div><div class="line">        .addScript(<span class="string">"my-schema.sql"</span>)</div><div class="line">        .addScript(<span class="string">"my-test-data.sql"</span>)</div><div class="line">        .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在想一想，如何将应用部署到QA或者生产环境，假设生产环境中使用的JNDI。我们的dataSource bean看起来像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Context ctx = <span class="keyword">new</span> InitialContext();</div><div class="line">    <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题是，在当前环境中如何切换这两个配置。随着时间推移，Spring用户设计了很多种方式完成此切换，通常使用系统环境变量和XML<code>&lt;import/&gt;</code>绑定，<code>&lt;import/&gt;</code>元素包含一个<code>${placeholder}</code>符号，使用环境变量来设置<code>${placeholder}</code>符号所代表的值，从而达到切换正确配置文件的目的。bean定义profiles是核心容器功能，提供针对子问题的解决方案。</p>
<p>概括一下上面的场景：环境决定bean定义，最后发现，我们需要在某些上下文环境中使用某些bean，在其他环境中则不用这些bean。你也许会说，你需要在场景A中注册一组bean定义，在场景B中注册另外一组。先看看我们如何修改配置来完成此需求。</p>
<p></p><h5 id="beans-definition-profiles-java">@Profile</h5><br><code>@Profile</code>注解的作用，是在一个或者多个指定profiles激活的情况下，注册某个组件。使用上面的样例，重写dataSource配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandaloneDataConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</div><div class="line">            .setType(EmbeddedDatabaseType.HSQL)</div><div class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</div><div class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>)</div><div class="line">            .build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JndiDataConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</div><div class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@Profile</code>可以用于元数据注解，为了组合自定义代码层注解。下面的的样例中定义了<code>@Production</code>自定义注解，该注解用于替换<code>@Profile(&quot;production&quot;)</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Production &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>@Profile</code>也能注解方法，用于配置一个配置类中的指定bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">devDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</div><div class="line">            .setType(EmbeddedDatabaseType.HSQL)</div><div class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</div><div class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>)</div><div class="line">            .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Profile</span>(<span class="string">"production"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">productionDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</div><div class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">"java:comp/env/jdbc/datasource"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>如果一个<code>@Configuration</code>类注解了<code>@Profile</code>，类中所有<code>@Bean</code>和<code>@Import</code>注解相关的类都将被忽略，除非该profile被激活。如果<code>@Component</code>或者<code>@Configuration</code>注解了<code>@Profile({&quot;p1&quot;,&quot;p2&quot;})</code>，该类将不会注册/处理，除非profiles’p1 and/or ‘p2’被激活。如果给定的profile，使用了NOT操作(!)前缀，若当前profile未被激活则注解元素将会注册，等等。对于<code>@Profile({&quot;p1&quot;, &quot;!p2&quot;})</code>，在profile ‘p1’被激活或者’p2’未激活时，发生注册。</p>
</blockquote>
<p></p><h4 id="beans-definition-profiles-xml">XML bean定义profile</h4><br>XML中的<code>beans</code>元素有一个<code>profile</code>属性。上面的栗子重写到2个XML中<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"dev"</span></span></div><div class="line">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><p></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span></span></div><div class="line">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>也可以不用分开2个文件，在同一个XML中配置2个<code>&lt;bean/&gt;</code>，<code>&lt;bean/&gt;</code>元素也有<code>profile</code>属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></div><div class="line">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- other bean definitions --&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"dev"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>TODO。The <code>spring-bean.xsd</code> has been constrained to allow such elements only as the last ones in the file.它是配置更加灵活，而又不造成XML文件混乱。</p>
<p></p><h5 id="beans-definition-profiles-enable">开启profile</h5><br>要修改配置，我们仍然需要指定要激活哪个文件。如果现在运行上面的样例应用，它会抛异常<code>NoSuchBeanDefinitionException</code>,因为容器找不到<code>dataSource</code>bean。<p></p>
<p>有多种方式激活配置，但是最直接的方式是编程式的方式使用<code>ApplicationContext API</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</div><div class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"dev"</span>);</div><div class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</div><div class="line">ctx.refresh();</div></pre></td></tr></table></figure></p>
<p>此外，还可以使用<code>spring.profiles.active</code>激活配置，该属性可以配置在系统环境变量、JVM系统属性、<code>web.xml</code>中JNDI中的servlet context上下文参数(<a href="#beans-property-source-abstraction">see Section 5.13.3, “PropertySource Abstraction”</a>)</p>
<p>注意配置文件不是单选；可能会同时激活多个配置文件，编程式的使用方法<code>setActiveProfiles()</code>，该方法接收<code>String...</code>参数,也就是多个配置文件名:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"profile1"</span>, <span class="string">"profile2"</span>);</div></pre></td></tr></table></figure></p>
<p>声明式的使用<code>spring.profiles.active</code>，值可以为逗号分隔的配置文件名列表,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Dspring.profiles.active=&quot;profile1,profile2&quot;</div></pre></td></tr></table></figure></p>
<p></p><h5 id="beans-definition-profiles-default">默认profile配置</h5><br>默认的profile配置就是默认开启的profile配置:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Profile</span>(<span class="string">"default"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</div><div class="line">            .setType(EmbeddedDatabaseType.HSQL)</div><div class="line">            .addScript(<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>)</div><div class="line">            .build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>如果profile激活了，上面的<code>dataSource</code>数据源就被创建了；这就像是提供了默认的bean定义，如果有任何profile配置被激活，默认的的就不在应用了。</p>
<p>默认profile配置文件可以更改，通过环境变量的<code>setDefaultProfiles</code>方法，或者是声明的<code>spring.profiles.default</code>属性值</p>
<p></p><h4 id="beans-property-source-abstraction">PropertySource Abstraction</h4><br>Spring的环境抽象提供了用于检索一系列的property sources属性配置文件。详细阐述，参看:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();</div><div class="line">Environment env = ctx.getEnvironment();</div><div class="line"><span class="keyword">boolean</span> containsFoo = env.containsProperty(<span class="string">"foo"</span>);</div><div class="line">System.out.println(<span class="string">"Does my environment contain the ''foo'' property? "</span> + containsFoo);</div></pre></td></tr></table></figure><p></p>
<p>在上面的片段中，通过较高层次方式检索SPring是否在当前环境中定义了<code>foo</code>property属性。为了检索该属性，环境对象在一组<code>PropertySource</code>对象中执行检索。<code>PropertySource</code>是key-value键值对配置文件的抽象，Spring的<code>StandardEnvironment</code>配置了2个<code>PropertySource</code>对象-其一是JVM系统properties(System.getProperties())，另一个是一组系统环境变量(System.getenv())。</p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>这些默认的property源代表<code>StandardEnvironment</code>，在独立的应用中使用。<code>StandardEnvironment</code>用默认的property配置源填充，默认配置源包括servlet配置和servlet上下文参数。<code>StandardPortletEnvironment</code>也可以访问portlet配置和portlet上下文参数。也可以可选的开启<code>JndiPropertySource</code>，详情参看Javadoc。</p>
</blockquote>
<p>若在系统property中存在<code>foo</code>或者在环境变量中存在<code>foo</code>，当使用<code>StandardEnvironment</code>调用<code>env.containsProperty(&quot;foo&quot;)</code>，将会返回<code>true</code>。</p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>检索是分层级的。默认情况，系统properties属性优先于环境变量，索引如果<code>foo</code>property这两两处都配置了，此时调用<code>env.getProperty(&quot;foo&quot;)</code>，系统property值将会返回。</p>
</blockquote>
<p>最重要的，完整的机制是可配置的。也许你需要一个自定义的properties源，并将该源整合到这个检索层级中。没有问题-只需实现和实例化你自定义的<code>PropertySource</code>，并在当前环境中把其加入到<code>PropertySources</code>中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ConfigurableApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();</div><div class="line">MutablePropertySources sources = ctx.getEnvironment().getPropertySources();</div><div class="line">sources.addFirst(<span class="keyword">new</span> MyPropertySource());</div></pre></td></tr></table></figure></p>
<p>在上面的代码中，<code>MyPropertySource</code>已经增加到了最高优先级的检索层级中。如果它有<code>foo</code>property属性，它将会被探测并返回，优先于其他<code>PropertySource</code>中的<code>foo</code>property属性。<code>MutablePropertySources</code>API暴露了很多方法，允许你精准的操作property属性源。</p>
<p></p><h4 id="__propertysource">@PropertySource</h4><br><code>@PropertySource</code>注解提供了一个方便的方式，用于增加一个<code>PropertySource</code>到Spring的环境中：<br>给定一个文件”app.properties”包含了key/value键值对testbean.name=myTestBean,下面的<code>@Configuration</code>类使用了<code>@PropertySource</code>，使用这种方式调用<code>testBean.getName()</code>将会返回<code>myTestBean</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/myco/app.properties"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    Environment env;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">testBean</span><span class="params">()</span> </span>&#123;</div><div class="line">        TestBean testBean = <span class="keyword">new</span> TestBean();</div><div class="line">        testBean.setName(env.getProperty(<span class="string">"testbean.name"</span>));</div><div class="line">        <span class="keyword">return</span> testBean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>任何的存在于<code>@PropertySource</code>中的<code>${...}</code>占位符，将会被解析为定义在环境中的属性配置文件中的属性值:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    Environment env;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">testBean</span><span class="params">()</span> </span>&#123;</div><div class="line">        TestBean testBean = <span class="keyword">new</span> TestBean();</div><div class="line">        testBean.setName(env.getProperty(<span class="string">"testbean.name"</span>));</div><div class="line">        <span class="keyword">return</span> testBean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设”my.placeholder”代表一个已经注册的的property属性，比如，系统属性或者环境变量，占位符将会被解析为相应的值。如果没有，那么<code>default/path</code>将会作为默认值。若没有默认值指定，那么property将不能解析，<code>IllegalArgumentException</code>将会抛出</p>
<p>TOADD</p>
<p></p><h4 id="_placeholder_resolution_in_statements">Placeholder resolution in statements</h4><br>以前，元素中的占位符的值只能解析JVM系统properties或者环境变量。No longer is this the case。因为<code>Environment</code>抽象通过容器集成，通过<code>Environment</code>可以非常容器的解析占位符。这意味着，你可以你喜欢的方式配置如何解析：可以改变是优先查找系统properties或者是有限查找环境变量，或者删除它们；增加自定义property源，使之成为更合适的。<p></p>
<p>下面的自定义property定义，会像<code>Enviroment</code>一样可用:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"com/bank/service/$&#123;customer&#125;-config.xml"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p></p><h3 id="context-load-time-weaver">注册LoadTimeWeaver</h3><br><code>LoadTimeWeaver</code>用于在JVM加载类时动态转换。<br>若要开启加载时织入，得在<code>@Configuration</code>类中增加<code>@EnableLoadTimeWeaving</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableLoadTimeWeaving</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>或者在XML中配置，使用<code>context:load-time-weaver</code>元素:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>一旦为<code>ApplicationContext</code>做了配置。<code>ApplicationContext</code>内的任何bean都会实现<code>LoadTimeWeaverAware</code>，因此可以接收load-time weaver实例。这种用法和JPA联合使用非常赞，load-time weaving加载织入对JPA类转换非常必要。详情请参看<code>LocalContainerEntityManagerFactoryBean</code>。关于AspectJ load-time weaving更多的详情，请参看<a href="#aop-aj-ltw">see Section 9.8.4, “Load-time weaving with AspectJ in the Spring Framework”</a></p>
<p></p><h3 id="context-introduction">补充说明ApplicationContext的能力</h3><br>就像简介章节讨论的,<code>org.springframework.beans.factory</code>包提供了管理和操作bean的基本功能，包含一种编程式的方式。<code>org.springframework.context</code>包增加了<code>ApplicationContext</code>接口，继承于<code>BeanFactory</code>接口,这也是为了继承其他的接口，并且提供<em>应用框架风格</em>。很多人使用<code>ApplicationContext</code>完全是声明式，甚至不用编程式去创建，依靠像<code>ContextLoader</code>这样的支持类自动实例化<code>ApplicationContext</code>，并把此作为Java EE web应用的启动步骤。<p></p>
<p>为了增强<code>BeanFactory</code>功能，context 包也支持下列功能:</p>
<ul>
<li>通过<code>MessageSource</code>接口，i18n-style方式访问messages。<em>译注国际化</em></li>
<li>通过<code>ResourceLoader</code>接口，访问资源，比如URLS网络资源定位符和Files文件系统</li>
<li>通过<code>ApplicationEventPublisher</code>,给实现了<code>ApplicationListener</code>接口的bean发布事件，</li>
<li>通过<code>HierarchicalBeanFactory</code>接口,加载多级contexts，允许关注某一层级context，比如应用的web层。</li>
</ul>
<p></p><h4 id="context-functionality-resources">TODO使用MessageSource国际化</h4><br><code>ApplicationContext</code>接口继承<code>MessageSource</code>接口,因此提供国际化<br>对这一章暂时不感兴趣，不翻了先。<p></p>
<p></p><h4 id="context-functionality-events">标注事件和自定义事件</h4><br><code>ApplicationContext</code>通过<code>ApplicationEvent</code>类和<code>ApplicationContext</code>类提供了事件处理。如果某个bean实现了<code>ApplicationListener</code>接口，并注册在了context中，每当<code>ApplicationEvent</code>向<code>ApplicationContext</code>发布时间，该bean就会收到通知。其实，这是一个标准的的<em>观察者模式</em>。Spring提供了下列标准事件:<p></p>
<p><strong>Table 5.7. Built-in Events</strong><br>事件  | 解释<br>—-  | —<br><code>ContextRefreshedEvent</code> |  当<code>ApplicationContext</code>初始化或者刷新时发布,比如，使用<code>ConfigurableApplicationContext</code>接口的<code>refresh()</code>方法。这里”初始化”的意思是指，所有的bean已经被加载、post-processor后处理bean已经被探测到并激活，单例bean已经pre-instantiated预先初始化，并且<code>ApplicationContext</code>对象已经可用。只要context上下文未关闭，可以多次触发刷新动作，    某些<code>ApplicationContext</code>支持”热”刷新。比如，<code>XmlWebApplicationContext</code>支持热刷新，<code>GenericApplicationContext</code>就不支持。<br><code>ContextStartedEvent</code> | 当<code>ApplicationContext</code>启动时候发布，使用<code>ConfiruableApplicationContext</code>接口的<code>start()</code>方法。这里的“启动”意思是指，所有的Lifecycle生命周期bean接收到了明确的启动信号。通常，这个信号用来在明确的“停止”指令之后重启beans，不过也可能是使用了启动组件，该组件并未配置自动启动，比如：组件在初始化的时候并未启动。<br><code>ContextStoppedEvent</code> | 当<code>ApplicationContext</code>停止时发布，使用<code>ConfigurableApplicationContext</code>接口的<code>stop()</code>方法。这里的“停止”的意思是指所有的Lifecycle生命周期bean接收到了明确的停止信号。一个停止了的context上下文可以通过<code>start()</code>调用来重启。<br><code>ContextClosedEvent</code> | 当<code>ApplicationContext</code>关闭时候发布，使用<code>ConfigurableApplicationContext</code>接口的<code>close()</code>方法。这里“关闭”的意思是所有的单例bean已经销毁。一个关闭的context上下文达到的生命周期的重点。不能刷新，不能重启。<br><code>RequestHandledEvent</code> | 是一个web专用事件，告诉所有的beans：一个HTTP request正在处理。这个时间在reqeust处理完成之后发布。该事件仅适用于使用Spring的<code>DispatcherServlet</code>的web应用。</p>
<p>你也可以创建并发布自定义事件。下面样例展示了这一点，一个简单的类继承了Spring的<code>ApplicationEvent</code>类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String test;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlackListEvent</span><span class="params">(Object source, String address, String test)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(source);</div><div class="line">        <span class="keyword">this</span>.address = address;</div><div class="line">        <span class="keyword">this</span>.test = test;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// accessor and other methods...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了发布自定义<code>ApplicationEvent</code>，得调用<code>ApplicationEventPublisher</code>接口上的<code>publishEvent()</code>方法。通常是使用一个已经注册为Spring bean的<code>ApplicationEventPublisherAware</code>接口的实现类来完成的。看样例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList;</div><div class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlackList</span><span class="params">(List&lt;String&gt; blackList)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.blackList = blackList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.publisher = publisher;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(String address, String text)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (blackList.contains(address)) &#123;</div><div class="line">            BlackListEvent event = <span class="keyword">new</span> BlackListEvent(<span class="keyword">this</span>, address, text);</div><div class="line">            publisher.publishEvent(event);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// send email...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在配置期间，spring容器发现<code>EmailService</code>实现了<code>ApplicationEventPublisherAware</code>并自动调用<code>setApplicationEventPublisher()</code>方法。实际上，参数就是Spring容器本身;可以通过<code>ApplicationEventPublisher</code>接口和应用上下文简单的交互。</p>
<p>为了接受自定义<code>ApplicationEvent</code>，得创建一个<code>ApplicationListener</code>的实现类并注册为spring Bean。看样例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListNotifier</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">BlackListEvent</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String notificationAddress;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotificationAddress</span><span class="params">(String notificationAddress)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.notificationAddress = notificationAddress;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</div><div class="line">        <span class="comment">// notify appropriate parties via notificationAddress...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，<code>ApplicationListener</code>以自定义事件类<code>BlackListEvent</code>作为范型类。也就是说<code>onApplicationEvent()</code>方法是类型安全的，无需向下转型。event listener事件监听想注册多少就注册多少,但是注意默认情况下，所有的监听会同步接收到事件。也就是说<code>publishEvent()</code>方法会阻塞所有监听完成对事件的处理。同步的、单线程的处理的一个优势是当一个监听接收到一个事件，若该事件发布者存在可用的事务时，监听会在发布者事务内操作。如果需要其他的事件发布策略，参看Spring的<code>ApplicationEventMulticastor</code>接口的JavaDoc</p>
<p>下面的样例展示了之前提到过的类如何定义bean并注册、配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emailService"</span> <span class="attr">class</span>=<span class="string">"example.EmailService"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blackList"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.spammer@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.hacker@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>john.doe@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blackListNotifier"</span> <span class="attr">class</span>=<span class="string">"example.BlackListNotifier"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"notificationAddress"</span> <span class="attr">value</span>=<span class="string">"blacklist@example.org"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>将他们组装到一起，当<code>emailService</code>bean的<code>sendEmail()</code>方法调用时，如果有email是黑名单中的的，自定义事件<code>BlackListEvent</code>就发布了。<code>balckListNotifier</code>bean注册成为<code>ApplicationListener</code>，因此可以接收到<code>BlackListEvent</code>,并能通知相关的观察者。</p>
<p><img src="http://docs.spring.io/spring/docs/4.2.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/images/note.png" alt="注意">  </p>
<blockquote>
<p>Spring的事件机制是为了Spirng beans和所在的应用context上下文之间做简单的交流。然而，为了满足复杂的企业级集成需求，有个单独维护的项目<a href="http://projects.spring.io/spring-integration/" target="_blank" rel="external">Spring Integration project</a>，提供了完整的支持,可用于轻量构建、<a href="http://www.enterpriseintegrationpatterns.com/" target="_blank" rel="external">pattern-oriented</a>，依赖Spring编程模型的事件驱动架构。</p>
</blockquote>
<p></p><h4 id="context-functionality-resources">便利的访问底层资源</h4><br>为了获得最佳用法和理解应用上下文，推荐大家通过Spring的Resource abstraction资源抽象熟悉他们，详情请参看<a href="#resources">Chapter 6, Resources</a><p></p>
<p>一个应用上下文是一个<code>ResourceLoader</code>，它能加载资源。<code>Resource</code>本质上是JDK的<code>java.net.URL</code>类的扩展，实际上，<code>Resource</code>的实现类中大多含有<code>java.net.URL</code>的实例。<code>Resource</code>几乎能从任何地方透明的获取底层资源，可以是classpath类路径、文件系统、标准的URL资源及变种URL资源。如果资源定位字串是简单的路径，没有任何特殊前缀，就适合于实际应用上下文类型。</p>
<p>可以配置一个bean部署到应用上下文中，用以实现特殊的回调接口，<code>ResouceLoaderAware</code>，它会在初始化期间自动回调。可以暴露<code>Resource</code>的type属性,这样就可以访问静态资源;静态资源可以像其他properties那样被注入<code>Resource</code>。可以使用简单的字串路径指定资源,这要依赖于特殊的JavaBean <code>PropertyEditor</code>,该类是通过context自动注册，当bean部署时候它将转换资源中的字串为实际的资源对象</p>
<p>The location path or paths supplied to an ApplicationContext constructor are actually resource strings, and in simple form are treated appropriately to the specific context implementation. ClassPathXmlApplicationContext treats a simple location path as a classpath location. You can also use location paths (resource strings) with special prefixes to force loading of definitions from the classpath or a URL, regardless of the actual context type.<br>定位符是实际的资源字串路径，作为<code>ApplicationContext</code>构造函数的参数，简单的形式就能得到特殊的context实现类恰当的处理。<code>ClassPathXamlApplicationContext</code>能解析简单的定位路径作为classpath定位，可以使用带有特殊前缀的定位路径，这样就可以强制从classpath或者URL定义加载路径,无需关注实际的context类型。</p>
<p><em>译注，啥玩意，翻的狗屁不通</em></p>
<p></p><h4 id="context-create">易用的web应用的<code>ApplicationContext</code>实例化</h4><br>可以通过声明式方式创建<code>ApplicationContext</code>实例，比如，一个<code>ContextLoader</code>。当然也可以使用编程时的方式创建<code>ApplicationContext</code>实例，得使用<code>ApplicationContext</code>实现。<br>使用<code>ContexgtLoaderListener</code>注册一个<code>ApplicationContext</code>，看样例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure><p></p>
<p>监听检查<code>contextConfigLocation</code>参数。如果参数不存在，监听默认使用<code>/WEB-INF/applicationContext.xml</code>。如果参数存在，监听会使用分隔符(逗号，分号，空格)分割参数，应用context会查找这些分割后的定位路径。Ant风格的路径支持的非常好。比如，<code>WEB-INF/*Context.xml</code>，将会匹配”WEB-INF”目录下所有以”Context.xml”结尾的file文件，<code>/WEB-INF/**/*Context.xml</code>，将会匹配”WEB-INF”下所有层级子目录的<code>Context.xml</code> 结尾的文件。</p>
<p></p><h4 id="context-deploy-rar">将Spring ApplicationContext作为JAVA EE RAR文件部署</h4><br>这章不翻了，没意思。<p></p>
<p></p><h3 id="beans-beanfactory">BeanFactory</h3><br><code>BeanFactory</code>为Spring的IoC功能提供了基础支撑，但是在集成第三方框架他只能直接使用，现在已经成为历史。<code>BeanFactory</code>和相关接口，比如<code>BeanFactorAware,InitializingBean,DisposableBean</code>，依然存在，是为了大量的集成了spirng的第三方框架向后兼容。常常有第三方组件不能使用现代风格的SPring，比如<code>@PostConstruct</code>或者<code>@PreDestroy</code>，是为了保留JDK1.4的兼容性，或者是为了避免依赖<code>JSR-250</code>。<br>本部分主要讲解有关<code>BeanFactory</code>和<code>ApplicationContext</code>之间的不同的背景，通过一个经典的检索单例类阐述他们如何直接的访问IoC容器。<p></p>
<p></p><h4 id="context-introduction-ctx-vs-beanfactory">BeanFactory or ApplicationContext</h4><br>优先使用<code>ApplicationContext</code>，除非你有非常好的理由不用它。<br>因为<code>ApplicationContext</code>包含了<code>BeanFactory</code>所有的方法，和<code>BeanFactory</code>相比更值得推荐，除了一些特定的场景，比如，在资源受限的设备上运行的内嵌的应用，这些设备非常关注内存消耗。无论如何，对于大多数的企业级应用和系统，<code>ApplicationContext</code>都是首选。Spring使用了的大量的<code>BeanPostProcess</code><a href="#beans-factory-extension-bpp">扩展点</a>，如果使用简单的<code>BeanFactory</code>，大量的功能将失效，比如:transactions 和AOP ，至少得多一些额外的处理。它会造成困扰，因为配置中所有的都不错。<p></p>
<p>下面的表格中列举了<code>BeanFactory</code>和<code>ApplicationContext</code>提供的功能:<br>Table 5.8. Feature Matrix</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody>
<tr>
<td>bean实例化和组装</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>自动注册<code>BeanPostProcessor</code></td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>自动注册<code>BeanFactoryPostProcessor</code></td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>便利的消息资源访问(用于i18n)</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td><code>ApplicationEvent</code>发布</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody>
</table>
<p>为了注册一个bean post-processor 给<code>BeanFactory</code>，得这么干:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ConfigurableBeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(...);</div><div class="line"></div><div class="line"><span class="comment">// now register any needed BeanPostProcessor instances</span></div><div class="line">MyBeanPostProcessor postProcessor = <span class="keyword">new</span> MyBeanPostProcessor();</div><div class="line">factory.addBeanPostProcessor(postProcessor);</div><div class="line"></div><div class="line"><span class="comment">// now start using the factory</span></div></pre></td></tr></table></figure></p>
<p>在使用<code>Beanfactory</code>时，注册<code>BeanFactoryPostProcessor</code>，得这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">XmlBeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> FileSystemResource(<span class="string">"beans.xml"</span>));</div><div class="line"></div><div class="line"><span class="comment">// bring in some property values from a Properties file</span></div><div class="line">PropertyPlaceholderConfigurer cfg = <span class="keyword">new</span> PropertyPlaceholderConfigurer();</div><div class="line">cfg.setLocation(<span class="keyword">new</span> FileSystemResource(<span class="string">"jdbc.properties"</span>));</div><div class="line"></div><div class="line"><span class="comment">// now actually do the replacement</span></div><div class="line">cfg.postProcessBeanFactory(factory);</div></pre></td></tr></table></figure></p>
<p>上面2个栗子，显示注册步骤非常不便，这就是为什么推荐使用<code>ApplicationContext</code>的原因之一,就是为了方便的使用<code>BeanFactoryPostProcessors</code>和<code>BeanPostProcessors</code>。这些机制实现了一些非常重要的功能，比如property placeholder replacement and AOP</p>
<p></p><h4 id="beans-servicelocator">耦合代码和邪恶的单例</h4><br>在应用中，推荐使用依赖注入的方式编写，使用Spring IoC容器管理的代码，当需要创建实例时，从容器获取他的依赖关系，并且对象对容器将对其一无所知，对于一些小的借合层的代码，也许会需要与其他层、组件、bean互相协作，可以以单例（准单例）方式使用Spring IoC容器。比如，第三方组件会使用构造器创建新对象（<code>Class.forName()</code>风格）,而不能使用IoC容器获取这些对象。 如果第三方组件创建的对象是stub或者proxy代理，然后这些对象以单例风格从Ioc容器获取真正的对象加以委派，此时控制反转完成主要工作（对象将脱离于容器管理）。此时，大部分代码不需知道容器、也不需知道如何访问容器，好处就是代码解耦。EJBs也可以使用这种方式，代理的方式委派给简单的java实现对象，java对象从Ioc容器检出。然而，spring Ioc容器必须得设计为单例，。。。。。。。//TODO<br><em>未翻译完，翻了完了不通顺，第五章总算是搞定了</em><p></p>
</aop:scoped-proxy>]]></content>
    
    <summary type="html">
    
      &lt;div style=&quot;font-size:34px&quot;&gt;Spring4参考手册中文版&lt;/div&gt;

&lt;p&gt;&lt;h1&gt;前言&lt;/h1&gt;&lt;br&gt;我是前言。&lt;/p&gt;
&lt;p&gt;&lt;h1 id=&quot;spring-core&quot;&gt;Part III. 核心技术&lt;/h1&gt;&lt;br&gt;本部分参考手册完全覆盖了Srping 框架的全部技术&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://liugch.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://liugch.top/tags/Spring/"/>
    
  </entry>
  
</feed>
