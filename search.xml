<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Springmvc 图片的上传]]></title>
      <url>http://liugch.top/2017/01/15/Springmvc%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%BF%9D%E5%AD%98/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Springmvc 图片的上传 和 保存到服务器中 并把图片地址保存在数据库中</p>
</blockquote>
<p>SpringMVC 中，文件的上传，是通过 MultipartResolver 实现的。</p>
<p>所以，如果要实现文件的上传，只要在 spring-mvc.xml 中注册相应的 MultipartResolver 即可。</p>
<a id="more"></a>
<p>MultipartResolver 的实现类有两个：</p>
<p>CommonsMultipartResolver</p>
<p>StandardServletMultipartResolver</p>
<blockquote>
<p>两个的区别：</p>
</blockquote>
<p>第一个需要使用 Apache 的 commons-fileupload 等 jar 包支持，但它能在比较旧的 servlet 版本中使用。</p>
<p>“commons-fileupload:commons-fileupload:1.3.1”,</p>
<p>第二个不需要第三方 jar 包支持，它使用 servlet 内置的上传功能，但是只能在 Servlet 3 以上的版本使用。</p>
<h1 id="兼容低版本方式的"><a href="#兼容低版本方式的" class="headerlink" title="兼容低版本方式的"></a>兼容低版本方式的</h1><p>1.必须导入的jar包</p>
<p>2.在Springmvc.xml中配置</p>
<pre><code>&lt;!-- SpringMVC上传文件时，需要配置MultipartResolver处理器 --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;
     &lt;!--最大能上传的大小 20M--&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;20971520&quot;/&gt;
    &lt;!--每个文件的大小5M--&gt;
    &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;5242880&quot;/&gt;
&lt;/bean&gt;  
</code></pre><p>3.在controller层中</p>
<pre><code>@PostMapping(value = &quot;/{id}&quot;)
public String post(MultipartFile picfile, HttpServletRequest request, @PathVariable int id ,Posts posts, Model model) {

    if (picfile != null &amp;&amp; !picfile.isEmpty()) {
        try {
            //保存的路径
            String realPath = request.getSession().getServletContext().getRealPath(&quot;/uploads&quot;);

            System.out.println(&quot;getRealPath:&quot;+realPath);
            // 获取图片的文件名
            String fileName = picfile.getOriginalFilename();
            System.out.println(&quot;获取图片的文件名&quot;+fileName);


            // 获取图片的扩展名
            String extensionName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1);
            // 新的图片文件名 = 获取时间戳+&quot;.&quot;图片扩展名
            String newFileName = String.valueOf(System.currentTimeMillis()) + &quot;.&quot; + extensionName;
            System.out.println(&quot;新的图片文件名&quot;+newFileName);

            // 保存在数库中文件地址
            String SQLpicName = realPath+&quot;\\&quot;+newFileName;

            String SQLpicName2 = &quot;/uploads/&quot;+newFileName;



            System.out.println(&quot;保存在数库中文件地址&quot;+SQLpicName);
            System.out.println(&quot;保存在数库中文件地址2&quot;+SQLpicName2);


            //在服务器中创建一个 文件保存
            File file = new File(realPath, newFileName);

            //保存在服务器中
            FileUtils.copyInputStreamToFile(picfile.getInputStream(), file);

            // 保存到数据库中
            User user = new User();
            user.setId(new Long(id));

            posts.setPic(SQLpicName2);
            posts.setCrateTime(new Date(System.currentTimeMillis()));
            posts.setUser(user);

            postsService.save(posts);


        } catch (Exception e) {
            model.addAttribute(&quot;error&quot;,&quot;发布微博失败!&quot;);
            //log.error(&quot;上传图片失败.&quot;, e);
        }
    }
    return &quot;redirect:/index&quot;;
}
</code></pre><h2 id="支持-servlet3-0-以上方式的"><a href="#支持-servlet3-0-以上方式的" class="headerlink" title="支持 servlet3.0 以上方式的"></a>支持 servlet3.0 以上方式的</h2><p>1.在web.xml 中配置</p>
<pre><code> &lt;servlet&gt;
    &lt;servlet-name&gt;myblog&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring-myblog.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;

    &lt;multipart-config&gt;
       &lt;!--&lt;location&gt;/temp&lt;/location&gt; &amp;lt;!&amp;ndash;临时保存&amp;ndash;&amp;gt;--&gt;
        &lt;max-file-size&gt;5242880&lt;/max-file-size&gt;&lt;!--最大可被上传的文件5MB--&gt;
        &lt;max-request-size&gt;20971520&lt;/max-request-size&gt;&lt;!--总大小20MB--&gt;
        &lt;file-size-threshold&gt;0&lt;/file-size-threshold&gt;
    &lt;/multipart-config&gt;
&lt;/servlet&gt;
</code></pre><p>2.在springmvc.xml 中</p>
<pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot; /&gt;
</code></pre><p>3.在controller层中</p>
<pre><code>@PostMapping(value = &quot;/{id}&quot;)
public String post(MultipartFile picfile, HttpServletRequest request, @PathVariable int id ,Posts posts, Model model) {

    if (picfile != null &amp;&amp; !picfile.isEmpty()) {
        try {
            //保存的路径
            String realPath = request.getSession().getServletContext().getRealPath(&quot;/uploads&quot;);

            System.out.println(&quot;getRealPath:&quot;+realPath);
            // 获取图片的文件名
            String fileName = picfile.getOriginalFilename();
            System.out.println(&quot;获取图片的文件名&quot;+fileName);


            // 获取图片的扩展名
            String extensionName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1);
            // 新的图片文件名 = 获取时间戳+&quot;.&quot;图片扩展名
            String newFileName = String.valueOf(System.currentTimeMillis()) + &quot;.&quot; + extensionName;
            System.out.println(&quot;新的图片文件名&quot;+newFileName);

            // 保存在数库中文件地址
            String SQLpicName = realPath+&quot;\\&quot;+newFileName;

            String SQLpicName2 = &quot;/uploads/&quot;+newFileName;



            System.out.println(&quot;保存在数库中文件地址&quot;+SQLpicName);
            System.out.println(&quot;保存在数库中文件地址2&quot;+SQLpicName2);


            //在服务器中创建一个 文件保存
            File file = new File(realPath, newFileName);

            //保存在服务器中
            //FileUtils.copyInputStreamToFile(picfile.getInputStream(), file);

            // 保存到数据库中
            User user = new User();
            user.setId(new Long(id));

            posts.setPic(SQLpicName2);
            posts.setCrateTime(new Date(System.currentTimeMillis()));
            posts.setUser(user);

            postsService.save(posts);


        } catch (Exception e) {
            model.addAttribute(&quot;error&quot;,&quot;发布微博失败!&quot;);
            //log.error(&quot;上传图片失败.&quot;, e);
        }
    }
    return &quot;redirect:/index&quot;;
}
</code></pre><p>上面controller层中 <strong>没有如下方法</strong>(把文件保存在 Tomcat服务器中 )</p>
<p>FileUtils.copyInputStreamToFile(picfile.getInputStream(), file);</p>
<p>要自己实现（也就是文件的流读取和保存） 网上代码一大堆</p>
<pre><code>public void copyInputStreamToFile(InputStream inputStream, File file) {

    BufferedInputStream bin = null;
    BufferedOutputStream bout = null;
    try {
        bin = new BufferedInputStream(inputStream);
        bout = new BufferedOutputStream(new FileOutputStream(file));

        byte[] buff=new byte[1024];
        int len=0;
        while((len=bin.read(buff))!=-1){
            bout.write(buff,0,len);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        try {
            bin.close();
            bout.flush();
            bout.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IO基本的操作]]></title>
      <url>http://liugch.top/2017/01/14/Java%20IO%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<blockquote>
<p>IO 的基本使用</p>
</blockquote>
<p><a href="http://www.cnblogs.com/oubo/archive/2012/01/06/2394638.html" target="_blank" rel="external">http://www.cnblogs.com/oubo/archive/2012/01/06/2394638.html</a></p>
<p><img src="http://pic002.cnblogs.com/images/2012/384764/2012031413373126.jpg" alt=""></p>
<h2 id="字符流-常用类"><a href="#字符流-常用类" class="headerlink" title="字符流  常用类"></a>字符流  常用类</h2><p>Reader  Writer</p>
<p>BufferedReader   InputStreamReader   FilterReader</p>
<p>BufferedWriter   OutputStreamWriter  FilterWriter</p>
<h3 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h3><p><strong>BufferedReader：</strong>  </p>
<p>可以通过 InputStreamReader 及其子类 FilterReader 进行创建</p>
<p>具有缓冲的作用，效率更高，一般都会去使用的</p>
<p>如： </p>
<pre><code>BufferedReader in = new BufferedReader(new FileReader(&quot;foo.in&quot;));

BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
</code></pre><p><strong>InputStreamReader:</strong> </p>
<p>可以通过 InputStream 及其 子类 进行创建</p>
<p>一般是用来创建BufferedReader 用的</p>
<pre><code>InputStreamReader(InputStream in) 
</code></pre><p><strong>FilterReader：</strong></p>
<p>一般都是不使用的， 都是用 FilterInputStream 进行代替</p>
<pre><code>FileReader(File file) 
      在给定从中读取数据的 File 的情况下创建一个新 FileReader。 

FileReader(String fileName) 
      在给定从中读取数据的文件名的情况下创建一个新 FileReader。 
</code></pre><blockquote>
<p>字符输出流和输入流几乎差不多                        </p>
</blockquote>
<h2 id="字节流-常用类"><a href="#字节流-常用类" class="headerlink" title="字节流 常用类"></a>字节流 常用类</h2><p>InputStream        OutputStream</p>
<p>FileInputStream    FileOutputStream</p>
<p>FilterInputStream  BufferedInputStream</p>
<p>FilterOutputStream BufferedOutputStream</p>
<h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><p><strong>FlieOutputStream：</strong></p>
<p>如果要输出的时字符流，一般都是使用 FileWriter</p>
<pre><code>FileOutputStream(File file) 
          创建一个向指定 File 对象表示的文件中写入数据的文件输出流。

FileOutputStream(String name) 
          创建一个向具有指定名称的文件中写入数据的输出文件流。 
</code></pre><p><strong>BufferedOutputStream：</strong></p>
<p>缓冲字节输出流，通过OutputStream的实现类进行创建</p>
<p>但是一般通过 FileOutputStream 来进行创建的</p>
<pre><code>BufferedOutputStream(OutputStream out) 
          创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 
BufferedOutputStream(OutputStream out, int size) 
          创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。
</code></pre><blockquote>
<p>下面是一个简单的使用：</p>
</blockquote>
<pre><code>/**
 * BufferedRead 和 BufferedWriter 的使用
 * @throws IOException
 */
public void fun() throws IOException{

    try {
        // 读
        FileReader fileReader = new FileReader(new File(&quot;C:/Users/Administrator/Desktop/test.txt&quot;));

        BufferedReader bufferedReader = new BufferedReader(fileReader);

        // 写

        File file = new File(&quot;C:/Users/Administrator/Desktop/test2.txt&quot;);

        if(!file.exists()){
            file.mkdirs();
        }


        FileWriter fileWriter = new FileWriter(file);

        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);

        String line;

        while((line=bufferedReader.readLine())!=null){
            System.out.println(line);

            bufferedWriter.write(line, 0,line.length());
        }

    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }


    //===============================

    FileInputStream fileInputStream = new FileInputStream(new File(&quot;C:/Users/Administrator/Desktop/test.txt&quot;));

    InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);

    BufferedReader bufferedReader2 = new BufferedReader(inputStreamReader);

}

/**
 * Inputstream 和 OutputStream 的基本使用 
 * @throws IOException
 */
public void fun2() throws IOException{

    FileInputStream fileInputStream = null;
    BufferedInputStream bufferedInputStream = null;
    BufferedOutputStream bufferedOutputStream = null;
    FileOutputStream fileOutputStream = null;
    try {
        fileInputStream = new FileInputStream(new File(&quot;C:/Users/Administrator/Desktop/test.txt&quot;));
        bufferedInputStream = new BufferedInputStream(fileInputStream);

        File file = new File(&quot;C:/Users/Administrator/Desktop/test2.txt&quot;);
        if(!file.exists()){
            file.mkdirs();
        }
        fileOutputStream = new FileOutputStream(file);

        bufferedOutputStream = new BufferedOutputStream(fileOutputStream);

        int len = fileInputStream.available();

        byte[] buff = new byte[len];

        while((len=fileInputStream.read(buff))!=-1){
            System.out.println(&quot;=======&quot;+fileInputStream.read(buff));
            bufferedOutputStream.write(buff,0,len);
        }
    } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }finally {
        fileInputStream.close();
        bufferedInputStream.close();
        fileOutputStream.close();
        bufferedOutputStream.flush();
        bufferedOutputStream.close();
    }


}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring 的基本问题]]></title>
      <url>http://liugch.top/2017/01/13/Spring%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="Spring-的基本问题"><a href="#Spring-的基本问题" class="headerlink" title="Spring 的基本问题"></a>Spring 的基本问题</h1><blockquote>
<p>AOP</p>
</blockquote>
<p>AOP ： 面向切面编程 ，它主要关注的是程序的执行过程。是对OOP 的一种扩充;</p>
<p>具体解析： 在java方法调用时，AOP机制能自动进行方法拦截，允许在方法调用之前，调用后，</p>
<p>以及执行异常时添加特点的代码来完成需要的功能。</p>
<a id="more"></a>
<p>特点：</p>
<p>1，消除编码模块之间的耦合。</p>
<p>2， 可以在任意阶段，向已有功能模块中填加新功能，且不侵入原有功能 低侵入式设计    </p>
<p>3， 各步骤之间的良好隔离性 , 源代码的无关性</p>
<p>4， AOP 的目标在于 将程序中涉及的公用问题集中解决</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 邮箱的发送 激活注册]]></title>
      <url>http://liugch.top/2017/01/11/Spring%20MVC%20%E9%82%AE%E7%AE%B1%E7%9A%84%E5%8F%91%E9%80%81%20%E6%BF%80%E6%B4%BB%E6%B3%A8%E5%86%8C/</url>
      <content type="html"><![CDATA[<h1 id="Spring-MVC-邮箱的发送-激活注册"><a href="#Spring-MVC-邮箱的发送-激活注册" class="headerlink" title="Spring MVC 邮箱的发送 激活注册"></a>Spring MVC 邮箱的发送 激活注册</h1><blockquote>
<p>发送邮件所需的jar包</p>
</blockquote>
<p>“org.springframework:spring-context-support:$springVersion”,<br>“javax.mail:mail:1.4.7”,</p>
<a id="more"></a>
<blockquote>
<p>在你的邮箱中把 POP3/SMTP服务 开启</p>
</blockquote>
<p>163 邮箱中: <a href="http://help.163.com/09/1223/14/5R7P3QI100753VB8.html" target="_blank" rel="external">http://help.163.com/09/1223/14/5R7P3QI100753VB8.html</a></p>
<p>qq 邮箱中: <a href="http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1000564" target="_blank" rel="external">http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1000564</a></p>
<p>以163 邮箱中的发送邮箱</p>
<blockquote>
<p> 在Spring.xml 和mail.properties 中配置 </p>
</blockquote>
<pre><code>mail.host=smtp.163.com  //服务地址
mail.username=liugchs@163.com // 用户名
mail.password=friend123 // 生成发邮箱的密码

 &lt;!--163 发送邮件 --&gt;
&lt;bean id=&quot;javaMailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt;
    &lt;property name=&quot;host&quot; value=&quot;${mail.host}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${mail.username}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${mail.password}&quot; /&gt;
    &lt;property name=&quot;port&quot; value=&quot;25&quot;&gt;&lt;/property&gt;// 端口
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;// 编码
    &lt;property name=&quot;javaMailProperties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;mail.transport.protocol&quot;&gt;smtp&lt;/prop&gt;
            &lt;prop key=&quot;mail.smtp.auth&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;mail.smtp.starttls.enable&quot;&gt;true&lt;/prop&gt;
            &lt;prop key=&quot;mail.smtp.timeout&quot;&gt;25000&lt;/prop&gt;
            &lt;prop key=&quot;mail.debug&quot;&gt;true&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>在 service 层中 dao 中的一些方法自己实现</p>
<pre><code>/**
 * Created by Administrator on 2017/2/7.
 */
@Service(value = &quot;userServiceImpl&quot;)
@Transactional
public class UserServiceImpl {
    @Resource
    private UserDaoImpl userDao;

    @Resource
    private EmailDaoImpl emailDao;

    @Transactional
    public void processRegist(User u) throws ServiceException {
        boolean isexit = userDao.isExit(u);
        if (isexit){
            throw new ServiceException(&quot;注册的用户已经存在了!&quot;);
        }else{
            u.setToux(&quot;https://secure.gravatar.com/avatar/81464a18af5480e64e56989887d118e8?s=50&quot;);
            u.setCrateTime(new Date());
            u.setStatus(0);

            String validateCode = MD5Util.encode2hex(u.getMail());
            u.setValidateCode(validateCode);

            //保存到数据库中
            userDao.save(u);

            //邮件内容
            StringBuffer sb=new StringBuffer(&quot;点击下面链接激活账号，48小时生效，否则重新注册账号，链接只能使用一次，请尽快激活！&lt;/br&gt;&quot;);
            sb.append(&quot;&lt;a href=\&quot;http://localhost:8080/upregist?action=activate&amp;email=&quot;);
            sb.append(u.getMail());
            sb.append(&quot;&amp;validateCode=&quot;);
            sb.append(validateCode);
            sb.append(&quot;&gt;http://localhost:8080/upregist?action=activate&amp;email=&quot;);
            sb.append(u.getMail());
            sb.append(&quot;&amp;validateCode=&quot;);
            sb.append(validateCode);
            sb.append(&quot;&lt;/a&gt;&quot;);

            //发送邮件
            emailDao.sendMail(u.getMail(),sb.toString());
        }

    }



    @Transactional
    public void activateRegist(String eamil,String validateCode) throws ServiceException {
        User user = userDao.getUserByEamil(eamil);
        if (user != null) {
            if (user.getStatus() == 0) {
                Date now = new Date(System.currentTimeMillis());
                Date get = user.getCrateTime();
                //得到天数
                int count = (int) ((now.getTime() - get.getTime()) / (1000 * 3600 * 24));
                if (get.before(now) &amp;&amp; count &lt; 2) {
                    if (user.getValidateCode().equals(validateCode)) {
                        user.setStatus(1);
                        userDao.update(user);
                    } else {
                        throw new ServiceException(&quot;激活码不正确！&quot;);
                    }
                } else {
                    throw new ServiceException(&quot;激活码已过期！&quot;);
                }
            } else {
                throw new ServiceException(&quot;邮箱已激活，请登录！&quot;);
            }

        } else {
            throw new ServiceException(&quot;该邮箱未注册（邮箱地址不存在）！&quot;);
        }

    }
}
</code></pre><p>在邮箱的dao 层中</p>
<pre><code> /**
 * 邮箱
 */
@Repository
public class EmailDaoImpl {

    @Resource
    MailSender mailSender;
    // 发件人
    private static final String FROM=&quot;liugchs@163.com&quot;;

    // 邮件标题
    private static final String SUBJECT=&quot;这是一个邮箱注册激活验证!&quot;;

    public void sendMail(String toEmail,String content) {
        SimpleMailMessage mailMsg = new SimpleMailMessage();
        mailMsg.setFrom(FROM);
        mailMsg.setTo(toEmail);
        mailMsg.setSubject(SUBJECT);
        mailMsg.setText(content);
        mailMsg.setSentDate(new Date());

        mailSender.send(mailMsg);  // 发送
    }
}
</code></pre><p>在controller 层中  还有一些userDao 中的方法自己 实现</p>
<pre><code>@RequestMapping(value = &quot;/upregist&quot;, method = {RequestMethod.GET, RequestMethod.POST})
public String regist2(User user, String repwd, HttpServletRequest request, Model model, HttpSession session, Errors errors) {
    // action=activate&amp;email=&quot;

    String action = request.getParameter(&quot;action&quot;);
    String email = request.getParameter(&quot;email&quot;);
    String validateCode = request.getParameter(&quot;validateCode&quot;);

    //如果是激活的话,改变 数据库的转态
    if (&quot;activate&quot;.equals(action)) {

        uerServices.activateRegist(email, validateCode);

        User use = uerServices.getUserByEamil(email);
        if (use == null || errors.hasErrors()) {
            return &quot;redirect:/login&quot;;
        } else {
            List&lt;Relationship&gt; relationshipList1 = relationshipService.getListByMasterId((int) use.getId());
            List&lt;Relationship&gt; relationshipList2 = relationshipService.getListByForlowedId((int) use.getId());
            session.setAttribute(&quot;session_user&quot;, use);
            session.setAttribute(&quot;session_relationshipList1&quot;, relationshipList1);
            session.setAttribute(&quot;session_relationshipList2&quot;, relationshipList2);
            return &quot;redirect:/index&quot;;
        }
    } else {
        // 注册 发送邮箱 激活
        uerServices.processRegist(user);
        model.addAttribute(&quot;activate&quot;, action);
        return &quot;redirect: /&quot;;
    }
}
</code></pre><p>工具类  用来 加密激活码用的 </p>
<pre><code> public class MD5Util {

    /**
     * 将源字符串使用MD5加密为字节数组
     *
     * @param source
     * @return
     */
    public static byte[] encode2bytes(String source) {
        byte[] result = null;
        try {
            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
            md.reset();
            md.update(source.getBytes(&quot;UTF-8&quot;));
            result = md.digest();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        return result;
    }

    /**
     * 将源字符串使用MD5加密为32位16进制数
     *
     * @param source
     * @return
     */
    public static String encode2hex(String source) {
        byte[] data = encode2bytes(source);
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; data.length; i++) {
            String hex = Integer.toHexString(0xff &amp; data[i]);

            if (hex.length() == 1) {
                hexString.append(&apos;0&apos;);
            }

            hexString.append(hex);
        }

        return hexString.toString();
    }

    /**
     * 验证字符串是否匹配
     *
     * @param unknown 待验证的字符串
     * @param okHex   使用MD5加密过的16进制字符串
     * @return 匹配返回true，不匹配返回false
     */
    public static boolean validate(String unknown, String okHex) {
        return okHex.equals(encode2hex(unknown));
    }

}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis 的基本使用]]></title>
      <url>http://liugch.top/2017/01/10/Redis%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="Redis-的基本使用"><a href="#Redis-的基本使用" class="headerlink" title="Redis 的基本使用"></a>Redis 的基本使用</h1><blockquote>
<p>使用教程</p>
</blockquote>
<p><a href="http://www.redis.net.cn/tutorial/3503.html" target="_blank" rel="external">http://www.redis.net.cn/tutorial/3503.html</a></p>
<a id="more"></a>
<blockquote>
<p>运行服务</p>
</blockquote>
<p> redis-server.exe redis.conf</p>
<blockquote>
<p>连接 </p>
</blockquote>
<p> redis-cli.exe -h 127.0.0.1 -p 6379</p>
<blockquote>
<p>PING</p>
</blockquote>
<p> 该命令用于检测 redis 服务是否启动。</p>
<blockquote>
<p>查看是否设置了密码</p>
</blockquote>
<p> CONFIG get requirepass</p>
<blockquote>
<p> 设置密码</p>
</blockquote>
<p> CONFIG set requirepass “runoob”</p>
<blockquote>
<p>整合相关</p>
</blockquote>
<p>个人 GitHub中有</p>
<p> <a href="http://blog.csdn.net/h348592532/article/details/46698311" target="_blank" rel="external">http://blog.csdn.net/h348592532/article/details/46698311</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 的基本操作]]></title>
      <url>http://liugch.top/2017/01/09/Linux%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="Linux-的基本操作"><a href="#Linux-的基本操作" class="headerlink" title="Linux 的基本操作"></a>Linux 的基本操作</h1><p>man ls</p>
<p>– help</p>
<a id="more"></a>
<blockquote>
<p>ls 操作</p>
</blockquote>
<p>ls [-l,-al]</p>
<p>ls |grep tomcat7</p>
<p>ls     : 当前目录下的所有的  文件夹名 及 文件名</p>
<p>ls -l  : 显示当前目录下面的所有的 文件夹名 及 文件名（具有权限，所有文件的总数）</p>
<p>ls -al : 显示 比 ls -l 更加具体一点的</p>
<blockquote>
<p>mkdir 创建 文件夹</p>
</blockquote>
<p>mkdir [-pm] 目录名</p>
<p>mkdir -p  ： 递归去创建 （mkdir -p test/test/test）</p>
<p>mkdir -m  ： 添加 不同权限的 目录 （ mkdir -m 771 test）</p>
<p>mkdri -pm 777 test/test/test  ：递归创建文件 并赋予相应的权限</p>
<blockquote>
<p>rmdir 移除目录</p>
</blockquote>
<p>rmdir [-p] 目录</p>
<p>rmdir -p test/test/test ： 连接上层的‘空’目录一起的移除（一点要空目录）</p>
<blockquote>
<p>复制 文件 或 目录</p>
</blockquote>
<p>cp [-adfilprsu] 源文件  目标目录</p>
<blockquote>
<p>删除文件夹</p>
</blockquote>
<p>rm [-rf] 目录名</p>
<p>rm -rf 目录名</p>
<blockquote>
<p>grep</p>
</blockquote>
<p>用来过滤的</p>
<blockquote>
<p>更改用户密码 ， 切换到超级用户 ， 临时切换到超级用户，并做一些操作</p>
</blockquote>
<p>sudo passwd :切换到超级用户 修改密码</p>
<p>su /sudo su ：切换到超级用户</p>
<blockquote>
<p>getdit Linux 下的一个简单的文本编辑器 相当于window下的编辑器</p>
</blockquote>
<p>getdit /etc/apt/sources.list</p>
<blockquote>
<p>apt 相关的操作</p>
</blockquote>
<p>apt-get update          : 更新 resources.list 一般当你要下载软件是一般使用比较好</p>
<p>apt-cache search “^git” : 查找 以 git 开头的 软件</p>
<p>apt-get install git     : 下载 git</p>
<p>apt-get remove git      : 卸载git</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 复习]]></title>
      <url>http://liugch.top/2017/01/08/java%E5%9F%BA%E7%A1%80_%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<blockquote>
<h1 id="Java-复习"><a href="#Java-复习" class="headerlink" title="Java 复习"></a>Java 复习</h1></blockquote>
<h2 id="Java-多线程-的-相关问题"><a href="#Java-多线程-的-相关问题" class="headerlink" title="Java 多线程 的 相关问题"></a>Java 多线程 的 相关问题</h2><p>Thread 多线程 面试常用问题 : <a href="http://www.cnblogs.com/dolphin0520/p/3958019.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3958019.html</a></p>
<blockquote>
<p>产生线程的方法</p>
</blockquote>
<a id="more"></a>
<p>1.继承 Thread 类; </p>
<p>2.实现Runable 接口;</p>
<pre><code>/**
 * 每个线程都是独立的单元
 * 一个程序中的线程是并发进行的  相当于同时执行  
 * 多线程,继承了Thread,并且重写了run ()方法
 * setName(),getName() 是用于设置   和    获取线程名称
 * Thread.currentThread() 获取当前的线程对象的引用
 * Thread.sleep(100) 让当前的线程睡眠 
 * threadDemo1.start() 线程的启动,使线程处于就绪的状态
 * @author Administrator
 *
 */
public class TreadDemo2 extends Thread{
    int count=0;
    public void run(){
        for(int i=0;i&lt;50;i++){
            if(i%3==0 &amp;&amp; this.getName().equals(&quot;线程2中的count值&quot;)){
                Thread.yield();//当前线程让行,有CPU资源也不继续运行,再次进入就绪状态
                try {
                    Thread.sleep(200);//
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(this.getName()+&quot;:&quot;+count);
            //System.out.println(Thread.currentThread().getName()+&quot;:&quot;+count++);
            //增加交替进行的机会

            count++;
        }
    }
    //mian 函数是主线程(守护线程) 
    public static void main(String[] args) {
        //创建了两个线程
        TreadDemo2 threadDemo1=new TreadDemo2();
        TreadDemo2 threadDemo2=new TreadDemo2();
        //设置线程的名称
        threadDemo1.setName(&quot;线程1中的count值&quot;);
        threadDemo2.setName(&quot;线程2中的count值&quot;);
        //启动线程
        threadDemo1.start();//强占CPU
        threadDemo2.start();

    }

}


public class TreadDemo3 implements Runnable{
    int count=0;
    public void run(){
        for(int i=0;i&lt;5;i++){
            //System.out.println(this.getName()+&quot;:&quot;+count++);

            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+count);
            //增加交替进行的机会
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            count++;
        }
        }
    public static void main(String[] args) {
         //创建了两个线程
        TreadDemo3 demo=new TreadDemo3();
        Thread t1=new Thread(demo);
        Thread t2=new Thread(demo);
        //设置线程的名称
        t1.setName(&quot;线程1中的count值&quot;);
        t2.setName(&quot;线程2中的count值&quot;);
        //启动线程
        t1.start();//强占CPU
        t2.start();
    }

}
</code></pre><p>3.Synchronized 的使用:</p>
<pre><code>class S126 implements Runnable {
    ArrayList&lt;String&gt; list;
    private Random rand = new Random();

    public S126() {
        list = new ArrayList&lt;String&gt;();
        list.add(&quot;张三(0)&quot;);
        list.add(&quot;李四(1)&quot;);
        list.add(&quot;王五(2)&quot;);
        list.add(&quot;赵六(3)&quot;);
        list.add(&quot;田七(4)&quot;);
        list.add(&quot;八哥(5)&quot;);
        list.add(&quot;九妹(6)&quot;);
    }
    @Override
    public  void run() {
        //fun();
        // 生成随机数
        // 显示随机数
        // 从列表中移除此人
        // 显示此人信息
        // 直到列表元素空了，就循环结束
        while (true) {
            synchronized (list) {    
                if (list.isEmpty()) {
                    System.out.println(&quot;人数已经抽完了!&quot;);
                    break;
                }
                int num = rand.nextInt(list.size());
                System.out.println(Thread.currentThread().getName() + &quot;抽到了&quot;
                        + num + &quot;号&quot;);
                String person = list.remove(num);
                System.out.println(Thread.currentThread().getName() + &quot;抽到人员姓名:&quot;
                        + person);
                list.notifyAll();
                try {
                    list.wait();
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    /*    System.out.println(Thread.currentThread().getName() + &quot;说:抽到人员姓名:&quot;
                + &quot;没人了!&quot;);*/

    }
}

public class SynchronizedDemo {
    public static void main(String[] args) {
        S126 s126 = new S126();
        Thread t1 = new Thread(s126,&quot;同望科技&quot;);
        Thread t2 = new Thread(s126,&quot;飞企科技&quot;);
        Thread t3 = new Thread(s126,&quot;Google网络&quot;);
        /*t1.setPriority(Thread.MAX_PRIORITY);
        t2.setPriority(Thread.MIN_PRIORITY);
        t3.setPriority(Thread.MIN_PRIORITY);*/
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre><blockquote>
<p>进程与线程的区别</p>
</blockquote>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。</p>
<p>不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。</p>
<p>别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<blockquote>
<p>Thread 类中的start() 和 run() 方法有什么区别？</p>
</blockquote>
<p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。</p>
<p>当你调用run()方法的时候，只会是在原来的线程中调用，<strong>没有新的线程启动，start()方法才会启动新线程</strong>。</p>
<blockquote>
<p>Java中notify 和 notifyAll有什么区别？</p>
</blockquote>
<p>notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。</p>
<p>而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p>
<blockquote>
<p> 为什么wait, notify 和 notifyAll 这些方法不在thread类里面？</p>
</blockquote>
<p>JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。</p>
<p>如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。</p>
<p>简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
<blockquote>
<p>Java中sleep()与wait()的区别  </p>
</blockquote>
<p>一,功能差不多,都用来进行线程控制,他们最大本质的区别是:sleep()释放CPU资源,不释放同步锁,wait()释放CPU资源,释放同步锁.   </p>
<p>还有用法的上的不同是:sleep(milliseconds)可以用时间指定来使他自动醒过来,如果时间不到你只能调用interreput()来强行打断;</p>
<p>二,Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。</p>
<p>wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，</p>
<p>而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。</p>
<p>wait()可以用notify()直接唤起.</p>
<blockquote>
<p> 什么是ThreadLocal变量？</p>
</blockquote>
<p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量</p>
<p>它是为创建代价高昂的对象获取线程安全的好方法, SimpleDataFormat;</p>
<blockquote>
<p>为什么wait和notify方法要在同步块中调用？</p>
</blockquote>
<p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。</p>
<p>还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<blockquote>
<p> Thread类中的yield方法有什么作用？</p>
</blockquote>
<p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。</p>
<p>它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，</p>
<p>执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<h2 id="Java-JDBC-数据库操作"><a href="#Java-JDBC-数据库操作" class="headerlink" title="Java JDBC 数据库操作"></a>Java JDBC 数据库操作</h2><blockquote>
<p>JDBC 连接数据库的几个步骤(以MySQL为例)</p>
</blockquote>
<p>加载驱动</p>
<pre><code>try{   
  //加载MySql的驱动类   com.masql.jdbc.Driver
  Class.forName(&quot;com.mysql.jdbc.Driver&quot;) ;   
}catch(ClassNotFoundException e){   
  System.out.println(&quot;找不到驱动程序类 ，加载驱动失败！&quot;);   
  e.printStackTrace() ;   
}   
</code></pre><p>获取连接对象</p>
<pre><code> //连接MySql数据库 url:jdbc:mysql://locahost:3306/数据库名
String url = &quot;jdbc:mysql://localhost:3306/test&quot; ;    
String username = &quot;root&quot; ;   
String password = &quot;root&quot; ; 

try{   
   Connection con =    
   DriverManager.getConnection(url , username , password ) ;   
}catch(SQLException se){   
   System.out.println(&quot;数据库连接失败！&quot;);   
   se.printStackTrace() ;   
}   
</code></pre><p>获取语句执行对象</p>
<pre><code>Statement stmt = con.createStatement() ;// 普通语句执行对象

PreparedStatement pstmt = con.prepareStatement(sql) ;// 具有预处理执行语句对象

CallableStatement cstmt = con.prepareCall(&quot;{CALL demoSp(? , ?)}&quot;);//执行储存过程语句对象  
</code></pre><p>获取结果集对象</p>
<pre><code>ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM ...&quot;) ;// 执行查询操作

int rows = stmt.executeUpdate(&quot;INSERT INTO ...&quot;) ;// 执行插入更新操作

boolean flag = stmt.execute(String sql) ;  //所有语句
</code></pre><p>关闭操作</p>
<pre><code>rs.close() ;   //关闭结果集

stmt.close() ; // 关闭语句执行对象   

conn.close() ;   //关闭连接对象
</code></pre><h2 id="Java-一些常用的设计模式"><a href="#Java-一些常用的设计模式" class="headerlink" title="Java 一些常用的设计模式"></a>Java 一些常用的设计模式</h2><blockquote>
<p>门面模式</p>
</blockquote>
<p>门面模式的实现</p>
<p>使用门面模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，</p>
<p>一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。</p>
<p>有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。</p>
<pre><code>public class Module {
    /**
     * 提供给子系统外部使用的方法
     */
    public void a1(){};

    /**
     * 子系统内部模块之间相互调用时使用的方法
     */
    public void a2(){};
    public void a3(){};
}

public class ModuleB {
    /**
     * 提供给子系统外部使用的方法
     */
    public void b1(){};

    /**
     * 子系统内部模块之间相互调用时使用的方法
     */
    public void b2(){};
    public void b3(){};
}

public class ModuleC {
    /**
     * 提供给子系统外部使用的方法
     */
    public void c1(){};

    /**
     * 子系统内部模块之间相互调用时使用的方法
     */
    public void c2(){};
    public void c3(){};
}


public class ModuleFacade {

    ModuleA a = new ModuleA();
    ModuleB b = new ModuleB();
    ModuleC c = new ModuleC();
    /**
     * 下面这些是A、B、C模块对子系统外部提供的方法
     */
    public void a1(){
        a.a1();
    }
    public void b1(){
        b.b1();
    }
    public void c1(){
        c.c1();
    }
}
</code></pre><p>这样定义一个ModuleFacade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。</p>
<p>比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。</p>
<p>对客户端来说，他可能还要去思考a2()、a3()方法用来干什么呢？</p>
<p>其实a2()和a3()方法是内部模块之间交互的，原本就不是对子系统外部的，所以干脆就不要让客户端知道。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 泛型的使用]]></title>
      <url>http://liugch.top/2017/01/07/Java%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>java 泛型的使用</p>
</blockquote>
<h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><p><strong>类型参数化</strong></p>
<p>类的设计者不用考虑类的具体类型,要以对象进行一定的操作，对象的所有操作都必须是进行相同的,</p>
<p>比如，存放放对象，获取对象等操作。</p>
<a id="more"></a>
<p>一般情况下,泛型广泛应用容器类型。</p>
<p>如果某两个容器类中包含A和B类两种对象，就不能对A对象进行A对象特有方法的调用,也不能调用B对象特有的方法.</p>
<p>否则就出现错误，这是泛型的局限性。</p>
<p><strong>在没有泛型之前，类型只有两种:</strong></p>
<p>基本数据类型(boolean,char,byte,short,int,long,double,float)</p>
<p>复杂类型(类，数组,接口)</p>
<p>有了泛型，就可以定义一种类型，扩展更多的类型。</p>
<p>例如：定义一个盒子的类型，作用一个容器,可以存储不同的类型的对象。</p>
<pre><code>class Food{
    public void eat(){}
}
class Book{
    public void read(){}
}
public class Box&lt;T&gt;{
    List&lt;T&gt; box;
    public Box(){
        box = new ArrayList&lt;T&gt;();
    }
    public void set(T t){
        box.add(t);
    }
    public T get(int index){
        return box.get(index);
    }
}
public class Test{
    public static void main(String args){            //用上面定义的泛型类Box可以定义以下两种不同的类型.
        //box1为一个食物的盒子
        //box2为一个放书的箱子
        Box&lt;Food&gt; box1 = new Box&lt;Food&gt;();
        Box&lt;Book&gt; box2 = new Box&lt;Book&gt;();
        //还可以衍生其它的新类型
        Box&lt;Number&gt; b3;
        Box&lt;String&gt; b4;            

        String name=&quot;张三&quot;;
        String className;            
        className=name;//类型相同，可以赋值            
        //!  b3 = box1;//出错，类型不同            
    }
}
</code></pre><h2 id="实现泛型类，接口及方法"><a href="#实现泛型类，接口及方法" class="headerlink" title="实现泛型类，接口及方法"></a>实现泛型类，接口及方法</h2><blockquote>
<p>定义一个泛型类</p>
</blockquote>
<p><strong>class 类名&lt;泛型名&gt;{ }</strong></p>
<p><strong>说明:</strong></p>
<pre><code>1.类中所有的成员都可以使用泛型，除静态块，静态方法，静态属性外。

2.泛型名一般用大写字母,以区别其它的标识符。

3.泛型名一般用T字母，以可以使用T附近的字母，比如:T,E之类的。

4.泛型定义时用&lt;&gt;包裹,写在类名之后。

5.不能用new实例化对象

例如:
public class MyContainer&lt;T,E&gt;{
    //像普通类型一样，作为成员属性的类型
    String name;
    T t;
    E e;

    //像普通类型一样，用在构造器的参数列表中
    public MyContainer(String name, T t, E e){
        this.name = name;
        this.t = t;
        this.e = e;
    }
    //像普通类型一样，作为方法的返回值类型，或方法的参数类型
    public T getObject1(){
        return t;
    }
    public void setObject2(E e){
        this.e = e;
    }
    public void setName(String name){
        this.name = name;
    }
    public String toString(){
        return name+&quot;,&quot;+t.toString()+&quot;,&quot;+e.toString();
    }
}
</code></pre><blockquote>
<p> 定义一个泛型接口</p>
</blockquote>
<pre><code>与泛型类相同
public Interface&lt;T&gt; 接口名{
    //!T t=null;//接口中的属性是常量(public static final)，不能存在在静态成员中
    public void set(T t);
    public T get();
}
</code></pre><blockquote>
<p>继承</p>
</blockquote>
<p>public class 子类<t,e> extends 父类<t>{</t></t,e></p>
<p>}</p>
<p>与普通类相似,继承一个父类，实现多个接口。</p>
<blockquote>
<p>方法</p>
</blockquote>
<p><strong>说明:</strong></p>
<p>在修饰符之后，返回类型之前用&lt;&gt;定义泛型    </p>
<pre><code>class 类名{
    //如果method中有个参数是未知类型
    public &lt;T&gt; void method(T t){

    }
    public static &lt;T&gt; void method(T t,int i){

    }

}
</code></pre><blockquote>
<p>泛型的实现原理</p>
</blockquote>
<p>源代码由编译器转换成字节码文件，由java虚拟机运行。</p>
<p>泛型是在编译器中实现的，不是在虚拟机中运行,在虚拟机运行之前必须要清楚具体类。这一个过程叫”擦除”。</p>
<p>解决问题:</p>
<p>将ClassCastException运行时异常，变为了个编译语法检查的行为，让程序避免了运行时异常的类型转换异常.</p>
<p>例如:</p>
<pre><code>public class Demo&lt;T,E&gt;{
    T firstObj;
    E secondObj;        
    public void setFirst(T firstObj){
        this.firstObj = firstObj;
    }
    public E getSecond(){
        return secondObj;
    }
    public static void main(){
        Demo&lt;Teacher,Student&gt; demo = new Demo&lt;Teacher,Student&gt;();

        //!demo.setFirst(new Person());
        //出错:在调用setFirst()方法时，强制的约束类型为Teacher,在调用此方法时，参数类型必须是Teachar类型或其子类。            
        demo.setFirst(new Teacher());


        //在编译器，自动进行一个&quot;擦除&quot;,代码变如下代码:
        //Student stu = (Student)demo.getSecond();
        Student stu = demo.getSecond();
    }
}
</code></pre><p>擦除后的代码:</p>
<pre><code>public static void main(){
    Demo demo = new Demo();

    demo.setFirst((Object)new Teacher());
    Object obj  = demo.getSecond();
    Stdudent stu = (Student)obj;
}    
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Struts2 常用的标签]]></title>
      <url>http://liugch.top/2017/01/06/Struts2%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
      <content type="html"><![CDATA[<h1 id="Struts2-常用的标签"><a href="#Struts2-常用的标签" class="headerlink" title="Struts2 常用的标签"></a>Struts2 常用的标签</h1><blockquote>
<p>集中常用的标签</p>
</blockquote>
<p><strong>日期标签:</strong></p>
<a id="more"></a>
<p>ognl:</p>
<pre><code>&lt;s:date name=&quot;&quot; format=&quot;yyyy-mm-dd&quot; /&gt;
</code></pre><p>jstl:</p>
<pre><code>&lt;f:formatDate value=&quot;${值}&quot; pattern=&quot;yyyy-MM-dd&quot;/&gt;
</code></pre><p><strong>数字格式化:</strong></p>
<p>jstl:</p>
<pre><code>&lt;%--以￥开头小数位为两位,不足两位不足--%&gt;
&lt;f:formatNumber pattern=&quot;￥#.00&quot; value=&quot;${number}&quot; type=&quot;number&quot;/&gt;
</code></pre><p><strong>ognl 错误 显示</strong></p>
<pre><code>&lt;s:fielderror fieldName=&quot;错误字段名&quot; /&gt;
</code></pre><p><strong>ognl 国际化显示</strong></p>
<pre><code>&lt;%--标签输出国际化信息--%&gt;
&lt;s:text name=“”/&gt;

&lt;%--在表单标签中，通过key属性指定资源文件中的key--%&gt;
&lt;s:textfield name=&quot;realname&quot; key=&quot;user&quot;/&gt;

&lt;%--使用&lt;s:i18n&gt;标签我们可以在类路径下直接从某个资源文件中获取国际化数据，而无需任何配置--%&gt;
&lt;s:i18n name=&quot;&quot; /&gt;
</code></pre><h2 id="Struts2-ajax-提交"><a href="#Struts2-ajax-提交" class="headerlink" title="Struts2 ajax 提交"></a>Struts2 ajax 提交</h2><p>1.导入相关的jar包</p>
<p>2.struts.xml 中配置相关 的 信息</p>
<p>3.使用 ajax 提交方式</p>
<pre><code>struts-json.jar 插件

&lt;!--  
    extends继承 json-default 
    json-default 是继承 struts-default 的 对其的一种扩展
--&gt;

&lt;package name=&quot;ajax3&quot; extends=&quot;json-default&quot;&gt;

&lt;action name=&quot;ajaxTest3&quot; class=&quot;xxx.AjaxAction&quot; method=&quot;ajaxTest3&quot;&gt;
    &lt;result type=&quot;json&quot;&gt;
        &lt;param name=&quot;root&quot;&gt;result 和action中 要显示页面的对象 名&lt;/param&gt;
        &lt;!-- 还有其他一些参数，可以看文档 --&gt;
    &lt;/result&gt;
&lt;/action&gt;
&lt;/package&gt;

// 在action 类 中 实现 Set Get 方法

private String result;


public String ajaxTest3 () {
    result = &quot;这是通过业务获取的string.&quot;;
    return &quot;success&quot;;
}
</code></pre><h3 id="Struts2-表单-的服务端验证"><a href="#Struts2-表单-的服务端验证" class="headerlink" title="Struts2 表单 的服务端验证"></a>Struts2 表单 的服务端验证</h3><p>一.编程式验证 一般都不用所以就不写 了</p>
<p>二. xml 进行验证</p>
<p>在与action类<strong>同包中</strong>添加xml 配置文件</p>
<p>1.对某个action 的验证 </p>
<p>命名: <strong>Action类名-validation.xml</strong></p>
<p>2.对action中某个方法进行验证</p>
<p>命名: <strong>Action类名-方法名-validation.xml</strong></p>
<p>例如: ScheduleAction-save-validation.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE validators PUBLIC
            &quot;-//Apache Struts//XWork Validator 1.0.3//EN&quot;
            &quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&quot;&gt;

    &lt;validators&gt;

        &lt;!-- 
            长度的验证 
            name: 必须和表单的字段名一致            
        --&gt;

        &lt;field name=&quot;schedule.consignee&quot;&gt;
            &lt;field-validator type=&quot;requiredstring&quot;&gt;
                &lt;message&gt;请填写收货人&lt;/message&gt;
            &lt;/field-validator&gt;
            &lt;field-validator type=&quot;stringlength&quot;&gt;
                &lt;param name=&quot;minLength&quot;&gt;1&lt;/param&gt;
                &lt;param name=&quot;maxLength&quot;&gt;8&lt;/param&gt;
                &lt;message&gt;收货人必须在 ${maxLength} 个字符之内&lt;/message&gt;
            &lt;/field-validator&gt;
        &lt;/field&gt;


        &lt;!-- 验证邮箱 --&gt;
        &lt;field name=&quot;schedule.email&quot;&gt;
            &lt;field-validator type=&quot;requiredstring&quot;&gt;
                &lt;message&gt;邮箱不能为空&lt;/message&gt;
            &lt;/field-validator&gt;
            &lt;field-validator type=&quot;email&quot;&gt;
                &lt;message&gt;请填写正确的邮箱&lt;/message&gt;
            &lt;/field-validator&gt;
        &lt;/field&gt;

        &lt;!-- 手机号码 的验证 --&gt;
        &lt;field name=&quot;person.phone&quot;&gt;  
            &lt;field-validator type=&quot;regex&quot;&gt;  
                &lt;param name=&quot;regex&quot;&gt;&lt;![CDATA[^1[358]\d{9}$]]&gt;&lt;/param&gt;            
                &lt;message&gt;电话号码必须为11位数字&lt;/message&gt;  
            &lt;/field-validator&gt;  
        &lt;/field&gt;

          &lt;!-- 身份证是否合法 --&gt;
        &lt;field name=&quot;person.code&quot;&gt;  
          &lt;field-validator type=&quot;regex&quot;&gt;
               &lt;param name=&quot;expression&quot;&gt;
                &lt;![CDATA[(^\d{14}(\d{1}|\d{4}|(\d{3}[xX]))$)]]&gt;
               &lt;/param&gt;
               &lt;message&gt;您输入的身份证号不正确&lt;/message&gt;
             &lt;/field-validator&gt;  
        &lt;/field&gt;
    &lt;/validators&gt;

    &lt;!-- 两次密码是否一致 --&gt;
    &lt;validator type=&quot;fieldexpression&quot;&gt;
        &lt;param name=&quot;fieldName&quot;&gt;pwd&lt;/param&gt;    
         &lt;param name=&quot;fieldName&quot;&gt;pwd2&lt;/param&gt;
         &lt;param name=&quot;expression&quot;&gt;&lt;![CDATA[pwd==pwd2]]&gt;&lt;/param&gt;&lt;!-- OGNL表达式 --&gt;
        &lt;message&gt;确认密码和密码输入不一致&lt;/message&gt;
    &lt;/validator&gt;
</code></pre><p>页面上用: <s:fielderror fieldname=""> 进行错误提示显示</s:fielderror></p>
<hr>
<blockquote>
<p>Struts2 几种获取参数的方法 </p>
<p><a href="https://my.oschina.net/u/1398304/blog/215874" target="_blank" rel="external">https://my.oschina.net/u/1398304/blog/215874</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 常用笔记]]></title>
      <url>http://liugch.top/2017/01/06/javaScript%20%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript常用笔记"><a href="#JavaScript常用笔记" class="headerlink" title="JavaScript常用笔记"></a>JavaScript常用笔记</h1><blockquote>
<p>电子邮箱 手机号码 中文验证 (表单)</p>
</blockquote>
<a id="more"></a>
<pre><code> $(&quot;form&quot;).submit(function () {
    var $consignee = $(&quot;input[name=&apos;schedule.consignee&apos;]&quot;);
    var $email = $(&quot;input[name=&apos;schedule.email&apos;]&quot;);
    var $mobile = $(&quot;input[name=&apos;schedule.mobile&apos;]&quot;);
    var $address = $(&quot;input[name=&apos;schedule.address&apos;]&quot;);
    /*中文*/
    if ($consignee.val().trim() == &quot; &quot; || $consignee.val().length &lt; 1 || !$consignee.val().match(/^[\u4e00-\u9fa5]{1,20}$/)) {
        $(&quot;#consignee&quot;).text(&quot;输入你的真实姓名(仅限中文名)&quot;).css(&quot;color&quot;, &quot;red&quot;);
        $consignee.focus();
        return false;
    }else{
        $(&quot;#consignee&quot;).text(&quot;&quot;);
    }
    /*电子邮箱*/
    if ($email.val().trim() == &quot; &quot; || $email.val().length &lt; 1 || !$email.val().match(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/)) {
        $(&quot;#email&quot;).text(&quot;请输入正确的电子邮箱&quot;).css(&quot;color&quot;, &quot;red&quot;);
        $email.focus();
        return false;
    }else{
        $(&quot;#email&quot;).text(&quot;&quot;);
    }

    /*电话号码*/
    if ($mobile.val().trim() == &quot; &quot; || $mobile.val().length &lt; 1 || !$mobile.val().match(/^(1(([35][0-9])|(47)|[8][01236789]))\d{8}$/)) {
        $(&quot;#mobile&quot;).text(&quot;请输入正确的电话号码号码&quot;).css(&quot;color&quot;, &quot;red&quot;);
        $mobile.focus();
        return false;
    }  else{
        $(&quot;#mobile&quot;).text(&quot;&quot;);
    }

    if ($address.val().trim() == &quot; &quot; || $address.val().length &lt; 1 ) {
        $(&quot;#address&quot;).text(&quot;请输入正确的收货地址&quot;).css(&quot;color&quot;, &quot;red&quot;);
        $address.focus();
        return false;
    } else{
        $(&quot;#address&quot;).text(&quot;&quot;);
    }
    return true;
});
</code></pre><blockquote>
<p>js 关闭浏览器</p>
</blockquote>
<pre><code>/*关闭浏览器*/
function closeWin(){
    if(confirm(&quot;真的准备退出吗?&quot;)) {
        var userAgent = navigator.userAgent;
        if (userAgent.indexOf(&quot;Firefox&quot;) != -1 || userAgent.indexOf(&quot;Chrome&quot;) !=-1) {
            window.location.href=&quot;about:blank&quot;;
        } else {
            window.opener = null;
            window.open(&quot;&quot;, &quot;_self&quot;);
            window.close();
        }
    }
}



 // 身份证号码为15位或者18位，15位时全为数字，18位前17位为数字，最后一位是校验位，可能为数字或字符X  
</code></pre><p>   var reg = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;<br>   if(reg.test(card) === false)<br>   {<br>       alert(“身份证输入不合法”);<br>       return  false;<br>   } </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 模式之代理模式]]></title>
      <url>http://liugch.top/2017/01/04/Java%20%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="Java-模式之代理模式"><a href="#Java-模式之代理模式" class="headerlink" title="Java 模式之代理模式"></a>Java 模式之代理模式</h1><p>静态代理 和 动态代理  <a href="http://blog.csdn.net/liangbinny/article/details/18656791" target="_blank" rel="external">http://blog.csdn.net/liangbinny/article/details/18656791</a></p>
<a id="more"></a>
<blockquote>
<p>静态代理</p>
</blockquote>
<p>代理的真实对象必须真实的存在</p>
<p>如果代理的对象很多;出现类的臃肿;不够灵活;</p>
<p>JDK 动态代理 和 CGLib 动态代理 <a href="http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html" target="_blank" rel="external">http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html</a></p>
<blockquote>
<p>JDK 动态代理</p>
</blockquote>
<p>必须要有一个接口,  真实的对象必须实现该接口;</p>
<pre><code>    public class BookFacadeProxy implements InvocationHandler {
    private Object target;

    private BookFacadeImpl bookFacade;

    /**
     * 绑定委托对象并返回一个代理类
     *
     * @param target
     * @return
     */
    public Object bind(Object target) {
        this.target = target;
        //取得代理对象  
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(), this);   //要绑定接口(这是一个缺陷，cglib弥补了这一缺陷)  
    }

    public BookFacadeProxy(BookFacadeImpl bookFacade) {
        this.bookFacade=bookFacade;
    }

    public BookFacadeProxy() {
        super();
    }

    /**
     *
     * @param proxy 代理对象
     * @param method 代理对象实现接口中的 方法
     * @param args  方法中的 参数
     * @return
     * @throws Throwable
     */
/*    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        Object result = null;
        System.out.println(&quot;事物开始&quot;);
        //执行代理对象中方法
        result = method.invoke(target, args);
        System.out.println(&quot;事物结束&quot;);
        return result;
    }*/

    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        Object result = null;
        System.out.println(&quot;事物开始&quot;);
        //执行方法
        result = method.invoke(bookFacade, args);
        System.out.println(&quot;事物结束&quot;);
        return result;
    }

}  
</code></pre><blockquote>
<p>CGLib 动态代理</p>
</blockquote>
<p>该代理的类可以不用继承一个接口,  实现的原理是:通过产生一个子类.增强父类,字节码增强;</p>
<p><strong>代理对象的生成过程由Enhancer类实现，大概步骤如下：</strong></p>
<p>1、生成代理类Class的二进制字节码；</p>
<p>2、通过Class.forName加载二进制字节码，生成Class对象；</p>
<p>3、通过反射机制获取实例构造，并初始化代理类对象。</p>
<pre><code>import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;


/**
 * 使用cglib动态代理
 *
 * @author student
 */
public class BookFacadeCglib implements MethodInterceptor {
    private Object target;

    /**
     * 创建代理对象
     *
     * @param target
     * @return
     */
    public Object getInstance(Object target) {
        this.target = target;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(this.target.getClass());
        // 回调方法  
        enhancer.setCallback(this);
        // 创建代理对象  
        return enhancer.create();
    }

    @Override
    // 回调方法  
    public Object intercept(Object obj, Method method, Object[] args,
                            MethodProxy proxy) throws Throwable {
        System.out.println(&quot;事物开始&quot;);
        proxy.invokeSuper(obj, args);
        System.out.println(&quot;事物结束&quot;);
        return null;
    }

}  



public class TestCglib {

    public static void main(String[] args) {

        BookFacadeCglib cglib = new BookFacadeCglib();

        //BookFacadeImpl1 bookCglib = (BookFacadeImpl1) cglib.getInstance(new BookFacadeImpl1());
        //
        //bookCglib.addBook();

        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(new BookFacadeImpl1().getClass());
        enhancer.setCallback(cglib);


        BookFacadeImpl1 bookFacadeImpl1 = (BookFacadeImpl1) enhancer.create();

        bookFacadeImpl1.addBook();




    }
}  
</code></pre><p>与JDK动态代理相比，cglib可以实现对一般类的代理而无需实现接口</p>
<p><strong>实现步骤:</strong></p>
<p>创建Enhancer实例</p>
<p>通过setSuperclass方法来设置目标类</p>
<p>通过setCallback 方法来设置拦截对象</p>
<p>create方法生成Target的代理类，并返回代理类的实例</p>
<p>说到底就是把目标类包装一下(extend).生成一个代理对象;</p>
<hr>
<p>所以总结三种代理模式:</p>
<p>静态代理: 代理类必须 实现一个接口, 在实际的开发中 会产生很多的代理类;</p>
<p>并且代理的 真实的类必须实现 同一个接口;(一般不使用)</p>
<p>JDK 代理 : 代理的真实的一个类必须实现一个接口;如果没有实现一个接口 会出现 转换异常;(如果真实的代理类如果实现了一个接口 使用JDK代理执行 效率比CGLib 高)</p>
<p>CGLib 代理: 可以不实现一个接口, 只是对真正所代理的对象进行了一个继承,进行更强的包装;</p>
<blockquote>
<p>Spring AOP 于 Aspectj 的区别 与什么时候适用<br><a href="https://www.oschina.net/translate/comparative_analysis_between_spring_aop_and_aspectj" target="_blank" rel="external">https://www.oschina.net/translate/comparative_analysis_between_spring_aop_and_aspectj</a></p>
</blockquote>
<p>你一定希望使用一种易于实现的方式。因为Spring AOP支持注解，在使用@Aspect注解创建和配置方面时将更加方便。<br>而使用AspectJ，你就需要通过.aj文件来创建方面，并且需要使用ajc（Aspect编译器）来编译代码。<br>所以如果你确定之前提到的限制不会成为你的项目的障碍时，使用Spring AOP。</p>
<p>使用AspectJ的一个间接局限是，因为AspectJ通知可以应用于POJO之上，它有可能将通知应用于一个已配置的通知之上。<br>对于一个你没有注意到这方面问题的大范围应用的通知，这有可能导致一个无限循环。</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-genericdao.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-genericdao.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 基本问题]]></title>
      <url>http://liugch.top/2017/01/03/Java%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="Java-基本问题"><a href="#Java-基本问题" class="headerlink" title="Java 基本问题"></a>Java 基本问题</h1><blockquote>
<p>六大设计模式</p>
</blockquote>
<a id="more"></a>
<p> 单一职责原则主要说明类的职责要单一；</p>
<p> 里氏替换原则强调不要破坏继承体系；</p>
<p> 依赖倒置原则描述要面向接口编程；</p>
<p> 接口隔离原则讲解设计接口的时候要精简；</p>
<p> 迪米特法则告诉我们要降低耦合；</p>
<p> 开闭原则讲述的是对扩展开放，对修改关闭。</p>
<p>数据的逻辑结构分两大类：<strong>线性结构 和 非线性结构 </strong></p>
<p>数据的存储方法有四种：顺序存储方法 、 链接存储方法 、 索引存储方法、 散列存储方法 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Thread]]></title>
      <url>http://liugch.top/2017/01/02/Java%20Thread%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Java Thread 笔记</p>
</blockquote>
<a id="more"></a>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git 的基本使用]]></title>
      <url>http://liugch.top/2017/01/01/Git%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="git-的相关操作"><a href="#git-的相关操作" class="headerlink" title="git 的相关操作"></a>git 的相关操作</h1><p>Git 的基本使用</p>
<p>一个教程网站 <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git 廖雪峰 教程</a> </p>
<blockquote>
<p>取别名 </p>
</blockquote>
<p><strong>局部</strong></p>
<p>git config alias.st status</p>
<p><strong>全局</strong></p>
<p>git config –global alias.st status</p>
<blockquote>
<p>初始化</p>
</blockquote>
<p>git init  </p>
<blockquote>
<p>添加到本地缓存中</p>
</blockquote>
<p>git add . </p>
<blockquote>
<p>从索引写入到库</p>
</blockquote>
<p>git commit -m “提交到版本库”</p>
<p>git commit -a -m “提交，连同所有未 add 的修改文件”</p>
<p>git commit –amend -a -m “替换最后一次的提交信息”</p>
<blockquote>
<p>从git仓库中克隆下来</p>
</blockquote>
<p>git clone <a href="https://github.com/liugch/SSH.git" target="_blank" rel="external">https://github.com/liugch/SSH.git</a></p>
<blockquote>
<p>更新本地仓库</p>
</blockquote>
<p>git pull</p>
<blockquote>
<p>提交到github 仓库中</p>
</blockquote>
<p>git push</p>
<blockquote>
<p> 查看修改了什么东西</p>
</blockquote>
<p>git diff</p>
<p>git diff –cached</p>
<p>git status</p>
<blockquote>
<p> 查看日志，历史记录</p>
</blockquote>
<p>git show</p>
<p>git log</p>
<p>git log –pretty=oneline  # 定制 log 的显示样式</p>
<p>git log -2 -p             # 显示最近两次提交的详细信息</p>
<p>git log –stat –summary  # 简要显示每次更新的统计信息（提交过那些文件，有多少行修改）</p>
<blockquote>
<p> 增加/查看/切换/删除 分支</p>
</blockquote>
<p>git branch                # 查看分支</p>
<p>git branch hehe           # 创建分支 hehe</p>
<p>git branch hehe 22222    # 以 22222 为起点创建 hehe 分支</p>
<p>git checkout hehe         # 切换到分支 hehe</p>
<p>git checkout -b tmp       # 创建并切换到分支 tmp</p>
<p>git branch -D tmp         # 删除分支 tmp</p>
<blockquote>
<p> 合并工作到主分支(hehe -&gt; master)</p>
</blockquote>
<p>git checkout master       # 切换到主分支</p>
<p>git merge HEAD hehe       # 将 hehe 的最新版本合并到当前分支</p>
<p>git pull . hehe           # 相当于 git fetch &amp;&amp; git merge</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mabatis基本使用]]></title>
      <url>http://liugch.top/2017/01/01/Mybatis%20%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h1 id="Mabatis基本使用"><a href="#Mabatis基本使用" class="headerlink" title="Mabatis基本使用"></a>Mabatis基本使用</h1><blockquote>
<p>Mabatis 表与实体的映射关系</p>
</blockquote>
<p><a href="http://www.cnblogs.com/xdp-gacl/p/4264440.html" target="_blank" rel="external">http://www.cnblogs.com/xdp-gacl/p/4264440.html</a></p>
<a id="more"></a>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC 相关笔记]]></title>
      <url>http://liugch.top/2016/11/28/Springmvc%20%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="SpringMVC-相关笔记"><a href="#SpringMVC-相关笔记" class="headerlink" title="SpringMVC 相关笔记"></a>SpringMVC 相关笔记</h1><p><a href="http://45.32.42.177:3000/" target="_blank" rel="external">http://45.32.42.177:3000/</a></p>
<p>求职问题:<a href="http://arts.51job.com/arts/05/283697.html" target="_blank" rel="external">http://arts.51job.com/arts/05/283697.html</a></p>
<a id="more"></a>
<p>jrebel 激活 <a href="http://blog.csdn.net/xiangxueping80/article/details/44487045" target="_blank" rel="external">http://blog.csdn.net/xiangxueping80/article/details/44487045</a></p>
<p>SpringMVC 异常的处理 <a href="http://blog.csdn.net/rj042/article/details/7380442" target="_blank" rel="external">http://blog.csdn.net/rj042/article/details/7380442</a></p>
<p>JSR-303 验证  <a href="http://jinnianshilongnian.iteye.com/blog/1733708" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/1733708</a><br>主要的验jsr 验证都在这里; </p>
<p>SpringMVC 拦截器 <a href="http://www.cnblogs.com/HD/p/4127873.html" target="_blank" rel="external">http://www.cnblogs.com/HD/p/4127873.html</a></p>
<p>SpringMVC 图片的上传并显示 <a href="http://blog.csdn.net/luckey_zh/article/details/46867957" target="_blank" rel="external">http://blog.csdn.net/luckey_zh/article/details/46867957</a></p>
<p>IDEA 连接数据库是遇到的问题:  <a href="https://segmentfault.com/q/1010000005020300" target="_blank" rel="external">https://segmentfault.com/q/1010000005020300</a></p>
<blockquote>
<p>IDEA Hibernate连接MYSQL失败提示时区错误该怎么解决？</p>
</blockquote>
<p>在 connection.url 值的后面追加 </p>
<p>?serverTimezone=UTC</p>
<p>题主可以在 mysql 中执行命令试下：</p>
<p>set global time_zone=’+8:00’</p>
<blockquote>
<p> @ResponseBody  and @RequestBody 的使用</p>
</blockquote>
<p>一般是 配合ajax 使用的</p>
<p>如:</p>
<pre><code>&lt;button id=&quot;btn&quot;&gt;requestBody 和 responsebody&lt;/button&gt;
&lt;script&gt;
    $(&quot;#btn&quot;).click(function () {
        alert(23);
        var i = {&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 20};
        $.ajax({
            method: &apos;post&apos;,
            url: &apos;/index2&apos;,
            data: JSON.stringify(i),
            contentType: &apos;application/json&apos;,
            success: function (data) {
                alert(data.name);
            }

        });
    });
&lt;/script&gt;--%&gt;

@RequestMapping(&quot;/index2&quot;)
@ResponseBody
public Person index2(@RequestBody Person person) {
    //Log.getLogger().logger.info(name+&quot;=================&quot;);
    person.setAge(100);
    return person;
}*/                                                     
</code></pre><blockquote>
<p>SpringMVC 验证器 的三种使用</p>
</blockquote>
<p><strong>第一种 原始用法:</strong></p>
<pre><code>@RequestMapping(&quot;/index2&quot;)
public String index2(Person person, Errors errors) {
    if(person.getAge()&gt;120||person.getAge()&lt;18){
        errors.rejectValue(&quot;age&quot;,null,&quot;年龄要在18-120 之间&quot;);
    }
    if(errors.hasErrors()){
        return &quot;index&quot;;
    }
    return &quot;false&quot;;
}
</code></pre><p><strong>第二种 自定义验证器</strong></p>
<pre><code>public class PersonValidator implements Validator {
    @Override
    public boolean supports(Class&lt;?&gt; clazz) {
        return clazz== Person.class;
    }

    @Override
    public void validate(Object target, Errors errors) {
        Person person =(Person) target;
        if(person.getAge()&gt;120||person.getAge()&lt;18){
            errors.reject(null,&quot;年龄要在18-120 之间&quot;);
        }
    }
}

@InitBinder
protected void init(DataBinder dataBinder) {
    dataBinder.setValidator(new PersonValidator());
}
@RequestMapping(&quot;/index2&quot;)
public String index2(@Validated Person person, Errors errors) {
    if (errors.hasErrors()) {
        return &quot;index&quot;;
    }
    return &quot;false&quot;;
}
</code></pre><p><strong>上面的也可以定义成全局的验证器</strong></p>
<pre><code>&lt;mvc:annotation-driven validator=&quot;userValidator&quot; /&gt;
&lt;bean name=&quot;userValidator&quot; class=&quot;app.liugch.validator.PersonValidator&quot; /&gt;
</code></pre><p><strong>第三种 JSR 303 验证</strong></p>
<p>导入相关的jar包 gradle 中:  “org.hibernate:hibernate-validator:$hibernateVersion”<br>在Model 实体类中使用相关的注解就行了</p>
<pre><code>public class Person implements Serializable {
    @NotEmpty(message = &quot;邮箱不能为空!&quot;)
    /*@Pattern(regexp = &quot;^([a-z0-9A-Z]+[-|\\\\.]?)+[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\\\.)+[a-zA-Z]{2,}$&quot;)*/
    @Email(message = &quot;邮箱格式错误!&quot;)
    private String name;


    @NotNull
    @Range(min = 18,max = 120,message = &quot;年龄要在18-20岁之间&quot;)
    private int age;
    /*
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)*/
    private Date birth;
}


/**
 * jsr 303 验证
 * @param person
 * @param errors
 * @return
 */
@RequestMapping(&quot;/index2&quot;)
public String index2(@Valid Person person, Errors errors) {
    if (errors.hasErrors()) {
        return &quot;index&quot;;
    }
    return &quot;fail&quot;;
}
</code></pre><blockquote>
<p>转换器<br>日期转换器</p>
</blockquote>
<p><strong>第一种方法：利用内置的 CustomDateEditor</strong></p>
<p>在Controller 中配置使用:</p>
<pre><code>@InitBinder
public void init (WebDataBinder binder) {
    CustomDateEditor dateEditor = new CustomDateEditor(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;), true);
    binder.registerCustomEditor(Date.class, dateEditor);
}
</code></pre><p>在要使用的地方 添加 @valid</p>
<p><strong>第二种方法:自定义转换器 converter</strong></p>
<pre><code>public class DateConverter implements Converter&lt;String, Date&gt; {

    @Override
    public Date convert(String source) {
       /* SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try {
            Date  d= sdf.parse(source);
            return d;
        } catch (ParseException e) {
            e.printStackTrace();
        }*/

        // String dateString = DateFormatUtils.formatString(source);
        SimpleDateFormat sdf = null;
        if (source != null &amp;&amp; source.trim().equals(&quot;&quot;)) {
            return null;
        } else {
            source = source.replace(&quot;-&quot;, &quot;&quot;).replace(&quot;:&quot;, &quot;&quot;).replace(&quot;/&quot;, &quot;&quot;).replace(&quot; &quot;,&quot;&quot;);
            int length = source.length();
            try {
                if (length == 8) {
                    sdf = format(&quot;yyyyMMdd&quot;);
                    return sdf.parse(source);

                } else if (length == 6) {
                    sdf = format(&quot;yyyyMM&quot;);
                    return sdf.parse(source);
                } else if (length == 14) {
                    sdf = format(&quot;yyyyMMddHHmmss&quot;);
                    return sdf.parse(source);
                } else {
                    return null;
                }
            } catch (ParseException e) {
                e.printStackTrace();
            }

        }


        return null;
    }

    /**
     * 不同 format
     *
     * @param pattern
     * @return
     */
    public SimpleDateFormat format(String pattern) {
        SimpleDateFormat sdf = null;
        if (pattern == null &amp;&amp; pattern.trim().equals(&quot;&quot;)) {
            sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        } else {
            sdf = new SimpleDateFormat(pattern);
        }
        return sdf;
    }
}
</code></pre><p>在配置文件中配置使用:</p>
<pre><code>&lt;!--全局转换器--&gt;
&lt;!-- 定义全局的转换服务，可以配置多个转换器 --&gt;
&lt;!-- 在这里，只配置了我们自定义的转换器，DateConverter --&gt;
&lt;!--&lt;mvc:annotation-driven conversion-service=&quot;myconversionService&quot;/&gt;
&lt;bean id=&quot;myconversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;converters&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;app.liugch.converter.DateConverter&quot;/&gt;
        &lt;/set&gt;
    &lt;/property&gt;

&lt;/bean&gt;--&gt;
</code></pre><p><strong>第三种方法:利用 注解的方式 </strong></p>
<p>如:日期转换</p>
<p>@DateTimeFormat(pattern = “yyyy-MM-dd”)</p>
<blockquote>
<p> SpringMVC Interceptor 拦截器 的使用:</p>
</blockquote>
<p>可以有两种方法: </p>
<p>分别实现</p>
<p>HandlerInterceptor(有更多的操作)<br>WebRequestInterceptor(更加的方便)</p>
<p>先自定义拦截器</p>
<pre><code>public class MyInterceptor implements WebRequestInterceptor {
    @Override
    public void preHandle(WebRequest request) throws Exception {
        System.out.println(&quot;my:pre&quot;);
    }

    @Override
    public void postHandle(WebRequest request, ModelMap model) throws Exception {
        System.out.println(&quot;my:post&quot;);
    }

    @Override
    public void afterCompletion(WebRequest request, Exception ex) throws Exception {
        System.out.println(&quot;my:complete&quot;);
    }
}

public class LoginInterceptor implements HandlerInterceptor {
    //在执行 Controller 相应 handler 之前要执行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;login:pre&quot;);
        return true;
    }

    //执行完 handler，进入 render 页面渲染前的阶段执行
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;login:post&quot;);
    }

    //所有的东西都做完，退出前执行。主要用来做一些清理工作
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(&quot;login:complete&quot;);
    }
}
</code></pre><p>在配置文件中配置</p>
<pre><code>&lt;!--拦截器--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/post/*&quot;/&gt;
        &lt;bean class=&quot;app.liugch.Interceptor.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;

    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/user/*&quot;/&gt;
        &lt;bean class=&quot;app.liugch.Interceptor.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre><p>如果请求:<a href="http://localhost:8080/post/message" target="_blank" rel="external">http://localhost:8080/post/message</a> 就会被 MyInterceptor 拦截器拦截  </p>
<p>如果请求:<a href="http://localhost:8080/user/index" target="_blank" rel="external">http://localhost:8080/user/index</a> 就会被 LoginInterceptor 拦截器拦截  </p>
<blockquote>
<p> SpringMVC 异常处理</p>
</blockquote>
<p><strong>第一:使用自定义的异常处理</strong></p>
<p>1.定义异常处理类</p>
<p>2.在交给Spring 来管理(可以使用<bean> 也可以使用 注解方式@component) </bean></p>
<pre><code>/**
 * 异常处理类
 */
public class MyException implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {

        if(ex instanceof IOException){
            return new ModelAndView(&quot;ioexp&quot;);
        }else if(ex instanceof SQLException){
            return new ModelAndView(&quot;sqlexp&quot;);
        }else{
            return new ModelAndView(&quot;error&quot;);
        }
    }
}
</code></pre><p><strong>内置的异常处理</strong></p>
<pre><code>  &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
    &lt;!-- 定义默认的异常处理页面，当该异常类型的注册时使用 --&gt;
    &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;&gt;&lt;/property&gt;
    &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;
    &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;
    &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt;
    &lt;property name=&quot;exceptionMappings&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;IOException&quot;&gt;ioexp&lt;/prop&gt;
            &lt;prop key=&quot;java.sql.SQLException&quot;&gt;sqlexp&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p><strong>使用注解的方式</strong></p>
<p>一般使全部的 Controller 都可以使用异常处理,所以 另外 单独定义一个 ExceptionController 类 处理异常;</p>
<p>其中用到一个<strong>@ControllerAdvice</strong> 注解 </p>
<p>作用: 让所有的Controller 都可以使用其中异常处理</p>
<p>使用: 一般都是和</p>
<p><strong>@ExceptionHandler </strong>  自定义的错误处理器</p>
<p><strong>@ModelAttribute</strong>      全局的对所有的controller的Model添加属性</p>
<p><strong>@InitBinder </strong> 对表单数据绑定</p>
<pre><code>@Controller
@ControllerAdvice
public class ExecptionController {
    /*
        @ExceptionHandler({IOException.class,RuntimeException.class})
        public String error(Exception ex, Model model) {
            return &quot;error&quot;;
        }
    */
    @ExceptionHandler
    public String error(Exception ex, Model model) {
        model.addAttribute(&quot;error&quot;, ex);
        return &quot;error&quot;;
    }

    @ExceptionHandler
    public String error2(MyExecption ex, Model model) {
        model.addAttribute(&quot;error&quot;, ex);
        return &quot;error&quot;;
    }
}

class MyExecption extends Exception {

}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 文件地址与缓存]]></title>
      <url>http://liugch.top/2016/11/01/Android_%E6%96%87%E4%BB%B6%E7%9A%84%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h1 id="文件地址与缓存"><a href="#文件地址与缓存" class="headerlink" title="文件地址与缓存"></a>文件地址与缓存</h1><blockquote>
<p>getCacheDir()、getFilesDir()、getExternalFilesDir()、getExternalCacheDir()</p>
<p> 低版本时所需要的权限 在AndroidManifest文件中加入sdcard操作权限</p>
</blockquote>
<a id="more"></a>
<pre><code>&lt;uses-permission Android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;

&lt;!--在SDCard中创建与删除文件权限 --&gt;
&lt;uses-permissioandroid:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt; 
&lt;!--往SDCard写入数据权限 --&gt; 
　　 &lt;uses-permissionandroid:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 
</code></pre><ul>
<li>2 确认sdcard的存在<br>　　* android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED)</li>
<li>3 获取扩展存储设备的文件目录<br>　　* android.os.Environment.getExternalStorageDirectory();</li>
</ul>
<p><strong>本机</strong></p>
<p>getCacheDir():方法用于获取/data/data/<application package="">/cache目录</application></p>
<p>getFilesDir():方法用于获取/data/data/<application package="">/files目录</application></p>
<p><strong>SD开</strong></p>
<p>Context.getExternalFilesDir():方法可以获取到 SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据</p>
<p><strong>context.getExternalFilesDir(null)::/storage/emulated/0/Android/data/com.main.app.zxingdemo/files</strong></p>
<p><strong>getExternalFilesDir().getAbsolutePath:: /storage/emulated/0/Android/data/com.main.app.zxingdemo/files</strong></p>
<p>Context.getExternalCacheDir():方法可以获取到 SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据</p>
<p>如果使用上面的方法，当你的应用在被用户卸载后，SDCard/Android/data/你的应用的包名/ 这个目录下的所有文件都会被删除，不会留下垃圾信息。</p>
<p>而且上面二个目录分别对应-&gt;应用详情里面的”清除数据“与”清除缓存“选项</p>
<blockquote>
<p>一个获取缓存路劲的方法</p>
</blockquote>
<pre><code>/**
 * 一个方法来获取缓存地址
 * @param context
 * @return
 */
public String getDiskCacheDir(Context context) {
    String cachePath = null;
    if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
            || !Environment.isExternalStorageRemovable()) {
        cachePath = context.getExternalCacheDir().getPath();
    } else {
        cachePath = context.getCacheDir().getPath();
    }
    return cachePath;
}
</code></pre><blockquote>
<p>获取文件保存路径</p>
</blockquote>
<pre><code>/**
 *  获取文件保存的路劲
 * @param context
 * @return
 */
private String getFileRoot(Context context) {
    //判断sd卡是否存在也就是是否正常挂载
    if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
        File external = context.getExternalFilesDir(null);
        if (external != null) {
            // /storage/emulated/0/Android/data/com.main.app.zxingdemo/files
            return external.getAbsolutePath();
        }
    }
    ///data/data/com.main.app.zxingdemo/files
    return context.getFilesDir().getAbsolutePath();
}
</code></pre><blockquote>
<p>其它文件路径</p>
</blockquote>
<pre><code> Environment.getDataDirectory();
Environment.getDownloadCacheDirectory();
Environment.getExternalStorageDirectory();
Environment.getExternalStoragePublicDirectory(&quot;test&quot;);
Environment.getRootDirectory();
getPackageCodePath();
getPackageResourcePath();
getCacheDir() ;
getDatabasePath(&quot;test&quot;) ;
getDir(&quot;test&quot;, Context.MODE_PRIVATE) ;
getExternalCacheDir() ;
getExternalFilesDir(&quot;test&quot;);
getExternalFilesDir(null);
getFilesDir();
</code></pre><p><strong>执行后结果为:</strong></p>
<p><img src="http://i.imgur.com/agjdjCS.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate]]></title>
      <url>http://liugch.top/2016/11/01/Hibernate/</url>
      <content type="html"><![CDATA[<h1 id="Hibernate工作原理及为什么要用"><a href="#Hibernate工作原理及为什么要用" class="headerlink" title="Hibernate工作原理及为什么要用?"></a>Hibernate工作原理及为什么要用?</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>1.通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件<br>2.由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml">读取并解析映射信息<br>3.通过config.buildSessionFactory();//创建SessionFactory<br>4.sessionFactory.openSession();//打开Sesssion<br>5.session.beginTransaction();//创建事务Transation<br>6.persistent operate持久化操作<br>7.session.getTransaction().commit();//提交事务<br>8.关闭Session<br>9.关闭SesstionFactory<br><a id="more"></a></mapping></p>
<h2 id="为什么要用："><a href="#为什么要用：" class="headerlink" title="为什么要用："></a>为什么要用：</h2><ol>
<li><p>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p>
</li>
<li><p>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的        编码工作</p>
</li>
<li><p>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</p>
</li>
<li><p>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，    从一对一到多对多的各种复杂关系。</p>
</li>
</ol>
<blockquote>
<p>Hibernate是如何延迟加载?</p>
</blockquote>
<ol>
<li><p>Hibernate2延迟加载实现：a)实体对象 b)集合（Collection）</p>
</li>
<li><p>Hibernate3 提供了属性的延迟加载功能</p>
</li>
</ol>
<p>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</p>
<blockquote>
<p>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)</p>
</blockquote>
<p>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</p>
<h2 id="说下Hibernate的缓存机制"><a href="#说下Hibernate的缓存机制" class="headerlink" title="说下Hibernate的缓存机制"></a>说下Hibernate的缓存机制</h2><ol>
<li><p>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</p>
</li>
<li><p>二级缓存：</p>
<p>a) 应用及缓存 </p>
<p>b) 分布式缓存<br>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非 关键数据<br>c) 第三方缓存的实现</p>
</li>
</ol>
<p><strong>一级缓存：session级的缓存也叫事务级的缓存，只缓存实体，生命周期和session一致。不能对其进行管理。不用显示的调用</strong>。</p>
<p><strong>二级缓存：sessionFactory缓存，也叫进程级的缓存，使用第3方插件实现的，也值缓存实体，生命周期和sessionFactory一致，可以进行管理。</strong></p>
<p>首先配置第3放插件，我们用的是EHCache，在hibernate.cfg.xml文件中加入</p>
<pre><code>&lt;property name=&quot;hibernate.cache.user_second_level_cache&quot;&gt;true&lt;/property&gt;
</code></pre><p>在映射中也要显示的调用<br>    <cache usage="read-only"></cache></p>
<p>二</p>
<blockquote>
<p>级缓存之查询缓存：对普通属性进行缓存。如果关联的表发生了修改，那么查询缓存的生命周期也结束了。</p>
</blockquote>
<p><strong>在程序中必须手动启用查询缓存：query.setCacheable(true);</strong></p>
<blockquote>
<p>Hibernate的查询方式     Sql、Criteria,object comptosition</p>
<p>Hql：</p>
</blockquote>
<p>1、 属性查询<br>2、 参数查询、命名参数查询<br>3、 关联查询<br>4、 分页查询<br>5、 统计函数</p>
<h2 id="如何优化Hibernate？"><a href="#如何优化Hibernate？" class="headerlink" title="如何优化Hibernate？"></a><strong>如何优化Hibernate？</strong></h2><p>1.使用双向一对多关联，不使用单向一对多</p>
<p>2.灵活使用单向一对多关联</p>
<p>3.不用一对一，用多对一取代</p>
<p>4.配置对象缓存，不使用集合缓存</p>
<p>5.一对多集合使用Bag,多对多集合使用Set</p>
<p>6.继承类使用显式多态</p>
<p>7.表字段要少，表关联不要怕多，有二级缓存撑腰</p>
<blockquote>
<p>Hibernate有哪几种查询数据的方式</p>
</blockquote>
<p>  (1)导航对象图查询</p>
<p>  (2)OID查询</p>
<p>  (3)HQL</p>
<p>  (4)QBC</p>
<p>  (5)本地SQL</p>
<h2 id="load-和get-的区别"><a href="#load-和get-的区别" class="headerlink" title="load()和get()的区别"></a><strong>load()和get()的区别</strong></h2><p>Session.load/get方法均可以根据指定的实体类和id从数据库读取记录，并返回与之对应的实体对象。</p>
<p>如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObjectNotFoundException。<br>Load方法可返回实体的代理类实例，而get方法永远直接返回实体类。<br>load方法可以充分利用内部缓存和二级缓存中的现有数据，<br>而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，<br>直接调用SQL完成数据读取。</p>
<p>/<em>
  </em>load()方法的执行顺序如下：<br>  <em>a)：首先通过id在session缓存中查找对象，如果存在此id的对象，直接将其返回
  </em>b)：在二级缓存中查找，找到后将 其返回。<br>  <em>c)：如果在session缓存和二级缓存中都找不到此对象，则从数据库中加载有此ID的对象
  </em>因此load()方法并不总是导致SQL语句，只有缓存中无此数据时，才向数据库发送SQL！<br>  */</p>
<p> /<em>
  </em>与get()的区别：<br>  <em>1：在立即加载对象（当hibernate在从数据库中取得数据组装好一个对象后
  </em>会立即再从数据库取得数据此对象所关联的对象）时，如果对象存在，<br>  <em>load()和get()方法没有区别，都可以取得已初始化的对象;但如果当对
  </em>象不存在且是立即加载时，使用get()方法则返回null,而使用load()则<br>  <em>抛出一个异常。因此使用load()方法时，要确认查询的主键ID一定是存在
  </em>的，从这一点讲它没有get方便！<br>  <em>2：在延迟加载对象(Hibernate从数据库中取得数据组装好一个对象后，
  </em>不会立即再从数据库取得数据组装此对象所关联的对象，而是等到需要时，<br>  <em>都会从数据库取得数据组装此对象关联的对象)时，get()方法仍然使用
  </em>立即加载的方式发送SQL语句，并得到已初始化的对象，而load()方法则<br>  <em>根本不发送SQL语句，它返回一个代理对象，直到这个对象被访问时才被
  </em>初始化。<br>  */</p>
<p>get()—-不支持LAZY</p>
<p>load()—-支持LAZY</p>
<p>总之对于get和load的根本区别，一句话，hibernate对于load方法认为该数据在数据库中一定存在，<br>可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；<br>而对于get方法，hibernate一定要获取到真实的数据，否则返回null。<br>get方法首先查询session缓存，没有的话查询二级缓存，最后查询数据库；<br>反而load方法创建时首先查询session缓存，没有就创建代理，实际使用数据时才查询二级缓存和数据库</p>
<blockquote>
<p>引用链接</p>
</blockquote>
<p><a href="http://sishuok.com/forum/blogPost/list/2936.html" target="_blank" rel="external">http://sishuok.com/forum/blogPost/list/2936.html</a><br><a href="http://www.cnblogs.com/javaNewegg/archive/2011/08/28/2156521.html" target="_blank" rel="external">http://www.cnblogs.com/javaNewegg/archive/2011/08/28/2156521.html</a><br><a href="http://blog.csdn.net/zhaoshl_368/article/details/6577103" target="_blank" rel="external">http://blog.csdn.net/zhaoshl_368/article/details/6577103</a></p>
<h2 id="hibernate-主键生成策略"><a href="#hibernate-主键生成策略" class="headerlink" title="hibernate 主键生成策略"></a>hibernate 主键生成策略</h2><pre><code>&lt;id name=&quot;id&quot; length=&quot;22&quot; &gt;
    &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;
&lt;/id&gt;
</code></pre><p><a href="http://www.cnblogs.com/xlwmin/articles/2189427.html" target="_blank" rel="external">http://www.cnblogs.com/xlwmin/articles/2189427.html</a></p>
<blockquote>
<p>注意:<br>    在HQL,您应该使用映射的java类名和属性名@ entity,而不是实际的表名和列名<br>List&lt;?&gt; result = session.createQuery(“from Student”).list();</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Struts2 中一些配置]]></title>
      <url>http://liugch.top/2016/10/29/Struts2%20%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="Struts2-中的一些简单的配置"><a href="#Struts2-中的一些简单的配置" class="headerlink" title="Struts2 中的一些简单的配置"></a>Struts2 中的一些简单的配置</h1><h3 id="在web-xml-中"><a href="#在web-xml-中" class="headerlink" title="在web.xml 中:"></a>在web.xml 中:</h3><pre><code>&lt;filter&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><a id="more"></a>
<h3 id="在Struts-xml-中"><a href="#在Struts-xml-中" class="headerlink" title="在Struts.xml 中:"></a>在Struts.xml 中:</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE struts PUBLIC
    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;
&lt;struts&gt;
    &lt;!-- 动态方法调用,一般都是为 false --&gt;
    &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot; /&gt;
    &lt;!-- 是否启用开发者模式 --&gt;
    &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt;

    &lt;package name=&quot;hehe&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;
        &lt;!--默认的要到的位置  --&gt;
        &lt;!-- &lt;default-action-ref name=&quot;index&quot; /&gt; --&gt;


        &lt;!-- 什么异常 对应的 --&gt;
        &lt;global-exception-mappings&gt;
            &lt;exception-mapping exception=&quot;java.lang.Exception&quot; result=&quot;error&quot;/&gt;
        &lt;/global-exception-mappings&gt;

        &lt;!-- 全局错误页面 --&gt;
        &lt;global-results&gt;
            &lt;result name=&quot;error&quot;&gt;/WEB-INF/jsp/error.jsp&lt;/result&gt;
        &lt;/global-results&gt;

      &lt;!--&lt;action name=&quot;index&quot;&gt;
            &lt;result type=&quot;redirectAction&quot;&gt;
                &lt;param name=&quot;actionName&quot;&gt;HelloWorld&lt;/param&gt;
                &lt;param name=&quot;namespace&quot;&gt;/example&lt;/param&gt;
            &lt;/result&gt;
        &lt;/action&gt; --&gt;

    &lt;/package&gt;

    &lt;include file=&quot;student.xml&quot;/&gt;
&lt;/struts&gt;
</code></pre><h3 id="Struts中表单的验证"><a href="#Struts中表单的验证" class="headerlink" title="Struts中表单的验证"></a>Struts中表单的验证</h3><p><img src="http://i.imgur.com/HAIFjK5.png" alt="验证格式图"></p>
<p>UserAction-loginSubmit-validation.xml</p>
<p><strong>UserAction:action 类名;loginSubmit:该类中的方法名;validation:必须这个结尾;</strong></p>
<p><strong>如果没有loginSubmit:说明UserAction 中的所用的方法都会验证;</strong></p>
<blockquote>
<p>验证的规则我们可以看文档;下载下来的 Struts中就有,下面一些简单的例子;</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE validators PUBLIC
    &quot;-//Apache Struts//XWork Validator 1.0.3//EN&quot;
    &quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&quot;&gt;    

&lt;validators&gt;
    &lt;!-- 与页面form表单对应的 name 的值 --&gt;
    &lt;field name=&quot;uname&quot;&gt;
        &lt;field-validator type=&quot;requiredstring&quot;&gt;
            &lt;param name=&quot;trim&quot;&gt;true&lt;/param&gt;  
            &lt;message&gt;用户名不能为空！&lt;/message&gt;
        &lt;/field-validator&gt;

        &lt;field-validator type=&quot;regex&quot;&gt;
            &lt;!-- param name值为：regex：正则表达式  --&gt;
            &lt;param name=&quot;regex&quot;&gt;&lt;![CDATA[(\w{5,})]]&gt;&lt;/param&gt;
            &lt;message&gt;长度要大于5位！&lt;/message&gt;
        &lt;/field-validator&gt;    
    &lt;/field&gt;

    &lt;field name=&quot;upwd&quot;&gt;
        &lt;field-validator type=&quot;requiredstring&quot;&gt;
            &lt;param name=&quot;trim&quot;&gt;true&lt;/param&gt;
            &lt;message&gt;密码不能为空！&lt;/message&gt;
        &lt;/field-validator&gt;

        &lt;field-validator type=&quot;regex&quot;&gt;
            &lt;param name=&quot;regex&quot;&gt;&lt;![CDATA[(^\w*$)]]&gt;&lt;/param&gt;
            &lt;message&gt;密码不合理含有非法字符&lt;/message&gt;
        &lt;/field-validator&gt;

        &lt;field-validator type=&quot;stringlength&quot;&gt;
            &lt;param name=&quot;minLength&quot;&gt;6&lt;/param&gt;
            &lt;param name=&quot;maxLength&quot;&gt;16&lt;/param&gt;
            &lt;message&gt;&lt;![CDATA[密码必须在6到16之间]]&gt;&lt;/message&gt;
        &lt;/field-validator&gt;

    &lt;/field&gt;
    &lt;field name=&quot;reupwd&quot;&gt;
        &lt;field-validator type=&quot;fieldexpression&quot;&gt;
               &lt;param name=&quot;expression&quot;&gt;&lt;![CDATA[reupwd==upwd]]&gt;&lt;/param&gt;
               &lt;message&gt;密码不一致！&lt;/message&gt;
         &lt;/field-validator&gt;
    &lt;/field&gt;

    &lt;field name=&quot;birth&quot;&gt;
        &lt;field-validator type=&quot;date&quot;&gt;
            &lt;param name=&quot;min&quot;&gt;2015-1-1&lt;/param&gt;
            &lt;param name=&quot;max&quot;&gt;2016-12-12&lt;/param&gt;
            &lt;message&gt;日期范围有误！请重新输入!&lt;/message&gt;
        &lt;/field-validator&gt;
    &lt;/field&gt;
&lt;/validators&gt;
</code></pre><p><strong>Make sure there is a result for “input” listed in the struts.xml for when the validation fails:</strong></p>
<p><strong>一定要在Struts.xml 写入 action中 result 名为:input 的返回页面,不然会报错</strong></p>
<blockquote>
<p>Struts2 中自定义拦截器</p>
</blockquote>
<ol>
<li>写一个类 继承 AbstractInterceptor</li>
<li>在xml 中使用</li>
</ol>
<p>课参考老师笔记 github.com/s126; notes;</p>
<blockquote>
<p>Struts2 中的国际化,ognl表达式,值栈, 获取值栈中的值;  值的获取… 笔记中;;</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SSH 整合笔记]]></title>
      <url>http://liugch.top/2016/10/28/SSH%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>SSH笔记</p>
</blockquote>
<p>rasphone  连接网络</p>
<blockquote>
<p>Spring 的使用教程</p>
</blockquote>
<h2 id="http-wiki-jikexueyuan-com-project-spring"><a href="#http-wiki-jikexueyuan-com-project-spring" class="headerlink" title="http://wiki.jikexueyuan.com/project/spring/ "></a><a href="http://wiki.jikexueyuan.com/project/spring/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/spring/</a> </h2><a id="more"></a>
<blockquote>
<p>Hibernate.initialize(autho.getBook()) 显式 lazy对象</p>
</blockquote>
<hr>
<blockquote>
<p>Struts2 几种获取参数的方法 </p>
<h2 id="https-my-oschina-net-u-1398304-blog-215874"><a href="#https-my-oschina-net-u-1398304-blog-215874" class="headerlink" title="https://my.oschina.net/u/1398304/blog/215874"></a><a href="https://my.oschina.net/u/1398304/blog/215874" target="_blank" rel="external">https://my.oschina.net/u/1398304/blog/215874</a></h2><p>SSH 整合的一些思路及案例</p>
<h2 id="http-blog-csdn-net-zhuanzhe117-article-details-48014545"><a href="#http-blog-csdn-net-zhuanzhe117-article-details-48014545" class="headerlink" title="http://blog.csdn.net/zhuanzhe117/article/details/48014545"></a><a href="http://blog.csdn.net/zhuanzhe117/article/details/48014545" target="_blank" rel="external">http://blog.csdn.net/zhuanzhe117/article/details/48014545</a></h2><p>SpringMVC 的一些配置</p>
<h2 id="https-segmentfault-com-a-1190000005670764-articleHeader7"><a href="#https-segmentfault-com-a-1190000005670764-articleHeader7" class="headerlink" title="https://segmentfault.com/a/1190000005670764#articleHeader7"></a><a href="https://segmentfault.com/a/1190000005670764#articleHeader7" target="_blank" rel="external">https://segmentfault.com/a/1190000005670764#articleHeader7</a></h2><p>SpringMVC 的一些笔记</p>
<h2 id="http-www-imooc-com-article-1392"><a href="#http-www-imooc-com-article-1392" class="headerlink" title="http://www.imooc.com/article/1392"></a><a href="http://www.imooc.com/article/1392" target="_blank" rel="external">http://www.imooc.com/article/1392</a></h2><p>maven 中oracle jar包</p>
</blockquote>
<p>到达下载后的jar包的位置 执行下面语句</p>
<p>mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0 -Dpackaging=jar -Dfile=ojdbc6.jar -DgeneratePom=true </p>
<hr>
<blockquote>
<p>大神的博客</p>
</blockquote>
<h2 id="http-blog-csdn-net-fengshizty-viewmode-list"><a href="#http-blog-csdn-net-fengshizty-viewmode-list" class="headerlink" title="http://blog.csdn.net/fengshizty?viewmode=list"></a><a href="http://blog.csdn.net/fengshizty?viewmode=list" target="_blank" rel="external">http://blog.csdn.net/fengshizty?viewmode=list</a></h2><blockquote>
<p>无法访问服务器</p>
</blockquote>
<p>1.没有部署到服务器中;<br>2.配置中访问地址已经出错;</p>
<blockquote>
<p>防止访问时路径有问题<br>    <base href="${pageContext.request.scheme}://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/"></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring 一些基本的注解的使用]]></title>
      <url>http://liugch.top/2016/10/28/Spring%20%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Spring Bean 的一些配置</p>
</blockquote>
<p><strong>id:</strong> Bean唯一标识</p>
<p><strong>Class:</strong> Bean 对应的Class 类</p>
<p><strong>lazy-init:</strong><br>值为: TRUE / false </p>
<a id="more"></a>
<p>默认为: false</p>
<p>定义这个Bean是否懒初始化(就是用到这个Bean的时候才初始化)</p>
<p><strong>singleton:</strong><br>值为: TRUE / false </p>
<p>默认为: TRUE;</p>
<p>定义这个Bean 是否是单例模式,如果是false的话:每获取该Bean 的时候 都不是同一个Bean实例 ,会重新创建一个;</p>
<h3 id="autowire"><a href="#autowire" class="headerlink" title="autowire:"></a>autowire:</h3><p>值为:<br>byName 根据名字装配</p>
<p>byType    根据类型装配</p>
<p>constructor 根据构造器装配</p>
<p>默认:default no ;</p>
<p>定义这个Bean的时候是否自动注入其它的Bean的实例;</p>
<p>比如autowire=”byName”,<br>如果该Bean对应类中有其它Bean类型的变量时:并且<strong>该变量的属性名 和 xml中定义的某个Bean的id 相同</strong><br>就会把这个Bean自动注入进去</p>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope:"></a>scope:</h3><p>值为:<br>singleton(单例)<br>prototype(重新创建实例) 一般用在Action</p>
<p>request,session,global session 仅用于web中;</p>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract:"></a>abstract:</h3><p>值为: TRUE / false</p>
<p>默认: false;</p>
<p>定义一个Bean是否是抽象Bean, 表示该Bean 不被实例化;</p>
<p><strong>一般用于,一些 属性不会经常改变; 经常会被其它的Bean 给继承;</strong></p>
<h3 id="parent"><a href="#parent" class="headerlink" title="parent:"></a>parent:</h3><p>值为: 其它 Bean的id值;</p>
<p><strong>表示继承对应id的Bean ;</strong></p>
<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on:"></a>depends-on:</h3><p>值为: 其它 Bean的id值;</p>
<p>表示实例化该Bean的时候 , <strong>先实例化和 depends-on值的Bean的实例;</strong></p>
<h3 id="init-method"><a href="#init-method" class="headerlink" title="init-method:"></a>init-method:</h3><p>用来定义Bean的初始化方法，它会在Bean组装之后调用。它必须是一个无参数的方法。 </p>
<h3 id="destroy-method："><a href="#destroy-method：" class="headerlink" title="destroy-method："></a>destroy-method：</h3><p>用来定义Bean的销毁方法，它在BeanFactory关闭时调用。同样，它也必须是一个无参数的方法。它只能应用于singleton Bean。 </p>
<h3 id="factory-method："><a href="#factory-method：" class="headerlink" title="factory-method："></a>factory-method：</h3><p>定义创建该Bean对象的工厂方法。它用于下面的“factory-bean”，表示这个Bean是通过工厂方法创建。此时，“class”属性失效。 </p>
<h3 id="factory-bean"><a href="#factory-bean" class="headerlink" title="factory-bean:"></a>factory-bean:</h3><p>定义创建该Bean对象的工厂类。如果使用了“factory-bean”则“class”属性失效。</p>
<hr>
<blockquote>
<p>如果有很多的xml 可以使用import 导入<br>在集合其它框架整合的时候. 还有其它方式进行导入</p>
</blockquote>
<pre><code>&lt;import resource=&quot;spring-test.xml&quot;/&gt;
</code></pre><blockquote>
<p>当使用注解的时候  需要定义如下:</p>
</blockquote>
<pre><code>&lt;context:component-scan base-package=&quot;com.liugch&quot;&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;com.liugch.entity&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre><blockquote>
<p> 当要加载 其它的配置文件的时候 如:properties 文件时</p>
</blockquote>
<pre><code>&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;
</code></pre><hr>
<blockquote>
<p> Spring 中一些常用的注解</p>
</blockquote>
<p>@Component</p>
<p>@Repository</p>
<p>@Service</p>
<p>@Controller</p>
<p>上面都是一样的作用: 用来 让一个类让Spring容器来管理 , 相当于生成了一个Bean</p>
<p>@Resource</p>
<p>@Autowired</p>
<p>@Qualifier</p>
<p>上面用注入: 一般用 @Resource 就行了</p>
<p>@Scope(“prototype”) </p>
<p>让该类不是使用单例;重新创建新的实例;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Test Junit 基本使用]]></title>
      <url>http://liugch.top/2016/10/28/spring%20junit%20%20%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>IDEA Spring Junit 单元测试</p>
</blockquote>
<p>参考文档：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-springunitest/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-springunitest/</a></p>
<a id="more"></a>
<blockquote>
<p>一些简单注解<br>@BeforeClass</p>
</blockquote>
<p><strong>用来执行整个测试类需要一次性初始化的环境 如加载spring中配置文件</strong></p>
<p>@RunWith </p>
<p><strong>注释标签是 Junit 提供的，用来说明此测试类的运行者，这里用了SpringJUnit4ClassRunner，</strong><br><strong>这个类是一个针对 Junit 运行环境的自定义扩展，用来标准化在 Spring 环境中 Junit4.5 的测试用例，</strong><br><strong>例如支持的注释标签的标准化</strong></p>
<p>@ContextConfiguration </p>
<p><strong>注释标签是 Spring test context 提供的，用来指定 Spring 配置信息的来源</strong></p>
<p>@Transactional </p>
<p><strong>注释标签是表明此测试类的事务启用，这样所有的测试方案都会自动的 rollback，即您不用自己清除自己所做的任何对数据库的变更了</strong></p>
<p>@ActiveProfiles(“test”) </p>
<p><strong>@ActiveProfiles，可以指定一个或者多个 profile，这样我们的测试类就仅仅加载这些名字的 profile 中定义的 bean 实例。</strong></p>
<p>@Repeat(3)</p>
<p><strong>通过 @Repeat，您可以轻松的多次执行测试用例，而不用自己写 for 循环</strong></p>
<hr>
<p><strong>对 TestNG 的支持</strong><br>Spring 2.5 以后，就开始支持 TestNG 了，支持的方法包括：<br>将您的 TestNG 测试<strong>类继承 Spring 的测试父类</strong>：<br>AbstractTransactionalTestNGSpringContextTests 或者 AbstractTestNGSpringContextTests，<br>这样您的 TestNG 测试类内部就可以访问 applicationContext 成员变量了</p>
<p><strong>不继承 Spring 父类</strong>，在测试类上使用<br>@TestExecutionListeners 注释标签，可以引入的监听器包括<br>DependencyInjectionTestExecutionListener：使得测试类拥有依赖注入特性<br>DirtiesContextTestExecutionListener：使得测试类拥有更新 applicationContext 能力<br>TransactionalTestExecutionListener：使得测试类拥有自动的事务管理能力</p>
<hr>
<blockquote>
<p>@Autowired注解、@Resource注解的区别  一般都会用 @Resource</p>
</blockquote>
<p><strong>@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了</strong><br><strong>@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。</strong><br><strong>所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。</strong><br><strong>如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</strong></p>
<blockquote>
<p>hibernate 不同版本的 SchemaExport 区别</p>
</blockquote>
<pre><code> @Test
public void ExportDB() {
    ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();
    Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
    SchemaExport export = new SchemaExport();
    export.create(EnumSet.of(TargetType.DATABASE), metadata);
 /*   // 默认读取hibernate.cfg.xml文件
    Configuration cfg = new Configuration().configure();

    // 生成并输出sql到文件（当前目录）和数据库
    SchemaExport schemaExport = new SchemaExport(cfg);

    // true 在控制台打印sql语句，true 导入sql语句到数据库，即可执行
    schemaExport.create(true, false);*/

/*    ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();

    MetadataImplementor metadataImplementor = (MetadataImplementor)
            new MetadataSources(serviceRegistry).buildMetadata();

    SchemaExport export = new SchemaExport(serviceRegistry, metadataImplementor);
    export.create(true, true);*/
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android WebView 的使用]]></title>
      <url>http://liugch.top/2016/10/25/Android_WebView/</url>
      <content type="html"><![CDATA[<h1 id="WebView-基本使用"><a href="#WebView-基本使用" class="headerlink" title="WebView 基本使用"></a>WebView 基本使用</h1><blockquote>
<p>WebView控件之WebSettings各种配置方法</p>
<p><a href="http://teachcourse.cn/android-webview-websettings" target="_blank" rel="external">http://teachcourse.cn/android-webview-websettings</a></p>
</blockquote>
<a id="more"></a>
<p><strong>设置WebView要显示的网页：</strong></p>
<p>互联网用：webView.loadUrl(“<a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a>“); </p>
<p>本地文件用：webView.loadUrl(“file:///android_asset/XX.html”);  </p>
<p>本地文件存放在：assets文件中</p>
<p><strong>设置WebView是否支持Javascript</strong></p>
<p>如果访问的页面中有JavaScript，则webview必须设置支持Javascript<br>webview.getSettings().setJavaScriptEnabled(true);  </p>
<hr>
<blockquote>
<p>android 各种所需的权限</p>
<p><a href="http://blog.csdn.net/sweetburden2011/article/details/9167353" target="_blank" rel="external">http://blog.csdn.net/sweetburden2011/article/details/9167353</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 自学笔记]]></title>
      <url>http://liugch.top/2016/10/15/Android%20%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="love-android"><a href="#love-android" class="headerlink" title="love android"></a>love android</h1><blockquote>
<p>自学的道路走起….</p>
<p>酷爱的资源网站 受益匪浅 …. </p>
<p>从此爱上了android的世界…</p>
<p>让我们一起踏上生命的航帆,让生命不息….</p>
</blockquote>
<a id="more"></a>
<p>鸿神: <a href="http://www.xueandroid.com/" title="鸿神" target="_blank" rel="external">http://www.xueandroid.com/</a></p>
<p>郭神:<a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">http://blog.csdn.net/guolin_blog</a></p>
<p>生命一号博客: <a href="http://www.cnblogs.com/smyhvae/p/4799730.html" target="_blank" rel="external">http://www.cnblogs.com/smyhvae/p/4799730.html</a></p>
<p>okhttps工具: <a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="external">https://github.com/hongyangAndroid/okhttputils</a></p>
<blockquote>
<p>android 图片的在线制作</p>
</blockquote>
<p><a href="https://romannurik.github.io/AndroidAssetStudio/icons-generic.html#source.type=image&amp;source.space.trim=1&amp;source.space.pad=-0.1&amp;size=24&amp;padding=0&amp;color=33b5e5%2C100&amp;name=ic_hehe" target="_blank" rel="external">https://romannurik.github.io/AndroidAssetStudio/icons-generic.html#source.type=image&amp;source.space.trim=1&amp;source.space.pad=-0.1&amp;size=24&amp;padding=0&amp;color=33b5e5%2C100&amp;name=ic_hehe</a></p>
<blockquote>
<p>图片乱选,OOM 等问题</p>
</blockquote>
<p><a href="http://blog.csdn.net/chinese_zhang/article/details/48470413" target="_blank" rel="external">http://blog.csdn.net/chinese_zhang/article/details/48470413</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/9316683</a></p>
<p><a href="http://blog.csdn.net/gao_chun/article/details/48550117" target="_blank" rel="external">http://blog.csdn.net/gao_chun/article/details/48550117</a></p>
<blockquote>
<p>Axure RP 8 的使用</p>
</blockquote>
<p> <a href="http://flavienlaurent.com/blog/2013/11/20/making-your-action-bar-not-boring/" target="_blank" rel="external">http://flavienlaurent.com/blog/2013/11/20/making-your-action-bar-not-boring/</a></p>
<blockquote>
<p>移动设备原型尺寸计算工具</p>
</blockquote>
<p><a href="http://www.iaxure.com/share/yxcc/" target="_blank" rel="external">http://www.iaxure.com/share/yxcc/</a></p>
<blockquote>
<p>fontawesome 字体的使用</p>
</blockquote>
<p><a href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" target="_blank" rel="external">https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css</a></p>
<blockquote>
<p>SwipeRefreshLayout 的使用，自定义SwipeRefreshLayout</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/d23b42b6360b" target="_blank" rel="external">http://www.jianshu.com/p/d23b42b6360b</a></p>
<blockquote>
<p>Intellij IDEA 的快捷键  同时也是用于andriod studio的快捷键</p>
</blockquote>
<p><a href="http://www.phperz.com/article/15/0923/159042.html" target="_blank" rel="external">http://www.phperz.com/article/15/0923/159042.html</a></p>
<blockquote>
<p>Intellij IDEA 中没有输入后就有 提示功能 问题</p>
</blockquote>
<p>解决： 把 编辑器中的 省电模式给关掉</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android BraodCastReceiver 基本使用]]></title>
      <url>http://liugch.top/2016/09/28/Android%20BraodCastReceiver%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>BroadCastReceiver（广播接受者）<br>用于接收广播，一个广播可以被多个广播接受者所接收<br>自身并不实现图形用户界面，当它收到某个通知后<br>BroadCastReceiver 可以启动Activity 作为相应，<br>或者通过NotificationManager 提醒用户，或者启动Service 等等</p>
<a id="more"></a>
<blockquote>
<p>常见的系统广播</p>
</blockquote>
<p>Android 系统在运行的过程中，会产生很多事件， 比如开机，电量改变，收发短信，拨打电话，屏幕锁屏</p>
<blockquote>
<p>BroadCastReceiver 配置方式</p>
</blockquote>
<p>静态注册：不够灵活，程序退出后还是可以 接收广播<br>第一步，写一个写继承BroadCastReceiver<br>第二步，在Androidmanifest 清单文件中配置<br>拨打电话广播:</p>
<pre><code>/**
 * Created by Administrator on 2017/1/3.
 * 接收打电话的广播接受者
 */

public class CallReceiver extends BroadcastReceiver {
    // 接收信息
    @Override
    public void onReceive(Context context, Intent intent) {
        // 获取电话号码
        String number = getResultData();
        Log.i(TAG, &quot;onReceive:&quot;+number);
        // 改变电话号码
        setResultData(&quot;10086&quot;);
        String number2 = getResultData();
        Log.i(TAG, &quot;onReceive:&quot;+number2);
    }
}

&lt;!--电话权限--&gt;
    &lt;uses-permission android:name=&quot;android.permission.PROCESS_OUTGOING_CALLS&quot;&gt;&lt;/uses-permission&gt;
   &lt;!--电话广播 --&gt;
&lt;receiver android:name=&quot;.Receiver.CallReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.NEW_OUTGOING_CALL&quot;&gt;&lt;/action&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><p>动态注册: 更加的灵活<br>在程序中使用registerReceiver注册。<br>使用unregiesterReciver()方法取消注册。</p>
<blockquote>
<p>一个短息拦截 小案例</p>
<p>参考 <a href="http://blog.csdn.net/qq_26787115/article/details/51113053" target="_blank" rel="external">http://blog.csdn.net/qq_26787115/article/details/51113053</a></p>
</blockquote>
<pre><code>  /**
 * Created by Administrator on 2017/1/4.
 * 接收 短信的广播接收者
 *
 * 短信拦截器
 */
public class SMSReceiver extends BroadcastReceiver {

private static final String TAG =&quot;SMSReceiver&quot; ;
    @RequiresApi(api = Build.VERSION_CODES.M)
    @Override
    public void onReceive(Context context, Intent intent) {

        SmsMessage[] messages= SMSReceiver.getMessagesFromIntent(intent);
        for (SmsMessage message : messages) {
            //获取发件人号码
            String toPhone = message.getOriginatingAddress();
            //获取短信内容
            String smsContent = message.getMessageBody();
            Log.i(&quot;SMSReceiver&quot;, &quot;发件人号码:&quot; + toPhone + &quot;短信内容&quot; + smsContent);

            //判断是否是拦截的号码
            if (toPhone.equals(&quot;12345678910&quot;)) {
                //拦截广播
                abortBroadcast();
            }
        }
    }

    /**
     *  通过意图获取所有的短信信息
     * @param intent
     * @return
     */
    @RequiresApi(api = Build.VERSION_CODES.M)
    public static SmsMessage[] getMessagesFromIntent(Intent intent) {

        Log.i(TAG, &quot;onReceive: &quot; + &quot;收到短信&quot;);
        // 获取短信内容
        Object[] messages = (Object[]) intent.getSerializableExtra(&quot;pdus&quot;);
        String format = intent.getStringExtra(&quot;format&quot;);
        int pduCount = messages.length;
        SmsMessage[] msgs = new SmsMessage[pduCount];

        for (int i = 0; i &lt; pduCount; i++) {
            byte[] pdu = (byte[]) messages[i];
            //把数组元素转换成短信对象
            msgs[i] = SmsMessage.createFromPdu(pdu, format);
        }
        return msgs;
    }

}

 &lt;!--短信权限--&gt;
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;

&lt;!--注册短信广播--&gt;
&lt;receiver android:name=&quot;.Receiver.SMSReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;!--定义接收的广播,被Google隐藏的权限操作--&gt;
        &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><p>这样我们运行之下，你会发现，虽然走到拦截这一步，但是并没有阻止显示在短信收件箱里，这里，我们要注意一个优势，就是广播接收者是有优先级定义的，我们只需要在<strong>清单注册根节点</strong>的intent-filter标签里定义一个</p>
<blockquote>
<p>android:priority=”1000”</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 第三方SDK 遇到的坑]]></title>
      <url>http://liugch.top/2016/09/27/android%E7%AC%AC%E4%B8%89%E6%96%B9SDK%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<h2 id="微博中．．．"><a href="#微博中．．．" class="headerlink" title="微博中．．．"></a>微博中．．．</h2><blockquote>
<p>异常</p>
</blockquote>
<p> AndroidStudio-/vendor/lib, /system/lib]]] couldn’t find “libweibosdkcore.so”</p>
<blockquote>
<p>成功的解决方案</p>
</blockquote>
<a id="more"></a>
<p>导入 下载下来SDK中的 weiboSDKCore_3.1.4.jar 和 libs 下的含有<strong>.so的文件夹</strong>放到libs中,</p>
<p>出现上面的错误,就在和 <strong>main同一级下新建 一个文件夹下,把含有.so的文件夹放入其中</strong>;</p>
<p>然后app 下的 H:\projects\weibo\app\build.gradle 文件中添加如下配置:</p>
<p>最后 <strong>一定要 Sync 一下</strong>;</p>
<pre><code>task nativeLibsToJar(type: Zip, description: &quot;create a jar archive of the native libs&quot;) {
    destinationDir file(&quot;$projectDir/libs&quot;)
    baseName &quot;Native_Libs2&quot;
    extension &quot;jar&quot;
    from fileTree(dir: &quot;libs&quot;, include: &quot;**/*.so&quot;)
    into &quot;lib&quot;
}

tasks.withType(JavaCompile) {
    compileTask -&gt; compileTask.dependsOn(nativeLibsToJar)
}
</code></pre><blockquote>
<p>放入的文件的结构图如下</p>
</blockquote>
<p><img src="http://i.imgur.com/EMXX6Fw.png" alt="结构图"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Menu]]></title>
      <url>http://liugch.top/2016/09/26/Android_menu/</url>
      <content type="html"><![CDATA[<h1 id="Meau"><a href="#Meau" class="headerlink" title="Meau"></a>Meau</h1><blockquote>
<p>选项菜单</p>
<p>上下文菜单</p>
<p>子菜单</p>
<p>Popup弹出菜单</p>
<p>ActionMode 创建导航菜单</p>
</blockquote>
<p>以下小例子都有很多优化的地方</p>
<a id="more"></a>
<p><strong>选项菜单</strong></p>
<p>onCreateOptionsMenu(Menu menu)</p>
<p>onOptionsItemSelected(MenuItem item)</p>
<p><strong>showAsAction 在as 中 会报错  要添加 xmlns:app=”<a href="http://schemas.android.com/apk/res-auto" target="_blank" rel="external">http://schemas.android.com/apk/res-auto</a>“  引用</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; &gt;
    &lt;!--
        item 中通还可以有menu  : 表示的为 子菜单;
        menuCategroy:属性可以控制菜单项的位置
        orderInCategory 同种类菜单进行排序
        title: 菜单显示的文本
        titleCondensed：菜单项的短标题。当菜单项标题太长时会显示该属性值
        icon: 设置图标
        alphabeticShortcut:添加菜单项的字母快捷键
        numericShortcut：添加菜单项的数字快捷键
        checkable：表示菜单项是否带复选框。该属性可设计为true或false
        checked：如果菜单项带复选框(checkable属性为true)，该属性表示复选框默认状态是否被选中。可设置的值为true或false
        visible：菜单项默认状态是否可视 true|false
        enable：菜单项默认状态是否被激活 是否是可用的
        showAsAction:
            ifRoom: 如果溢出就会隐藏 溢出来的部分
            never:永远不会显示。只会在溢出列表中显示，而且只显示标题，所以在定义item的时候，最好把标题都带上。
            always : 不管是是否溢出都会显示
            withText: 只显示文本
            collapseActionView:声明了这个操作视窗应该被折叠到一个按钮中，当用户选择这个按钮时，
                        这个操作视窗展开。否则，这个操作视窗在默认的情况下是可见的，
                        并且即便在用于不适用的时候，也要占据操作栏的有效空间。
                        一般要配合ifRoom一起使用才会有效果。
        --&gt;
    &lt;item
        android:id=&quot;@+id/action_add&quot;
        android:orderInCategory=&quot;1&quot;
        app:showAsAction=&quot;never&quot;
        android:title=&quot;呵呵哒&quot; /&gt;

    &lt;item
        android:id=&quot;@+id/delete&quot;
        android:orderInCategory=&quot;2&quot;
        app:showAsAction=&quot;never&quot;
        android:title=&quot;萌萌哒&quot; /&gt;
&lt;/menu&gt;
</code></pre><hr>
<pre><code>   ///////////////////  创建一个选项菜单
/**
 * 创建一个选项菜单
 * @param menu
 * @return
 */
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.menu, menu);
//        menu.add(1,1,1,&quot;add&quot;);
//        menu.add(1,2,1,&quot;delete&quot;);
    return true;
}
/**
 * 当菜单选项被单击的时候
 * @param
 * @return
 */
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()){
        case R.id.action_add:
            toast(&quot;add&quot;);
            break;
        case R.id.delete:
            toast(&quot;delete&quot;);
            break;
        default:
            break;
    }
    return super.onOptionsItemSelected(item);
}
</code></pre><p><strong>上下文菜单</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
&lt;item
    android:id=&quot;@+id/a&quot;
    android:title=&quot;a&quot;
    android:orderInCategory=&quot;1&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
&lt;item
    android:id=&quot;@+id/b&quot;
    android:title=&quot;b&quot;
    android:orderInCategory=&quot;2&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
&lt;item
    android:id=&quot;@+id/c&quot;
    android:title=&quot;c&quot;
    android:orderInCategory=&quot;3&quot;
    app:showAsAction=&quot;ifRoom&quot;
    /&gt;
</code></pre><p></p>
<hr>
<pre><code>list = (ListView) findViewById(R.id.listview);
    String[] listItem = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;};
    ArrayAdapter&lt;String&gt; adpater = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, listItem);
    list.setAdapter(adpater);

    registerForContextMenu(list);//为 listview 注册一个菜单

///////              创建一个上下文菜单
/**
 * 导入你所需的菜单
 * @param menu
 * @param v
 * @param menuInfo
 */
@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    getMenuInflater().inflate(R.menu.item, menu);
}

/**
 * 当 listview中的item 长按的时候
 * @param item
 * @return
 */
@Override
public boolean onContextItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.a:
            toast(&quot;a&quot;);
            break;
        case R.id.b:
            toast(&quot;b&quot;);
            break;
        default:
            break;
    }
    return super.onContextItemSelected(item);
}
</code></pre><p><strong>子菜单</strong></p>
<pre><code> /////////////////////////////// 创建子菜单
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    SubMenu a = menu.addSubMenu(1, 1, 1, &quot;hehe&quot;);
    a.setHeaderTitle(&quot;想你了&quot;);
    a.setHeaderIcon(R.mipmap.ic_launcher);
    a.add(1, 1, 1, &quot;a&quot;);
    a.add(1, 2, 1, &quot;b&quot;);
    SubMenu b = menu.addSubMenu(2, 1, 1, &quot;heihei&quot;);
    b.setHeaderTitle(&quot;不想你了&quot;);
    b.add(2, 1, 1, &quot;c&quot;);
    b.add(2, 2, 1, &quot;d&quot;);
    return true;
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {

    if (item.getGroupId() == 1) {
        switch (item.getItemId()) {
            case 1:
                toast(&quot;a&quot;);
                break;
            case 2:
                toast(&quot;b&quot;);
                break;
            default:
                break;
        }
    }else if (item.getGroupId() == 2) {
        switch (item.getItemId()) {
            case 1:
                toast(&quot;c&quot;);
                break;
            case 2:
                toast(&quot;d&quot;);
                break;
            default:
                break;
        }
    }


    return super.onOptionsItemSelected(item);
}
public void toast(String str) {
    Toast.makeText(this, str, Toast.LENGTH_SHORT).show();
}
</code></pre><p><strong>Popup弹出菜单</strong></p>
<pre><code>// 点击一个 按钮时:
@Override
public void onClick(View v) {
    switch (v.getId()){
        case R.id.PopupMenu:
            //建立PopupMenu对象
            PopupMenu popup = new PopupMenu(MainActivity.this, v);
            //压入XML资源文件
            popup.getMenuInflater().inflate(R.menu.menu,popup.getMenu());
            //设置点击菜单选项事件
            popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
                @Override
                public boolean onMenuItemClick(MenuItem item) {
                    switch (item.getItemId()){
                        case R.id.action_add:
                            toast(&quot;add&quot;);
                            break;
                        case R.id.delete:
                            toast(&quot;delete&quot;);
                            break;
                        default:
                            break;
                    }
                    return true;
                }
            });
            //显示菜单
            popup.show();
            break;
        default:
            break;
    }
}
</code></pre><p><strong>ActionMode 导航菜单</strong></p>
<pre><code>modeAction.setOnLongClickListener(new View.OnLongClickListener() {
      @Override
      public boolean onLongClick(View v) {
          if(actionMode != null) {
              return false;
          }
          // 这里在start时， 也是可以得到 ActionMode的
          actionMode = startActionMode(new ActionMode.Callback() {
              @Override
              public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                  menu.add(1, 1, 1, &quot;hehe&quot;);
                  menu.add(1, 2, 1, &quot;jjj&quot;);
                  menu.add(1, 3, 1, &quot;ggg&quot;);
                  return true;
              }

              @Override
              public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                  return false;
              }

              @Override
              public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
                  switch (item.getItemId()) {
                      case 1:
                          toast(&quot;1&quot;);
                          break;
                      case 2:
                          toast(&quot;2&quot;);
                          break;
                      case 3:
                          toast(&quot;3&quot;);
                          break;
                      default:
                          break;
                  }
                  return false;
              }

              @Override
              public void onDestroyActionMode(ActionMode mode) {
                  actionMode = null;
              }
          });
          v.setSelected(true);        //设置为可选
          return true;
      }
  });
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Layout]]></title>
      <url>http://liugch.top/2016/09/25/shapeAndview/</url>
      <content type="html"><![CDATA[<h1 id="布局的优化"><a href="#布局的优化" class="headerlink" title="布局的优化"></a>布局的优化</h1><blockquote>
<p>尽量的使用 include merge </p>
<p>劲量不要嵌套的太多的布局</p>
<p>一般不要 RelativeLayout 里面再次嵌套 RelativeLayout</p>
</blockquote>
<h2 id="布局的一些简化操作"><a href="#布局的一些简化操作" class="headerlink" title="布局的一些简化操作"></a>布局的一些简化操作</h2><pre><code> &lt;LinearLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;120dp&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;ImageView
        android:layout_width=&quot;120dp&quot;
        android:layout_height=&quot;120dp&quot;
        android:layout_margin=&quot;5dp&quot;
        android:src=&quot;@drawable/touxiang&quot; /&gt;
    &lt;!--
    ineSpacingExtra属性代表的是行间距，他默认是0，是一个绝对高度值。
    同时还有lineSpacingMultiplier属性， 它代表行间距倍数，默认为1.0f，是一个相对高度值。
    android:text=&quot;你好\n第三方\n大都饭店&quot; 自动回帮你换行
    --&gt;
    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:gravity=&quot;center_vertical&quot;
        android:lineSpacingMultiplier=&quot;2&quot;
        android:text=&quot;你好\n第三方\n大都饭店&quot;
        android:textSize=&quot;14sp&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><blockquote>
<p>定义 一个shape的XML</p>
<p>调用 自定义的 shape 设置包含item的分割线</p>
<p>item中的间隔我可以 放弃 view 和 margin 用 space 使用</p>
</blockquote>
<p><strong>类似的效果图</strong></p>
<p><img src="http://i.imgur.com/bV20OlF.png" alt=""></p>
<p><strong>divider.xml</strong></p>
<pre><code>&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;size
    android:width=&quot;1dp&quot;
    android:height=&quot;1dp&quot;/&gt;
&lt;solid
    android:color=&quot;#e1e1e1&quot;/&gt;
&lt;/shape&gt;
</code></pre><p><strong>布局</strong>    </p>
<pre><code>&lt;!--
    divider:调用 定义的shape  
    showDividers:分割线显示的位置
    android:drawableLeft=&quot;@mipmap/shebei
    Space: 设置 间隔
 --&gt;
&lt;LinearLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:divider=&quot;@drawable/divider&quot;
    android:showDividers=&quot;middle|beginning|end&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;
    &lt;Space
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;30dp&quot; /&gt;
    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;40dp&quot;
        android:background=&quot;#ffffff&quot;
        android:drawableLeft=&quot;@mipmap/shebei&quot;
        android:drawablePadding=&quot;5dp&quot;
        android:drawableRight=&quot;@drawable/right&quot;
        android:gravity=&quot;center_vertical&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:paddingRight=&quot;5dp&quot;
        android:text=&quot;我的设备&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p><strong>TextView 实现超链接</strong></p>
<p>效果图:</p>
<p><img src="http://i.imgur.com/LUa8sx6.png" alt=""></p>
<pre><code>//布局
 &lt;TextView
    android:id=&quot;@+id/text&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:autoLink=&quot;all&quot; /&gt;

// activity
 text=(TextView) findViewById(R.id.text);
    String texts = &quot;网址：http://www.baidu.com&quot;+&quot;\n&quot;;
    texts += &quot;邮箱:88888888@qq.com&quot;+&quot;\n&quot;;
    texts += &quot;电话：13888888888&quot; +&quot;\n&quot;;
    text.setText(texts);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客搭建]]></title>
      <url>http://liugch.top/2016/09/25/hexo/</url>
      <content type="html"><![CDATA[<h1 id="1-Hexo简介"><a href="#1-Hexo简介" class="headerlink" title="1.Hexo简介"></a>1.Hexo简介</h1><p>Hexo是一款基于Node.js 的静态博客框架，并且使用Markdown来解析文章的，本地安装Hexo后，可以利用git版本控制工具来操作Hexo,利用Hexo的主题来自动生成静态的网页。&lt;属于个人的理解&gt;</p>
<a id="more"></a>
<p>查考：<a href="https://hexo.io/zh-cn/docs/" title="Hexo帮助文档" target="_blank" rel="external">Hexo的帮助文档重要 </a></p>
<h1 id="2-博客环境的搭建"><a href="#2-博客环境的搭建" class="headerlink" title="2.博客环境的搭建"></a>2.博客环境的搭建</h1><h2 id="一、安装Git"><a href="#一、安装Git" class="headerlink" title="一、安装Git"></a>一、安装Git</h2><blockquote>
<p>下载地址  <a href="https://git-scm.com/download" title="Git下载地址" target="_blank" rel="external">https://git-scm.com/download</a></p>
</blockquote>
<h2 id="二、安装Node-js"><a href="#二、安装Node-js" class="headerlink" title="二、安装Node.js"></a>二、安装Node.js</h2><blockquote>
<p>下载地址  <a href="http://nodejs.cn/download/" title="Node.js下载地址" target="_blank" rel="external">http://nodejs.cn/download/</a></p>
</blockquote>
<h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>Git和Node.js 安装好后，在一个合适的位置新建一个文件夹（英文的比较好），之后就开始使用Hexo了。</p>
<blockquote>
<p>Hexo的安装并初始化</p>
</blockquote>
<pre><code>$ npm install -g hexo-cli
$ hexo init
</code></pre><p>安装Hexo后会在该文件夹下生成如下的文件</p>
<pre><code>├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><p>其中_config.yml文件用于存放网站的配置信息，你可以在此配置大部分的参数；scaffolds是存放模板的文件夹，当新建文章时，Hexo 会根据scaffold来建立文件；source是资源文件夹，用于存放用户资源，themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。</p>
<blockquote>
<p>生成静态的博文</p>
</blockquote>
<p>在Git Bash终端执行命令：</p>
<pre><code>1  hexo g
2  hexo s
</code></pre><p>可以组合起来使用：</p>
<pre><code>hexo s -g
</code></pre><p>执行完之后：</p>
<p>Hexo将source文件夹中的 Markdown 和 HTML 文件会被解析并放到public文件夹中，public文件夹用于存放静态博客文件，相当于网站根目录。</p>
<blockquote>
<p>至此简单的博客已经搭建完毕  访问：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a></p>
</blockquote>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Oralce的世界]]></title>
      <url>http://liugch.top/2016/09/24/index/</url>
      <content type="html"><![CDATA[<h1 id="Oracle-的体系结构"><a href="#Oracle-的体系结构" class="headerlink" title="Oracle 的体系结构"></a>Oracle 的体系结构</h1><p>数据库是一个以某种有组织的方式存储的数据集合。 它本质上是用计算机存储记录的系统，是位于用户和系统之间的一层管理软件。 Oracle 数据库是目前最流行、最强大的面向对象的关系型数据库(ORDBMS)。</p>
<a id="more"></a>
<p>Oracle 是基于请求响应的方式，分为服务端和客户端。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>Oracle 是由实例和数据库两部分组成</p>
<h3 id="实例-INSTANCE"><a href="#实例-INSTANCE" class="headerlink" title="实例 (INSTANCE)"></a><strong>实例 (INSTANCE)</strong></h3><p> 又称为oracle数据库引擎，由由内存即SGA(System Global Area,系统全局区)和后台处理进程组成。</p>
<h3 id="数据库-DATEBASE"><a href="#数据库-DATEBASE" class="headerlink" title="数据库(DATEBASE)"></a><strong>数据库(DATEBASE)</strong></h3><p> 保存在计算机上的数据文件等。可以从物理物件或逻辑组件的角度看待。</p>
<h4 id="物理组件"><a href="#物理组件" class="headerlink" title="物理组件"></a>物理组件</h4><ol>
<li><p><strong>控制文件 (Control File)</strong></p>
<pre><code>select * from v$controlfile;
</code></pre><p>记录数据库的物理结构和其他控制信息，如数据库名称，数据文件、日志文件名称和位置等。多副本保证安全。</p>
</li>
<li><p><strong>数据文件 (Data File)</strong></p>
<pre><code>select name,status,enabled from v$datafile;
</code></pre></li>
<li><p><strong> 日志文件 (联机日志文件/归档日志文件)</strong></p>
<pre><code>select * from v$log;   -- 查看日志
</code></pre><p>保存用户的所有操作。一个数据库至少有两个日志组，轮流写入。<br>每个日志组至少有一个日志成员，成员之间是镜像关系，这是为了保护数据。<br>联机日志组的交换过程叫切换。当一个组写完会自动切换下一组，也可以手动切换：</p>
<pre><code>alter system switch logfile   -- 切换日志文件
</code></pre><p>如果打开归档模式，切换日志的时候会产生归档文件。打开归档模式命令:</p>
<pre><code>alter database archivelog
</code></pre></li>
<li><p><strong>初始化参数文件 (Parameter File)</strong></p>
<pre><code>位置:
$ORA_HOME/admin/&lt;SID&gt;/pfile/init.ora.xxx
</code></pre></li>
</ol>
<h4 id="逻辑组件"><a href="#逻辑组件" class="headerlink" title="逻辑组件"></a>逻辑组件</h4><ul>
<li><p><strong>表空间</strong></p>
<pre><code>select * from v$tablespace;--查询所有的表空间
</code></pre></li>
</ul>
<ol>
<li>最基本的逻辑结构 ，是数据库恢复的最小单位, 容纳着许多数据库实体, 如表、视图、索引、聚簇、回退段和临时段等。</li>
<li>默认创建的表空间有 SYSTEM/SYSAUX/TEMP/UNDO/USERS</li>
<li>表空间跟数据文件是 1vN 的关系。一个表空间至少需要一个相应的数据文件</li>
<li>在实际生产中，不建议用默认表空间，要根据情况自己创建</li>
<li><p>创建/删除表空间的语法：</p>
<pre><code>--表空间创建
create tablespace xxx
datafile &apos;D:\xxx.dbf&apos;
size 50m
autoextend on
next 50m maxsize 20480m
extent management local;

-- 创建临时表空间
create temporary tablespace yyy
tempfile &apos;D:\yyy.dbf&apos;;

-- 删除
drop tablespace yyy;
</code></pre></li>
<li>逻辑上说，一个表空间是由一到多个段组成的。</li>
</ol>
<ul>
<li><strong>段 (Segment)</strong></li>
</ul>
<ol>
<li>段是对象在数据库中占用的空间</li>
<li>每个段，对应的是每个对象，有 table/index/view 等</li>
<li>按照存储对象类型的不同，分为数据段、索引段、回滚段和临时段</li>
<li>逻辑上说，段是由区组成的</li>
</ol>
<ul>
<li><strong> 区 (Extend)</strong></li>
</ul>
<ol>
<li>由连续的数据块组成，由 Oracle 自动分配管理</li>
<li>当段中的空间已满时，会自动扩展新区</li>
</ol>
<ul>
<li><strong>块</strong></li>
</ul>
<ol>
<li>数据块是Oracle服务器所能分配、读取或写入的最小逻辑单位。</li>
<li>Oracle服务器以数据块为单位管理数据文件的存储空间。</li>
<li>正常情况下，块的大小是操作系统块的整数倍，称作标准块。</li>
<li>可以通过参数 db_block_size 控制，默认 8k.</li>
</ol>
<blockquote>
<p>启动过程</p>
</blockquote>
<pre><code>startup nomount        -- 只启动了实例 (Instance)
alter database mount   -- 数据库挂载
alter database open    -- 数据库打开
shutdown immediate     -- 立刻关闭
</code></pre><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="连接语法"><a href="#连接语法" class="headerlink" title="连接语法"></a>连接语法</h2><pre><code>sqlplus sys/southit as sysdba     -- 管理员登录
sqlplus / as sysdba               -- 操作系统认证
sqlplus scott/tiger               -- 普通用户登录
sqlplus scott/tiger@remotedb      -- 连接远程数据库
 -- 未连接状态，之后可以用 conn user/pass 语法登录
sqlplus /nolog                    
</code></pre><hr>
<h1 id="Oracle-网络配置"><a href="#Oracle-网络配置" class="headerlink" title="Oracle 网络配置"></a>Oracle 网络配置</h1><h2 id="配置途径"><a href="#配置途径" class="headerlink" title="配置途径"></a>配置途径</h2><ul>
<li><p><code>直接修改 NETWORK/ADMIN 下的配置文件</code><br>  通过 Oracle 的 Net Manager 工具配置<br>  服务端 (NETWORK/ADMIN/listener.ora)</p>
</li>
<li><p><code>直接修改配置文件或通过图形界面配置。</code><br>  主要配置元素有：<br>  协议 (TCP/IP)<br>  连接地址<br>  端口号 (默认1521，一般不需要修改)<br>  开启 TNSListener 服务</p>
</li>
</ul>
<hr>
<h1 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>用户是用于资源控制和权限管理的一个概念<br>开始新的项目时，保持良好的习惯： 为项目创建新的用户，指定新的表空间。</p>
<blockquote>
<p>系统缺省用户</p>
</blockquote>
<p><strong>SYS 用户</strong></p>
<pre><code>又叫特权用户，数据库中至高无上的用户。
它是数据库的系统管理员，负责的是数据的安装、维护、升级、备份、恢复、优化等操作。
不能用 normal 的身份登录，必须用 SYSDBA/SYSOPER 的身份登录。
即使其他的用户用 SYSDBA/SYSOPER 的身份登录，实际上登录的也是 SYS。
</code></pre><p><strong>SYSTEM 用户</strong></p>
<pre><code>数据库的管理员。SYSTEM 用户之下保存着数据库运行的一些基本字典数据。
它拥有 DBA 的角色。主要负责对数据库中各种对象，各种资源的管理。
</code></pre><p><strong>其他用户 (如SCOTT)</strong></p>
<pre><code>普通用户，能够执行被授权范围之内的操作。
</code></pre>]]></content>
    </entry>
    
  
  
</search>
